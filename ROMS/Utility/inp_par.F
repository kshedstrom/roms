#include "cppdefs.h"
      SUBROUTINE inp_par (model)
!
!svn $Id$
!================================================== Hernan G. Arango ===
!  Copyright (c) 2002-2011 The ROMS/TOMS Group                         !
!    Licensed under a MIT/X style license                              !
!    See License_ROMS.txt                                              !
!=======================================================================
!                                                                      !
!  This routine reads in input model parameters from standard input.   !
!  It also writes out these parameters to standard output.             !
!                                                                      !
!=======================================================================
!
#ifdef FILTERED
      USE mod_filter, ONLY: nfil,fcount,nw,dtfil,FILN
#endif
      USE mod_param
      USE mod_parallel
      USE mod_iounits
      USE mod_ncparam
      USE mod_scalars
#ifdef DISTRIBUTE
      USE mod_strings
#endif
!
#ifdef DISTRIBUTE
      USE distribute_mod, ONLY : mp_bcasti, mp_bcasts
#endif
      USE ran_state, ONLY: ran_seed
!
      implicit none
!
!  Imported variable declarations.
!
      integer, intent(in) :: model
!
!  Local variable declarations.
!
      logical :: Lwrite

      integer :: Itile, Jtile, Nghost, Ntiles, tile
      integer :: Imin, Imax, Jmin, Jmax
#ifdef DISTRIBUTE
      integer :: MaxHaloLenI, MaxHaloLenJ
#endif
      integer :: ifile, inp, out, itrc, ng, npts, sequence

      real(r8) :: cff
      real(r8), parameter :: spv = 0.0_r8
      character*2 :: ngnumber
!
!-----------------------------------------------------------------------
!  Read in and report input model parameters.
!-----------------------------------------------------------------------
!
!  Set input units.
!
#if defined DISTRIBUTE || defined MODEL_COUPLING
      Lwrite=Master
      inp=1
      out=stdout
#else
      Lwrite=Master
      inp=stdinp
      out=stdout
#endif
!
!  Get current date.
!
#ifndef NO_DATE_STAMP
# ifdef DISTRIBUTE
      IF (Master) CALL get_date (date_str)
      CALL mp_bcasts (1, model, date_str)
# else
      CALL get_date (date_str)
# endif
#endif
!
!-----------------------------------------------------------------------
!  Read in physical model input parameters.
!-----------------------------------------------------------------------
!
      IF (Lwrite) WRITE (out,10) version, TRIM(date_str)
 10   FORMAT (/,' Model Input Parameters:  ROMS/TOMS version ',a,/,     &
     &       26x,a,/,1x,77('-'))

#ifdef MODEL_COUPLING
!
!  In multiple model coupling, the ocean input physical parameter
!  script needs to be opened and processed as a regular file.
!  Its file name is specified in the coupling standard input script.
!
      OPEN (inp, FILE=TRIM(Iname), FORM='formatted', STATUS='old',      &
     &      ERR=20)
      GO TO 40
 20   IF (Master) WRITE (stdout,30)
      exit_flag=2
      RETURN
 30   FORMAT (/,' INP_PAR - Unable to open ROMS/TOMS input script ',    &
     &              'file.')
 40   CONTINUE

#else
# ifdef DISTRIBUTE
!
!  In distributed-memory configurations, the input physical parameters
!  script is opened as a regular file.  It is read and processed by all
!  parallel nodes.  This is to avoid a very complex broadcasting of the
!  input parameters to all nodes.
!
!!    CALL my_getarg (1, Iname)
      IF (Master) CALL my_getarg (1, Iname)
      CALL mp_bcasts (1, model, Iname)
      OPEN (inp, FILE=TRIM(Iname), FORM='formatted', STATUS='old',      &
     &      ERR=20)
      GO TO 40
 20   IF (Master) WRITE (stdout,30)
      exit_flag=2
      RETURN
 30   FORMAT (/,' INP_PAR - Unable to open ROMS/TOMS input script ',    &
     &              'file.',                                            &
     &        /,11x,'In distributed-memory applications, the input',    &
     &        /,11x,'script file is processed in parallel. The Unix',   &
     &        /,11x,'routine GETARG is used to get script file name.',  &
     &        /,11x,'For example, in MPI applications make sure that',  &
     &        /,11x,'command line is something like:',/,                &
     &        /,11x,'mpirun -np 4 ocean ocean.in',/,/,11x,'and not',/,  &
     &        /,11x,'mpirun -np 4 ocean < ocean.in',/)
 40   CONTINUE
# endif
#endif

      CALL read_PhyPar (model, inp, out, Lwrite)
#ifdef DISTRIBUTE
      CALL mp_bcasti (1, model, exit_flag)
#endif
      IF (exit_flag.ne.NoError) RETURN
!
!-----------------------------------------------------------------------
!  Set lower and upper bounds indices per domain partition for all
!  nested grids.
!-----------------------------------------------------------------------
!
!  Set boundary edge I- or J-indices for each variable type.
!
      DO ng=1,Ngrids
        BOUNDS(ng) % edge(iwest ,p2dvar) = 1
        BOUNDS(ng) % edge(iwest ,r2dvar) = 0
        BOUNDS(ng) % edge(iwest ,u2dvar) = 1
        BOUNDS(ng) % edge(iwest ,v2dvar) = 0

        BOUNDS(ng) % edge(ieast ,p2dvar) = Lm(ng)+1
        BOUNDS(ng) % edge(ieast ,r2dvar) = Lm(ng)+1
        BOUNDS(ng) % edge(ieast ,u2dvar) = Lm(ng)+1
        BOUNDS(ng) % edge(ieast ,v2dvar) = Lm(ng)+1

        BOUNDS(ng) % edge(isouth,p2dvar) = 1
        BOUNDS(ng) % edge(isouth,u2dvar) = 0
        BOUNDS(ng) % edge(isouth,r2dvar) = 0
        BOUNDS(ng) % edge(isouth,v2dvar) = 1

        BOUNDS(ng) % edge(inorth,p2dvar) = Mm(ng)+1
        BOUNDS(ng) % edge(inorth,r2dvar) = Mm(ng)+1
        BOUNDS(ng) % edge(inorth,u2dvar) = Mm(ng)+1
        BOUNDS(ng) % edge(inorth,v2dvar) = Mm(ng)+1
      END DO
!
!  Set logical switches needed when processing variables in tiles
!  adjacent to the domain boundary edges or corners.  This needs to
!  be computed first since these switches are used in "get_tile".
!
      DO ng=1,Ngrids
        DO tile=-1,NtileI(ng)*NtileJ(ng)-1
          CALL get_domain_edges (ng, tile,                              &
     &                           DOMAIN(ng) % Eastern_Edge    (tile),   &
     &                           DOMAIN(ng) % Western_Edge    (tile),   &
     &                           DOMAIN(ng) % Northern_Edge   (tile),   &
     &                           DOMAIN(ng) % Southern_Edge   (tile),   &
     &                           DOMAIN(ng) % NorthEast_Corner(tile),   &
     &                           DOMAIN(ng) % NorthWest_Corner(tile),   &
     &                           DOMAIN(ng) % SouthEast_Corner(tile),   &
     &                           DOMAIN(ng) % SouthWest_Corner(tile),   &
     &                           DOMAIN(ng) % NorthEast_Test  (tile),   &
     &                           DOMAIN(ng) % NorthWest_Test  (tile),   &
     &                           DOMAIN(ng) % SouthEast_Test  (tile),   &
     &                           DOMAIN(ng) % SouthWest_Test  (tile))
        END DO
      END DO
!
!  Set tile computational indices and arrays allocation bounds
!
      Nghost=GHOST_POINTS
      DO ng=1,Ngrids
        BOUNDS(ng) % LBij = 0
        BOUNDS(ng) % UBij = MAX(Lm(ng)+1,Mm(ng)+1)
        DO tile=-1,NtileI(ng)*NtileJ(ng)-1
          BOUNDS(ng) % tile(tile) = tile
          CALL get_tile (ng, tile, Itile, Jtile,                        &
     &                   BOUNDS(ng) % Istr   (tile),                    &
     &                   BOUNDS(ng) % Iend   (tile),                    &
     &                   BOUNDS(ng) % Jstr   (tile),                    &
     &                   BOUNDS(ng) % Jend   (tile),                    &
     &                   BOUNDS(ng) % IstrM  (tile),                    &
     &                   BOUNDS(ng) % IstrR  (tile),                    &
     &                   BOUNDS(ng) % IstrU  (tile),                    &
     &                   BOUNDS(ng) % IendR  (tile),                    &
     &                   BOUNDS(ng) % JstrM  (tile),                    &
     &                   BOUNDS(ng) % JstrR  (tile),                    &
     &                   BOUNDS(ng) % JstrV  (tile),                    &
     &                   BOUNDS(ng) % JendR  (tile),                    &
     &                   BOUNDS(ng) % IstrB  (tile),                    &
     &                   BOUNDS(ng) % IendB  (tile),                    &
     &                   BOUNDS(ng) % IstrP  (tile),                    &
     &                   BOUNDS(ng) % IendP  (tile),                    &
     &                   BOUNDS(ng) % IstrT  (tile),                    &
     &                   BOUNDS(ng) % IendT  (tile),                    &
     &                   BOUNDS(ng) % JstrB  (tile),                    &
     &                   BOUNDS(ng) % JendB  (tile),                    &
     &                   BOUNDS(ng) % JstrP  (tile),                    &
     &                   BOUNDS(ng) % JendP  (tile),                    &
     &                   BOUNDS(ng) % JstrT  (tile),                    &
     &                   BOUNDS(ng) % JendT  (tile),                    &
     &                   BOUNDS(ng) % Istrm3 (tile),                    &
     &                   BOUNDS(ng) % Istrm2 (tile),                    &
     &                   BOUNDS(ng) % Istrm1 (tile),                    &
     &                   BOUNDS(ng) % IstrUm2(tile),                    &
     &                   BOUNDS(ng) % IstrUm1(tile),                    &
     &                   BOUNDS(ng) % Iendp1 (tile),                    &
     &                   BOUNDS(ng) % Iendp2 (tile),                    &
     &                   BOUNDS(ng) % Iendp2i(tile),                    &
     &                   BOUNDS(ng) % Iendp3 (tile),                    &
     &                   BOUNDS(ng) % Jstrm3 (tile),                    &
     &                   BOUNDS(ng) % Jstrm2 (tile),                    &
     &                   BOUNDS(ng) % Jstrm1 (tile),                    &
     &                   BOUNDS(ng) % JstrVm2(tile),                    &
     &                   BOUNDS(ng) % JstrVm1(tile),                    &
     &                   BOUNDS(ng) % Jendp1 (tile),                    &
     &                   BOUNDS(ng) % Jendp2 (tile),                    &
     &                   BOUNDS(ng) % Jendp2i(tile),                    &
     &                   BOUNDS(ng) % Jendp3 (tile))

          CALL get_bounds (ng, tile, 0, Nghost, Itile, Jtile,           &
     &                     BOUNDS(ng) % LBi(tile),                      &
     &                     BOUNDS(ng) % UBi(tile),                      &
     &                     BOUNDS(ng) % LBj(tile),                      &
     &                     BOUNDS(ng) % UBj(tile))
        END DO
      END DO
!
!  Set I/O processing minimum (Imin, Jmax) and maximum (Imax, Jmax)
!  indices for non-overlapping (Nghost=0) and overlapping (Nghost>0)
!  tiles for each C-grid type variable.
!
      Nghost=GHOST_POINTS
      DO ng=1,Ngrids
        DO tile=0,NtileI(ng)*NtileJ(ng)-1
          CALL get_bounds (ng, tile, p2dvar, 0     , Itile, Jtile,      &
     &                     BOUNDS(ng) % Imin(1,0,tile),                 &
     &                     BOUNDS(ng) % Imax(1,0,tile),                 &
     &                     BOUNDS(ng) % Jmin(1,0,tile),                 &
     &                     BOUNDS(ng) % Jmax(1,0,tile))
          CALL get_bounds (ng, tile, p2dvar, Nghost, Itile, Jtile,      &
     &                     BOUNDS(ng) % Imin(1,1,tile),                 &
     &                     BOUNDS(ng) % Imax(1,1,tile),                 &
     &                     BOUNDS(ng) % Jmin(1,1,tile),                 &
     &                     BOUNDS(ng) % Jmax(1,1,tile))

          CALL get_bounds (ng, tile, r2dvar, 0     , Itile, Jtile,      &
     &                     BOUNDS(ng) % Imin(2,0,tile),                 &
     &                     BOUNDS(ng) % Imax(2,0,tile),                 &
     &                     BOUNDS(ng) % Jmin(2,0,tile),                 &
     &                     BOUNDS(ng) % Jmax(2,0,tile))
          CALL get_bounds (ng, tile, r2dvar, Nghost, Itile, Jtile,      &
     &                     BOUNDS(ng) % Imin(2,1,tile),                 &
     &                     BOUNDS(ng) % Imax(2,1,tile),                 &
     &                     BOUNDS(ng) % Jmin(2,1,tile),                 &
     &                     BOUNDS(ng) % Jmax(2,1,tile))

          CALL get_bounds (ng, tile, u2dvar, 0     , Itile, Jtile,      &
     &                     BOUNDS(ng) % Imin(3,0,tile),                 &
     &                     BOUNDS(ng) % Imax(3,0,tile),                 &
     &                     BOUNDS(ng) % Jmin(3,0,tile),                 &
     &                     BOUNDS(ng) % Jmax(3,0,tile))
          CALL get_bounds (ng, tile, u2dvar, Nghost, Itile, Jtile,      &
     &                     BOUNDS(ng) % Imin(3,1,tile),                 &
     &                     BOUNDS(ng) % Imax(3,1,tile),                 &
     &                     BOUNDS(ng) % Jmin(3,1,tile),                 &
     &                     BOUNDS(ng) % Jmax(3,1,tile))

          CALL get_bounds (ng, tile, v2dvar, 0     , Itile, Jtile,      &
     &                     BOUNDS(ng) % Imin(4,0,tile),                 &
     &                     BOUNDS(ng) % Imax(4,0,tile),                 &
     &                     BOUNDS(ng) % Jmin(4,0,tile),                 &
     &                     BOUNDS(ng) % Jmax(4,0,tile))
          CALL get_bounds (ng, tile, v2dvar, Nghost, Itile, Jtile,      &
     &                     BOUNDS(ng) % Imin(4,1,tile),                 &
     &                     BOUNDS(ng) % Imax(4,1,tile),                 &
     &                     BOUNDS(ng) % Jmin(4,1,tile),                 &
     &                     BOUNDS(ng) % Jmax(4,1,tile))
        END DO
      END DO
!
!  Set NetCDF IO bounds.
!
      DO ng=1,Ngrids
        CALL get_iobounds (ng)
      END DO
!
!-----------------------------------------------------------------------
!  Check tile partition starting and ending (I,J) indices for illegal
!  domain decomposition parameters NtileI and NtileJ in standard input
!  file.
!-----------------------------------------------------------------------
!
      IF (Master) THEN
        DO ng=1,Ngrids
#ifdef SOLVE3D
          WRITE (stdout,50) ng, Lm(ng), Mm(ng), N(ng),                  &
     &                      NtileI(ng), NtileJ(ng)
#else
          WRITE (stdout,50) ng, Lm(ng), Mm(ng),                         &
     &                      NtileI(ng), NtileJ(ng)
#endif
          Print *,'Number of tracers: ', NT(ng)
#if !defined DISTRIBUTE && defined ADJOINT
          IF ((NtileI(ng).ne.1).or.(NtileJ(ng).ne.1)) THEN
            WRITE (stdout,60)
            exit_flag=6
            RETURN
          END IF
#endif
          DO tile=0,NtileI(ng)*NtileJ(ng)-1
#ifdef SOLVE3D
            npts=(BOUNDS(ng)%Iend(tile)-                                &
     &            BOUNDS(ng)%Istr(tile)+1)*                             &
     &           (BOUNDS(ng)%Jend(tile)-                                &
     &            BOUNDS(ng)%Jstr(tile)+1)*N(ng)
#else
            npts=(BOUNDS(ng)%Iend(tile)-                                &
     &            BOUNDS(ng)%Istr(tile)+1)*                             &
     &           (BOUNDS(ng)%Jend(tile)-                                &
     &            BOUNDS(ng)%Jstr(tile)+1)
#endif
            WRITE (stdout,70) tile,                                     &
     &                        BOUNDS(ng)%Istr(tile),                    &
     &                        BOUNDS(ng)%Iend(tile),                    &
     &                        BOUNDS(ng)%Jstr(tile),                    &
     &                        BOUNDS(ng)%Jend(tile),                    &
     &                        npts
            IF ((BOUNDS(ng)%Iend(tile)-                                 &
     &           BOUNDS(ng)%Istr(tile)+1).lt.2) THEN
              WRITE (stdout,80) ng, 'NtileI = ', NtileI(ng),            &
     &                              'Lm = ', Lm(ng),                    &
     &                              'Istr = ', BOUNDS(ng)%Istr(tile),   &
     &                              '  Iend = ', BOUNDS(ng)%Iend(tile), &
     &                              'NtileI'
              exit_flag=6
              RETURN
            END IF
            IF ((BOUNDS(ng)%Jend(tile)-                                 &
     &           BOUNDS(ng)%Jstr(tile)+1).lt.2) THEN
              WRITE (stdout,80) ng, 'NtileJ = ', NtileJ(ng),            &
     &                              'Mm = ', Mm(ng),                    &
     &                              'Jstr = ', BOUNDS(ng)%Jstr(tile),   &
     &                              '  Jend = ', BOUNDS(ng)%Jend(tile), &
     &                              'NtileJ'
              exit_flag=6
              RETURN
            END IF
          END DO
        END DO
#ifdef SOLVE3D
 50     FORMAT (/,' Tile partition information for Grid ',i2.2,':',2x,  &
     &          i4.4,'x',i4.4,'x',i4.4,2x,'tiling: ',i3.3,'x',i3.3,/,/, &
     &          5x,'tile',5x,'Istr',5x,'Iend',5x,'Jstr',5x,'Jend',      &
     &          5x,'Npts',/)
#else
 50     FORMAT (/,' Tile partition information for Grid ',i2.2,':',2x,  &
     &          i4.4,'x',i4.4,2x,'tiling: ',i3.3,'x',i3.3,/,/,          &
     &          5x,'tile',5x,'Istr',5x,'Iend',5x,'Jstr',5x,'Jend',      &
     &          5x,'Npts',/)
#endif
#if !defined DISTRIBUTE && defined ADJOINT
 60     FORMAT (/,' INP_PAR - illegal domain decomposition for the ',   &
     &                       'Adjoint model.',/,11x,'Partitions are ',  &
     &          'allowed in distributed-menory (MPI) applications.'/)
#endif
 70     FORMAT (5(5x,i4),2x,i7)
 80     FORMAT (/,' INP_PAR - domain decomposition error in input ',    &
     &                        'script file for grid: ',i2,/,            &
     &          /,11x,'The domain partition parameter, ',a,i3,          &
     &          /,11x,'is incompatible with grid size, ',a,i4,          &
     &          /,11x,'because it yields too small tile, ',a,i3,a,i3,   &
     &          /,11x,'Decrease partition parameter: ',a)
      END IF
#ifdef DISTRIBUTE
      CALL mp_bcasti (1, model, exit_flag)
#endif
      IF (exit_flag.ne.NoError) RETURN
!
!  Report tile minimum and maximum fractional grid coordinates.
!
      DO ng=1,Ngrids
        IF (Master) THEN
          WRITE (stdout,90)
          DO tile=0,NtileI(ng)*NtileJ(ng)-1
            WRITE (stdout,100) tile,                                    &
     &                         DOMAIN(ng)%Xmin_rho(tile),               &
     &                         DOMAIN(ng)%Xmax_rho(tile),               &
     &                         DOMAIN(ng)%Ymin_rho(tile),               &
     &                         DOMAIN(ng)%Ymax_rho(tile), 'RHO-points'
          END DO
          WRITE (stdout,'(1x)')
          DO tile=0,NtileI(ng)*NtileJ(ng)-1
            WRITE (stdout,100) tile,                                    &
     &                         DOMAIN(ng)%Xmin_u(tile),                 &
     &                         DOMAIN(ng)%Xmax_u(tile),                 &
     &                         DOMAIN(ng)%Ymin_u(tile),                 &
     &                         DOMAIN(ng)%Ymax_u(tile), '  U-points'
          END DO
          WRITE (stdout,'(1x)')
          DO tile=0,NtileI(ng)*NtileJ(ng)-1
            WRITE (stdout,100) tile,                                    &
     &                         DOMAIN(ng)%Xmin_v(tile),                 &
     &                         DOMAIN(ng)%Xmax_v(tile),                 &
     &                         DOMAIN(ng)%Ymin_v(tile),                 &
     &                         DOMAIN(ng)%Ymax_v(tile), '  V-points'
          END DO
 90       FORMAT (/,' Tile minimum and maximum fractional grid ',       &
     &            'coordinates:',/,                                     &
#ifdef FULL_GRID
     &            '   (interior and boundary points)',/,/,              &
#else
     &            '   (interior points only)',/,/,                      &
#endif
     &            5x,'tile',5x,'Xmin',5x,'Xmax',5x,'Ymin',5x,'Ymax',    &
     &            5x,'grid',/)
 100      FORMAT (5x,i4,4f9.2,2x,a)
        END IF
      END DO

#ifdef DISTRIBUTE
!
!-----------------------------------------------------------------------
!  Determine the maximum tile lengths in XI and ETA directions for
!  distributed-memory communications.  Notice that halo size are
!  increased by few points to allow exchanging of private arrays.
!-----------------------------------------------------------------------
!
# if defined EW_PERIODIC || defined NS_PERIODIC
      Nghost=1+GHOST_POINTS
# else
      Nghost=GHOST_POINTS
# endif
      DO ng=1,Ngrids
        MaxHaloLenI=0
        MaxHaloLenJ=0
        DO tile=0,NtileI(ng)*NtileJ(ng)-1
          Imin=BOUNDS(ng)%LBi(tile)-1
          Imax=BOUNDS(ng)%UBi(tile)+1
          Jmin=BOUNDS(ng)%LBj(tile)-1
          Jmax=BOUNDS(ng)%UBj(tile)+1
          MaxHaloLenI=MAX(MaxHaloLenI,(Imax-Imin+1))
          MaxHaloLenJ=MAX(MaxHaloLenJ,(Jmax-Jmin+1))
        END DO
        HaloSizeI(ng)=Nghost*MaxHaloLenI+6*Nghost
        HaloSizeJ(ng)=Nghost*MaxHaloLenJ+6*Nghost
        TileSide(ng)=MAX(MaxHaloLenI,MaxHaloLenJ)
        TileSize(ng)=MaxHaloLenI*MaxHaloLenJ
        IF (Master) THEN
          WRITE (stdout,110) ng, HaloSizeI(ng), ng, HaloSizeJ(ng),      &
     &                       ng, TileSide(ng),  ng, TileSize(ng)
 110      FORMAT (/,' Maximum halo size in XI and ETA directions:',/,   &
     &            /,'               HaloSizeI(',i1,') = ',i7,           &
     &            /,'               HaloSizeJ(',i1,') = ',i7,           &
     &            /,'                TileSide(',i1,') = ',i7,           &
     &            /,'                TileSize(',i1,') = ',i7,/)
        END IF
      END DO
#endif

#ifdef BIOLOGY
!
!-----------------------------------------------------------------------
!  Read in biological model input parameters.
!-----------------------------------------------------------------------
!
      OPEN (15, FILE=TRIM(bparnam), FORM='formatted', STATUS='old')

      CALL read_BioPar (model, 15, out, Lwrite)
#endif
#ifdef ICE_MODEL
!
!-----------------------------------------------------------------------
!  Read in ice model input parameters.
!-----------------------------------------------------------------------
!
      OPEN (inp, FILE=TRIM(iparnam), FORM='formatted', STATUS='old')

      CALL read_IcePar (inp, out, Lwrite)
#endif
#ifdef SEDIMENT
!
!-----------------------------------------------------------------------
!  Read in sediment model input parameters.
!-----------------------------------------------------------------------
!
      OPEN (25, FILE=TRIM(sparnam), FORM='formatted', STATUS='old')

      CALL read_SedPar (model, 25, out, Lwrite)
#endif
#if defined FOUR_DVAR || defined VERIFICATION
!
!-----------------------------------------------------------------------
!  Read in input assimilation parameters.
!-----------------------------------------------------------------------
!
      OPEN (35, FILE=TRIM(aparnam), FORM='formatted', STATUS='old')

      CALL read_AssPar (model, 35, out, Lwrite)
#endif
#ifdef FLOATS
!
!-----------------------------------------------------------------------
!  Read in floats input parameters.
!-----------------------------------------------------------------------
!
      OPEN (45, FILE=TRIM(fposnam), FORM='formatted', STATUS='old')

      CALL read_FloatsPar (model, 45, out, Lwrite)
#endif
#ifdef STATIONS
!
!-----------------------------------------------------------------------
!  Read in stations input parameters.
!-----------------------------------------------------------------------
!
      OPEN (55, FILE=TRIM(sposnam), FORM='formatted', STATUS='old')

      CALL read_StaPar (model, 55, out, Lwrite)
#endif
!
!-----------------------------------------------------------------------
!  Check C-preprocessing options and definitions.
!-----------------------------------------------------------------------
!
      IF (Master) THEN
        CALL checkdefs
        CALL my_flush (out)
      END IF
#ifdef DISTRIBUTE
      CALL mp_bcasti (1, model, exit_flag)
      CALL mp_bcasts (1, model, Coptions)
#endif
      IF (exit_flag.ne.NoError) RETURN
!
!-----------------------------------------------------------------------
!  Compute various constants.
!-----------------------------------------------------------------------
!
      gorho0=g/rho0
      DO ng=1,Ngrids
        dtfast(ng)=dt(ng)/REAL(ndtfast(ng),r8)
#ifdef FILTERED
!
!  Check various parameters for writing time-filtered output
!
        IF (ntsavg(ng).ne.1) THEN
          ntsavg(ng) = 1
          IF (Master) print *, 'Resetting ntsavg to 1'
        END IF
        IF (MOD(dt(ng),1.0_r8).ne.0) THEN
          IF (Master) print *, 'Model timestep must be a whole number'
          exit_flag=2
        END IF
        IF (MOD(dtfil,INT(dt(ng))).ne.0) THEN
          IF (Master) print *,                                          &
     &                'Model timesteps must fall on filter interval'
          exit_flag=2
        END IF
        nfil = nw*dtfil/INT(dt(ng))
        IF (MOD(nfil,navg(ng)).ne.0) THEN
          IF (Master) print *,                                          &
     &                'Must write out in sync with filter length'
          exit_flag=2
        END IF
        IF (nfil/navg(ng).ne.FILN) THEN
          IF (Master) print *, 'Number of filter sums is wrong'
          exit_flag=2
        END IF
        DO itrc=1,FILN
          fcount(itrc) = (1-itrc)*nw/FILN
        END DO
# ifdef FILTERED_RST
!
!  Hardcode the names of the filter restart files.
!
        WRITE(ngnumber,'(i2.2)') ng
        FIL(1,ng)%name=TRIM(ADJUSTL('ocean_fil2d_'//ngnumber//'.nc'))
        FIL(2,ng)%name=TRIM(ADJUSTL('ocean_filu_'//ngnumber//'.nc'))
        FIL(3,ng)%name=TRIM(ADJUSTL('ocean_filv_'//ngnumber//'.nc'))
        FIL(4,ng)%name=TRIM(ADJUSTL('ocean_filakt_'//ngnumber//'.nc'))
        FIL(5,ng)%name=TRIM(ADJUSTL('ocean_filaks_'//ngnumber//'.nc'))
        FIL(6,ng)%name=TRIM(ADJUSTL('ocean_filakv_'//ngnumber//'.nc'))
        FIL(7,ng)%name=TRIM(ADJUSTL('ocean_filr_'//ngnumber//'.nc'))
        FIL(8,ng)%name=TRIM(ADJUSTL('ocean_filt_'//ngnumber//'.nc'))
        FIL(9,ng)%name=TRIM(ADJUSTL('ocean_filw_'//ngnumber//'.nc'))
        FIL(10,ng)%name=TRIM(ADJUSTL('ocean_filice_'//ngnumber//'.nc'))
!              allocate ( TIDE(ng)%Nrec(Nfiles) )
!              allocate ( TIDE(ng)%time_min(Nfiles) )
!              allocate ( TIDE(ng)%time_max(Nfiles) )
        DO ifile=1,nfile
          allocate ( FIL(ifile,ng)%Vid(NV) )
          allocate ( FIL(ifile,ng)%Tid(MT) )
        END DO
!              allocate ( TIDE(ng)%files(Nfiles) )
!              TIDE(ng)%Nfiles=Nfiles
!              TIDE(ng)%Fcount=1
!              TIDE(ng)%Rindex=0
!              TIDE(ng)%ncid=-1
!              TIDE(ng)%Vid=-1
!              TIDE(ng)%Tid=-1
!              TIDE(ng)%Nrec(1:Nfiles)=0
!              TIDE(ng)%time_min(1:Nfiles)=0.0_r8
!              TIDE(ng)%time_max(1:Nfiles)=0.0_r8
!              TIDE(ng)%name=TRIM(FRC(ifile,mg)%name)
!              TIDE(ng)%label='TIDE - tidal forcing'
# endif
#endif
!
!  Take the square root of the biharmonic coefficients so it can
!  be applied to each harmonic operator.
!
        nl_visc4(ng)=SQRT(ABS(nl_visc4(ng)))
#ifdef ADJOINT
        ad_visc4(ng)=SQRT(ABS(ad_visc4(ng)))
#endif
#if defined TANGENT || defined TL_IOMS
        tl_visc4(ng)=SQRT(ABS(tl_visc4(ng)))
#endif
        tkenu4(ng)=SQRT(ABS(tkenu4(ng)))
!
!  Compute inverse nudging coefficients (1/s) used in various tasks.
!
        IF (Znudg(ng).gt.0.0_r8) THEN
          Znudg(ng)=1.0_r8/(Znudg(ng)*86400.0_r8)
        ELSE
          Znudg(ng)=0.0_r8
        END IF
        IF (M2nudg(ng).gt.0.0_r8) THEN
          M2nudg(ng)=1.0_r8/(M2nudg(ng)*86400.0_r8)
        ELSE
          M2nudg(ng)=0.0_r8
        END IF
#ifdef SOLVE3D
        IF (M3nudg(ng).gt.0.0_r8) THEN
          M3nudg(ng)=1.0_r8/(M3nudg(ng)*86400.0_r8)
        ELSE
          M3nudg(ng)=0.0_r8
        END IF
#endif
#ifdef SO_SEMI
       SO_decay(ng)=SO_decay(ng)*86400.0_r8
#endif
!
!  Convert momentum stresses and tracer flux scales to kinematic
!  Values. Recall, that all the model fluxes are kinematic.
!
#ifdef NCEP_FLUXES
        cff=1.0_r8
#else
        cff=1.0_r8/rho0
        Fscale(idUsms,ng)=cff*Fscale(idUsms,ng)
        Fscale(idVsms,ng)=cff*Fscale(idVsms,ng)
        Fscale(idUbms,ng)=cff*Fscale(idUbms,ng)
        Fscale(idVbms,ng)=cff*Fscale(idVbms,ng)
        Fscale(idUbrs,ng)=cff*Fscale(idUbrs,ng)
        Fscale(idVbrs,ng)=cff*Fscale(idVbrs,ng)
        Fscale(idUbws,ng)=cff*Fscale(idUbws,ng)
        Fscale(idVbws,ng)=cff*Fscale(idVbws,ng)
        Fscale(idUbcs,ng)=cff*Fscale(idUbcs,ng)
        Fscale(idVbcs,ng)=cff*Fscale(idVbcs,ng)
#endif
#ifdef NCEP_FLUXES
        cff=1.0_r8
#else
        cff=1.0_r8/(rho0*Cp)
        Fscale(idTsur(itemp),ng)=cff*Fscale(idTsur(itemp),ng)
        Fscale(idTbot(itemp),ng)=cff*Fscale(idTbot(itemp),ng)
        Fscale(idSrad,ng)=cff*Fscale(idSrad,ng)
        Fscale(idLdwn,ng)=cff*Fscale(idLdwn,ng)
        Fscale(idLrad,ng)=cff*Fscale(idLrad,ng)
        Fscale(idLhea,ng)=cff*Fscale(idLhea,ng)
        Fscale(idShea,ng)=cff*Fscale(idShea,ng)
        Fscale(iddQdT,ng)=cff*Fscale(iddQdT,ng)
#endif
      END DO
!
!-----------------------------------------------------------------------
!  Initialize random number sequence so we can get identical results
!  everytime that we run the same solution.
!-----------------------------------------------------------------------
!
      sequence=759
      CALL ran_seed (sequence)

      RETURN
      END SUBROUTINE inp_par

#ifdef BIOLOGY
# if defined BIO_FENNEL
#  include <fennel_inp.h>
# elif defined BEST_NPZ
#  include <bestnpz_inp.h>
# elif defined BIO_GOANPZ
#  include <goanpz_inp.h>
# elif defined BIO_UMAINE
#  include <umaine_inp.h>
# elif defined ECOSIM
#  include <ecosim_inp.h>
# elif defined NEMURO
#  include <nemuro_inp.h>
# elif defined NPZD_FRANKS
#  include <npzd_Franks_inp.h>
# elif defined NPZD_IRON
#  include <npzd_iron_inp.h>
# elif defined NPZD_POWELL
#  include <npzd_Powell_inp.h>
# endif
#endif

#ifdef SEDIMENT
# include <sediment_inp.h>
#endif

#ifdef MODEL_COUPLING
      SUBROUTINE read_CouplePar (model)
!
!=======================================================================
!                                                                      !
!  This routine reads in physical model input parameters.              !
!                                                                      !
!=======================================================================
!
#ifdef FILTERED
      USE mod_filter, ONLY: nfil,fcount,nw,dtfil,FILN
#endif
      USE mod_param
      USE mod_parallel
      USE mod_coupler
      USE mod_iounits
      USE mod_scalars

# ifdef DISTRIBUTE
!
      USE distribute_mod, ONLY : mp_bcasts
# endif
!
      implicit none
!
!  Imported variable declarations.
!
      integer, intent(in) :: model
!
!  Local variable declarations.
!
      logical :: Lwrite

      integer :: Npts, Nval, i, ic, j, inp, ng, out, status

      integer :: decode_line, load_i, load_l, load_r

      real(r8), dimension(100) :: Rval

      real(r8), allocatable :: MyRval(:)

      character (len=40) :: KeyWord
      character (len=256) :: line
      character (len=256) :: Cname
      character (len=256), dimension(100) :: Cval
!
!-----------------------------------------------------------------------
!  Determine coupling standard input file name.  In distributed-memory,
!  this name is assigned at the executtion command line and processed
!  with the Unix routine GETARG.  The ROMS/TOMS input parameter script
!  name is specified in this coupling script.
!-----------------------------------------------------------------------
!
# ifdef DISTRIBUTE
      Lwrite=Master
      inp=1
      out=stdout
!
      IF (MyRank.eq.0) CALL my_getarg (1,Cname)
      CALL mp_bcasts (1, model, Cname)
      IF (MyRank.eq.0) THEN
        WRITE(stdout,*) 'Coupled Input File name = ', TRIM(Cname)
      END IF
      OPEN (inp, FILE=TRIM(Cname), FORM='formatted', STATUS='old',      &
     &      ERR=10)
      GO TO 30
 10   WRITE (stdout,20)
      IF (Master) WRITE(stdout,*) 'MyRank = ', MyRank, TRIM(Cname)
      exit_flag=4
      RETURN
 20   FORMAT (/,' INP_PAR - Unable to open coupling input script.',     &
     &        /,11x,'In distributed-memory applications, the input',    &
     &        /,11x,'script file is processed in parallel. The Unix',   &
     &        /,11x,'routine GETARG is used to get script file name.',  &
     &        /,11x,'For example, in MPI applications make sure that',  &
     &        /,11x,'command line is something like:',/,                &
     &        /,11x,'mpirun -np 4 masterM coupling.in',/,               &
     &        /,11x,'and not',/,                                        &
     &        /,11x,'mpirun -np 4 masterM < coupling.in',/)
 30   CONTINUE
# else
      Lwrite=Master
      inp=stdinp
      out=stdout
# endif
!
!-----------------------------------------------------------------------
!  Read in multiple models coupling parameters. Then, load input
!  data into module. Take into account nested grid configurations.
!-----------------------------------------------------------------------
!
      DO WHILE (.TRUE.)
        READ (inp,'(a)',ERR=40,END=50) line
        status=decode_line(line, KeyWord, Nval, Cval, Rval)
        IF (status.gt.0) THEN
          IF (TRIM(KeyWord).eq.'Nmodels') THEN
            Npts=load_i(Nval, Rval, 1, Nmodels)
            IF (.not.allocated(MyRval) ) THEN
              allocate ( MyRval(Nmodels) )
            END IF
            IF (.not.allocated(OrderLabel) ) THEN
              allocate ( OrderLabel(Nmodels) )
            END IF
            IF (.not.allocated(Nthreads) ) THEN
              allocate ( Nthreads(Nmodels) )
              Nthreads=0
            END IF
            IF (.not.allocated(TimeInterval) ) THEN
              allocate ( TimeInterval(Nmodels,Nmodels) )
              TimeInterval=0.0_r8
            END IF
            IF (.not.allocated(INPname) ) THEN
              allocate ( INPname(Nmodels) )
            END IF
            IF (.not.allocated(Nexport) ) THEN
              allocate ( Nexport(Nmodels) )
              Nexport=0
            END IF
            IF (.not.allocated(Nimport) ) THEN
              allocate ( Nimport(Nmodels) )
              Nimport=0
            END IF
         ELSE IF (TRIM(KeyWord).eq.'Lreport') THEN
            Npts=load_l(Nval, Cval, 1, Lreport)
         ELSE IF (TRIM(KeyWord).eq.'OrderLabel') THEN
            DO i=1,Nmodels
              IF (i.eq.Nval) THEN
                OrderLabel(i)=TRIM(ADJUSTL(Cval(Nval)))
                IF (INDEX(TRIM(OrderLabel(i)),'ocean').ne.0) THEN
                  Iocean=i
                ELSE IF (INDEX(TRIM(OrderLabel(i)),'waves').ne.0) THEN
                  Iwaves=i
                ELSE IF (INDEX(TRIM(OrderLabel(i)),'atmos').ne.0) THEN
                  Iatmos=i
                END IF
              END IF
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Nthreads(ocean)') THEN
            IF ((0.lt.Iocean).and.(Iocean.le.Nmodels)) THEN
              Npts=load_i(Nval, Rval, 1, Nthreads(Iocean))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Nthreads(waves)') THEN
            IF ((0.lt.Iwaves).and.(Iwaves.le.Nmodels)) THEN
              Npts=load_i(Nval, Rval, 1, Nthreads(Iwaves))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Nthreads(atmos)') THEN
            IF ((0.lt.Iatmos).and.(Iatmos.le.Nmodels)) THEN
              Npts=load_i(Nval, Rval, 1, Nthreads(Iatmos))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'TimeInterval') THEN
            Npts=load_r(Nval, Rval, Nmodels, MyRval)
            ic=0
            DO j=1,Nmodels
              DO i=1,Nmodels
                IF (i.gt.j) THEN
                  ic=ic+1
                  TimeInterval(i,j)=MyRval(ic)
                  TimeInterval(j,i)=MyRval(ic)
                END IF
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'INPname(ocean)') THEN
            IF ((0.lt.Iocean).and.(Iocean.le.Nmodels)) THEN
              INPname(Iocean)=TRIM(ADJUSTL(Cval(Nval)))
              Iname=TRIM(INPname(Iocean))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'INPname(waves)') THEN
            IF ((0.lt.Iwaves).and.(Iwaves.le.Nmodels)) THEN
              INPname(Iwaves)=TRIM(ADJUSTL(Cval(Nval)))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'INPname(atmos)') THEN
            IF ((0.lt.Iatmos).and.(Iatmos.le.Nmodels)) THEN
              INPname(Iatmos)=TRIM(ADJUSTL(Cval(Nval)))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'CPLname') THEN
            CPLname=TRIM(ADJUSTL(Cval(Nval)))
          ELSE IF (TRIM(KeyWord).eq.'Nexport(ocean)') THEN
            IF ((0.lt.Iocean).and.(Iocean.le.Nmodels)) THEN
              Npts=load_i(Nval, Rval, 1, Nexport(Iocean))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Nexport(waves)') THEN
            IF ((0.lt.Iwaves).and.(Iwaves.le.Nmodels)) THEN
              Npts=load_i(Nval, Rval, 1, Nexport(Iwaves))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Nexport(atmos)') THEN
            IF ((0.lt.Iatmos).and.(Iatmos.le.Nmodels)) THEN
              Npts=load_i(Nval, Rval, 1, Nexport(Iatmos))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Export(ocean)') THEN
            IF (.not.allocated(Export)) THEN
              allocate ( Export(Nmodels) )
              DO i=1,Nmodels
                allocate ( Export(i)%code(MAX(1,Nexport(i))) )
                Export(i)%code=' '
              END DO
            END IF
            IF ((0.lt.Iocean).and.(Iocean.le.Nmodels)) THEN
              IF (Nval.le.Nexport(Iocean)) THEN
                Export(Iocean)%code(Nval)=TRIM(ADJUSTL(Cval(Nval)))
              END IF
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Export(waves)') THEN
            IF (.not.allocated(Export)) THEN
              allocate ( Export(Nmodels) )
              DO i=1,Nmodels
                allocate ( Export(i)%code(MAX(1,Nexport(i))) )
                Export(i)%code=' '
              END DO
            END IF
            IF ((0.lt.Iwaves).and.(Iwaves.le.Nmodels)) THEN
              IF (Nval.le.Nexport(Iwaves)) THEN
                Export(Iwaves)%code(Nval)=TRIM(ADJUSTL(Cval(Nval)))
              END IF
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Export(atmos)') THEN
            IF (.not.allocated(Export)) THEN
              allocate ( Export(Nmodels) )
              DO i=1,Nmodels
                allocate ( Export(i)%code(MAX(1,Nexport(i))) )
                Export(i)%code=' '
              END DO
            END IF
            IF ((0.lt.Iatmos).and.(Iatmos.le.Nmodels)) THEN
              IF (Nval.le.Nexport(Iatmos)) THEN
                Export(Iatmos)%code(Nval)=TRIM(ADJUSTL(Cval(Nval)))
              END IF
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Nimport(ocean)') THEN
            IF ((0.lt.Iocean).and.(Iocean.le.Nmodels)) THEN
              Npts=load_i(Nval, Rval, 1, Nimport(Iocean))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Nimport(waves)') THEN
            IF ((0.lt.Iwaves).and.(Iwaves.le.Nmodels)) THEN
              Npts=load_i(Nval, Rval, 1, Nimport(Iwaves))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Nimport(atmos)') THEN
            IF ((0.lt.Iatmos).and.(Iatmos.le.Nmodels)) THEN
              Npts=load_i(Nval, Rval, 1, Nimport(Iatmos))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Import(ocean)') THEN
            IF (.not.allocated(Import)) THEN
              allocate ( Import(Nmodels) )
              DO i=1,Nmodels
                allocate ( Import(i)%code(MAX(1,Nimport(i))) )
                Import(i)%code=' '
              END DO
            END IF
            IF ((0.lt.Iocean).and.(Iocean.le.Nmodels)) THEN
              IF (Nval.le.Nimport(Iocean)) THEN
                Import(Iocean)%code(Nval)=TRIM(ADJUSTL(Cval(Nval)))
              END IF
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Import(waves)') THEN
            IF (.not.allocated(Import)) THEN
              allocate ( Import(Nmodels) )
              DO i=1,Nmodels
                allocate ( Import(i)%code(MAX(1,Nimport(i))) )
                Import(i)%code=' '
              END DO
            END IF
            IF ((0.lt.Iwaves).and.(Iwaves.le.Nmodels)) THEN
              IF (Nval.le.Nimport(Iwaves)) THEN
                Import(Iwaves)%code(Nval)=TRIM(ADJUSTL(Cval(Nval)))
              END IF
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Import(atmos)') THEN
            IF (.not.allocated(Import)) THEN
              allocate ( Import(Nmodels) )
              DO i=1,Nmodels
                allocate ( Import(i)%code(MAX(1,Nimport(i))) )
                Import(i)%code=' '
              END DO
            END IF
            IF ((0.lt.Iatmos).and.(Iatmos.le.Nmodels)) THEN
              IF (Nval.le.Nimport(Iatmos)) THEN
                Import(Iatmos)%code(Nval)=TRIM(ADJUSTL(Cval(Nval)))
              END IF
            END IF
          END IF
        END IF
      END DO
  40  IF (Master) WRITE (out,60) line
      exit_flag=4
      RETURN
  50  CLOSE (inp)

  60  FORMAT (/,' READ_CouplePar - Error while processing line: ',/,a)

      RETURN
      END SUBROUTINE read_CouplePar
#endif

      SUBROUTINE read_PhyPar (model, inp, out, Lwrite)
!
!=======================================================================
!                                                                      !
!  This routine reads in physical model input parameters.              !
!                                                                      !
!=======================================================================
!
      USE mod_param
      USE mod_parallel
#ifdef BIOLOGY
      USE mod_biology
#endif
#ifdef MODEL_COUPLING
      USE mod_coupler
#endif
#if defined FOUR_DVAR || defined VERIFICATION
      USE mod_fourdvar
#endif
      USE mod_iounits
      USE mod_ncparam
      USE mod_netcdf
      USE mod_scalars
#if defined SEDIMENT || defined BBL_MODEL
      USE mod_sediment
#endif
      USE mod_stepping
#ifdef PROPAGATOR
      USE mod_storage
#endif
      USE mod_strings
!
      implicit none
!
!  Imported variable declarations
!
      logical, intent(in) :: Lwrite
      integer, intent(in) :: model, inp, out
!
!  Local variable declarations.
!
      logical :: find_file, got_Ngrids
#if defined SOLVE3D && defined SEDIMENT
      logical :: LreadNCS = .FALSE.
      logical :: LreadNNS = .FALSE.
#endif
      integer :: Lstr, Npts, Nval, i, itrc, k, ng, status
      integer :: ifile, igrid, mFfiles

      integer :: decode_line, load_i, load_l, load_r
      integer :: load_s1d, load_s2d

#if defined SOLVE3D && defined T_PASSIVE
      logical, allocatable :: Linert(:,:)
#endif
#if defined SOLVE3D && (defined BBL_MODEL || defined SEDIMENT)
      logical, allocatable :: Lbottom(:,:)
#endif
      logical, allocatable :: Ltracer(:,:)
#if defined AD_SENSITIVITY    || defined IS4DVAR_SENSITIVITY || \
    defined FORCING_SV        || defined OPT_OBSERVATIONS    || \
    defined SENSITIVITY_4DVAR || defined SO_SEMI
      logical, allocatable :: Ladsen(:)
#endif
#if defined DIAGNOSTICS_UV
      logical, allocatable :: Ldiag(:)
#endif
      integer, allocatable :: Nfiles(:)
      integer, allocatable :: Ncount(:,:)

      real(r8), allocatable :: Rtracer(:,:)
      real(r8), allocatable :: tracer(:,:)

      real(r8), dimension(100) :: Rval

      character (len=1  ), parameter :: blank = ' '
      character (len=19 ) :: ref_att
      character (len=40 ) :: KeyWord
      character (len=50 ) :: label
      character (len=256) :: fname, line
      character (len=256), dimension(100) :: Cval
!
!-----------------------------------------------------------------------
!  Initialize.
!-----------------------------------------------------------------------
!
      ifile=1
      igrid=1
      DO i=1,LEN(label)
        label(i:i)=blank
      END DO
      got_Ngrids=.FALSE.
!
!-----------------------------------------------------------------------
!  Read in physical model parameters. Then, load input data into module.
!  Take into account nested grid configurations.
!-----------------------------------------------------------------------
!
      DO WHILE (.TRUE.)
        READ (inp,'(a)',ERR=10,END=20) line
        status=decode_line(line, KeyWord, Nval, Cval, Rval)
        IF (status.gt.0) THEN
          IF (TRIM(KeyWord).eq.'TITLE') THEN
            IF (Nval.eq.1) THEN
              title=TRIM(ADJUSTL(Cval(Nval)))
            ELSE
              WRITE(title,'(a,1x,a)') TRIM(ADJUSTL(title)),             &
     &                                TRIM(ADJUSTL(Cval(Nval)))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'MyAppCPP') THEN
            DO i=1,LEN(MyAppCPP)
              MyAppCPP(i:i)=blank
            END DO
            MyAppCPP=TRIM(ADJUSTL(Cval(Nval)))
          ELSE IF (TRIM(KeyWord).eq.'VARNAME') THEN
            DO i=1,LEN(varname)
              varname(i:i)=blank
            END DO
            varname=TRIM(ADJUSTL(Cval(Nval)))
          ELSE IF (TRIM(KeyWord).eq.'Ngrids') THEN
            Npts=load_i(Nval, Rval, 1, Ngrids)
            IF (Ngrids.le.0) THEN
              IF (Master) WRITE (out,290) 'Ngrids', Ngrids,             &
     &                                    'must be greater than zero.'
              exit_flag=5
              RETURN
            END IF
            got_Ngrids=.TRUE.
            CALL allocate_param       ! Start allocating variables in
            CALL allocate_parallel    ! modules that solely depend on
            CALL allocate_iounits     ! the number of nested grids
            CALL allocate_stepping
#if defined FOUR_DVAR || defined VERIFICATION
            CALL allocate_fourdvar
#endif
#if defined SOLVE3D && (defined BBL_MODEL || defined SEDIMENT)
            IF (.not.allocated(Lbottom)) THEN
              allocate ( Lbottom(MBOTP,Ngrids) )
            END IF
#endif
#if defined DIAGNOSTICS_UV
            IF (.not.allocated(Ldiag)) THEN
              allocate ( Ldiag(Ngrids) )
            END IF
#endif
            IF (.not.allocated(Nfiles)) THEN
              allocate ( Nfiles(Ngrids) )
              Nfiles(1:Ngrids)=0
            END IF
          ELSE IF (TRIM(KeyWord).eq.'Lm') THEN
            IF (.not.got_Ngrids) THEN
              IF (Master) WRITE (out,330) 'Ngrids',                     &
     &      'Add "Ngrids" keyword before grid dimension (Lm, Mm) entry.'
              exit_flag=5
              RETURN
            END IF
            Npts=load_i(Nval, Rval, Ngrids, Lm)
            DO ng=1,Ngrids
              IF (Lm(ng).le.0) THEN
                IF (Master) WRITE (out,300) 'Lm', ng,                   &
     &                                      'must be greater than zero.'
                exit_flag=5
                RETURN
              END IF
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Mm') THEN
            Npts=load_i(Nval, Rval, Ngrids, Mm)
            DO ng=1,Ngrids
              IF (Mm(ng).le.0) THEN
                IF (Master) WRITE (out,300) 'Mm', ng,                   &
     &                                      'must be greater than zero.'
                exit_flag=5
                RETURN
              END IF
            END DO
          ELSE IF (TRIM(KeyWord).eq.'N') THEN
            Npts=load_i(Nval, Rval, Ngrids, N)
            DO ng=1,Ngrids
              IF (N(ng).lt.0) THEN
                IF (Master) WRITE (out,300) 'N', ng,                    &
     &                                      'must be greater than zero.'
                exit_flag=5
                RETURN
              END IF
            END DO
#if defined SEDIMENT && defined SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Nbed') THEN
            Npts=load_i(Nval, Rval, 1, Nbed)
            IF (Nbed.le.0) THEN
              IF (Master) WRITE (out,290) 'Nbed = ', Nbed,              &
     &                                    'must be greater than zero.'
              exit_flag=5
              RETURN
            END IF
#endif
#ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'NAT') THEN
            Npts=load_i(Nval, Rval, 1, NAT)
            IF ((NAT.lt.0).or.(NAT.gt.2)) THEN
              IF (Master) WRITE (out,290) 'NAT = ', NAT,                &
     &                          'make sure that NAT is either 1 or 2.'
              exit_flag=5
              RETURN
            END IF
# ifdef SALINITY
            IF (NAT.ne.2) THEN
              IF (Master) WRITE (out,290) 'NAT = ', NAT,                &
     &                          'make sure that NAT is equal to 2.'
              exit_flag=5
              RETURN
            END IF
# endif
#endif
#if defined T_PASSIVE && defined SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'NPT') THEN
            Npts=load_i(Nval, Rval, 1, NPT)
            IF (NPT.le.0) THEN
              IF (Master) WRITE (out,290) 'NPT = ', NPT,                &
     &                                    'must be greater than zero.'
              exit_flag=5
              RETURN
            END IF
#endif
#if defined SEDIMENT && defined SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'NCS') THEN
            Npts=load_i(Nval, Rval, 1, NCS)
            IF (NCS.lt.0) THEN
              IF (Master) WRITE (out,290) 'NCS = ', NCS,                &
     &                                    'must be greater than zero.'
              exit_flag=5
              RETURN
            END IF
            LreadNCS=.TRUE.
            IF (LreadNNS.and.((NCS+NNS).le.0)) THEN
              IF (Master) WRITE (out,290) 'NST = ', NCS+NNS,            &
     &                    'either NCS or NNS must be greater than zero.'
              exit_flag=5
              RETURN
            END IF
            NST=NST+NCS
          ELSE IF (TRIM(KeyWord).eq.'NNS') THEN
            Npts=load_i(Nval, Rval, 1, NNS)
            IF (NNS.lt.0) THEN
              IF (Master) WRITE (out,290) 'NNS = ',                     &
     &                                    'must be greater than zero.'
              exit_flag=5
              RETURN
            END IF
            LreadNNS=.TRUE.
            IF (LreadNCS.and.((NCS+NNS).le.0)) THEN
              IF (Master) WRITE (out,290) 'NST = ', NCS+NNS,            &
     &                    'either NCS or NNS must be greater than zero.'
              exit_flag=5
              RETURN
            END IF
            NST=NST+NNS
#endif
          ELSE IF (TRIM(KeyWord).eq.'NtileI') THEN
            Npts=load_i(Nval, Rval, Ngrids, NtileI)
#ifdef DISTRIBUTE
            NtileX(1:Ngrids)=1
#else
            NtileX(1:Ngrids)=NtileI(1:Ngrids)
#endif
          ELSE IF (TRIM(KeyWord).eq.'NtileJ') THEN
            Npts=load_i(Nval, Rval, Ngrids, NtileJ)
#ifdef DISTRIBUTE
            NtileE(1:Ngrids)=1
#else
            NtileE(1:Ngrids)=NtileJ(1:Ngrids)
#endif
#ifdef BIOLOGY
            CALL initialize_biology
#endif
#if defined SEDIMENT || defined BBL_MODEL
            CALL initialize_sediment
#endif
            CALL initialize_param    ! Continue allocating/initalizing
            CALL allocate_scalars    ! variables since the application
            CALL initialize_scalars  ! number of nested grids and
            CALL allocate_ncparam    ! domain parameters are known
            CALL initialize_ncparam
#if defined AD_SENSITIVITY    || defined IS4DVAR_SENSITIVITY || \
    defined FORCING_SV        || defined OPT_OBSERVATIONS    || \
    defined SENSITIVITY_4DVAR || defined SO_SEMI
            IF (.not.allocated(Ladsen)) THEN
              allocate (Ladsen(MT*Ngrids))
            END IF
#endif
            IF (.not.allocated(Ltracer)) THEN
              allocate (Ltracer(NAT+NPT,Ngrids))
            END IF
#if defined SOLVE3D && defined T_PASSIVE
            IF (.not.allocated(Linert)) THEN
              allocate (Linert(NPT,Ngrids))
            END IF
            IF (MAXVAL(inert).eq.0) THEN
              IF (Master) WRITE (out,280) 'inert'
              exit_flag=5
              RETURN
            END IF
#endif
            IF (.not.allocated(Rtracer)) THEN
              allocate (Rtracer(NAT+NPT,Ngrids))
            END IF
            IF (.not.allocated(tracer)) THEN
              allocate (tracer(MT,Ngrids))
            END IF
          ELSE IF (TRIM(KeyWord).eq.'NTIMES') THEN
            Npts=load_i(Nval, Rval, Ngrids, ntimes)
          ELSE IF (TRIM(KeyWord).eq.'DT') THEN
            Npts=load_r(Nval, Rval, Ngrids, dt)
#ifdef AGE_DISTRIBUTION
          ELSE IF (TRIM(KeyWord).eq.'DTAU') THEN
            Npts=load_r(Nval, Rval, Ngrids, dtau)
#endif
#ifdef MODEL_COUPLING
            IF (.not.allocated(CoupleSteps)) THEN
              allocate (CoupleSteps(Nmodels,Ngrids))
              CoupleSteps=0
            END IF
            DO ng=1,Ngrids
              DO i=1,Nmodels
                CoupleSteps(i,ng)=MAX(1,                                &
     &                                INT(TimeInterval(Iocean,i)/       &
     &                                dt(ng)))
              END DO
            END DO
#endif
          ELSE IF (TRIM(KeyWord).eq.'NDTFAST') THEN
            Npts=load_i(Nval, Rval, Ngrids, ndtfast)
          ELSE IF (TRIM(KeyWord).eq.'ERstr') THEN
            Npts=load_i(Nval, Rval, 1, ERstr)
          ELSE IF (TRIM(KeyWord).eq.'ERend') THEN
            Npts=load_i(Nval, Rval, 1, ERend)
          ELSE IF (TRIM(KeyWord).eq.'Nouter') THEN
            Npts=load_i(Nval, Rval, 1, Nouter)
          ELSE IF (TRIM(KeyWord).eq.'Ninner') THEN
            Npts=load_i(Nval, Rval, 1, Ninner)
          ELSE IF (TRIM(KeyWord).eq.'Nintervals') THEN
            Npts=load_i(Nval, Rval, 1, Nintervals)
#ifdef PROPAGATOR
          ELSE IF (TRIM(KeyWord).eq.'NEV') THEN
            Npts=load_i(Nval, Rval, 1, NEV)
          ELSE IF (TRIM(KeyWord).eq.'NCV') THEN
            Npts=load_i(Nval, Rval, 1, NCV)
# if defined FT_EIGENMMODES || defined AFT_EIGENMODES
            IF (NCV.lt.(2*NEV+1)) THEN
              IF (Master) WRITE (out,260) 'NCV = ', NCV,                &
     &                       'Must be greater than or equal to 2*NEV+1'
              exit_flag=5
              RETURN
            END IF
# elif defined OPT_PERTURBATION
            IF (NCV.lt.(2*NEV)) THEN
              IF (Master) WRITE (out,260) 'NCV = ', NCV,                &
     &                       'Must be greater than or equal to 2*NEV'
              exit_flag=5
              RETURN
            END IF
# else
            IF (NCV.lt.(2*NEV)) THEN
              IF (Master) WRITE (out,260) 'NCV = ', NCV,                &
     &                                    'Must be greater than NEV'
              exit_flag=5
              RETURN
            END IF
# endif
#endif
          ELSE IF (TRIM(KeyWord).eq.'NRREC') THEN
            Npts=load_i(Nval, Rval, Ngrids, nrrec)
            DO ng=1,Ngrids
              IF (nrrec(ng).lt.0) THEN
                LastRec(ng)=.TRUE.
              ELSE
                LastRec(ng)=.FALSE.
              END IF
            END DO
          ELSE IF (TRIM(KeyWord).eq.'LcycleRST') THEN
            Npts=load_l(Nval, Cval, Ngrids, LcycleRST)
          ELSE IF (TRIM(KeyWord).eq.'NRST') THEN
            Npts=load_i(Nval, Rval, Ngrids, nRST)
          ELSE IF (TRIM(KeyWord).eq.'NSTA') THEN
            Npts=load_i(Nval, Rval, Ngrids, nSTA)
          ELSE IF (TRIM(KeyWord).eq.'NFLT') THEN
            Npts=load_i(Nval, Rval, Ngrids, nFLT)
          ELSE IF (TRIM(KeyWord).eq.'NINFO') THEN
            Npts=load_i(Nval, Rval, Ngrids, ninfo)
          ELSE IF (TRIM(KeyWord).eq.'LDEFOUT') THEN
            Npts=load_l(Nval, Cval, Ngrids, ldefout)
          ELSE IF (TRIM(KeyWord).eq.'NHIS') THEN
            Npts=load_i(Nval, Rval, Ngrids, nHIS)
          ELSE IF (TRIM(KeyWord).eq.'NDEFHIS') THEN
            Npts=load_i(Nval, Rval, Ngrids, ndefHIS)
          ELSE IF (TRIM(KeyWord).eq.'NTSAVG') THEN
            Npts=load_i(Nval, Rval, Ngrids, ntsAVG)
#ifdef ADJOINT
            DO ng=1,Ngrids
              IF (ntsAVG(ng).eq.1) ntsAVG(ng)=ntimes(ng)
            END DO
#endif
          ELSE IF (TRIM(KeyWord).eq.'NAVG') THEN
            Npts=load_i(Nval, Rval, Ngrids, nAVG)
          ELSE IF (TRIM(KeyWord).eq.'NDEFAVG') THEN
            Npts=load_i(Nval, Rval, Ngrids, ndefAVG)
          ELSE IF (TRIM(KeyWord).eq.'NTSAVG2') THEN
            Npts=load_i(Nval, Rval, Ngrids, ntsAVG2)
          ELSE IF (TRIM(KeyWord).eq.'NAVG2') THEN
            Npts=load_i(Nval, Rval, Ngrids, nAVG2)
          ELSE IF (TRIM(KeyWord).eq.'NDEFAVG2') THEN
            Npts=load_i(Nval, Rval, Ngrids, ndefAVG2)
          ELSE IF (TRIM(KeyWord).eq.'NTSDIA') THEN
            Npts=load_i(Nval, Rval, Ngrids, ntsDIA)
          ELSE IF (TRIM(KeyWord).eq.'NDIA') THEN
            Npts=load_i(Nval, Rval, Ngrids, nDIA)
          ELSE IF (TRIM(KeyWord).eq.'NDEFDIA') THEN
            Npts=load_i(Nval, Rval, Ngrids, ndefDIA)
          ELSE IF (TRIM(KeyWord).eq.'LcycleTLM') THEN
            Npts=load_l(Nval, Cval, Ngrids, LcycleTLM)
          ELSE IF (TRIM(KeyWord).eq.'NTLM') THEN
            Npts=load_i(Nval, Rval, Ngrids, nTLM)
          ELSE IF (TRIM(KeyWord).eq.'NDEFTLM') THEN
            Npts=load_i(Nval, Rval, Ngrids, ndefTLM)
          ELSE IF (TRIM(KeyWord).eq.'LcycleADJ') THEN
            Npts=load_l(Nval, Cval, Ngrids, LcycleADJ)
          ELSE IF (TRIM(KeyWord).eq.'NADJ') THEN
            Npts=load_i(Nval, Rval, Ngrids, nADJ)
          ELSE IF (TRIM(KeyWord).eq.'NDEFADJ') THEN
            Npts=load_i(Nval, Rval, Ngrids, ndefADJ)
          ELSE IF (TRIM(KeyWord).eq.'NOBC') THEN
            Npts=load_i(Nval, Rval, Ngrids, nOBC)
#ifdef ADJUST_BOUNDARY
            DO ng=1,Ngrids
              Nbrec(ng)=1+ntimes(ng)/nOBC(ng)
            END DO
            allocate ( OBC_time(MAXVAL(Nbrec),Ngrids) )
#endif
          ELSE IF (TRIM(KeyWord).eq.'NSFF') THEN
            Npts=load_i(Nval, Rval, Ngrids, nSFF)
#if defined ADJUST_STFLUX || defined ADJUST_WSTRESS
            DO ng=1,Ngrids
              Nfrec(ng)=1+ntimes(ng)/nSFF(ng)
            END DO
            allocate ( SF_time(MAXVAL(Nfrec),Ngrids) )
#endif
          ELSE IF (TRIM(KeyWord).eq.'LmultiGST') THEN
            Npts=load_l(Nval, Cval, 1, LmultiGST)
          ELSE IF (TRIM(KeyWord).eq.'LrstGST') THEN
            Npts=load_l(Nval, Cval, 1, LrstGST)
          ELSE IF (TRIM(KeyWord).eq.'MaxIterGST') THEN
            Npts=load_i(Nval, Rval, 1, MaxIterGST)
          ELSE IF (TRIM(KeyWord).eq.'NGST') THEN
            Npts=load_i(Nval, Rval, 1, nGST)
#ifdef PROPAGATOR
          ELSE IF (TRIM(KeyWord).eq.'Ritz_tol') THEN
            Npts=load_r(Nval, Rval, 1, Ritz_tol)
#endif
          ELSE IF (TRIM(KeyWord).eq.'TNU2') THEN
            Npts=load_r(Nval, Rval, (NAT+NPT)*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                nl_tnu2(itrc,ng)=Rtracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                nl_tnu2(itrc,ng)=Rtracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'TNU4') THEN
            Npts=load_r(Nval, Rval, (NAT+NPT)*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                nl_tnu4(itrc,ng)=Rtracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                nl_tnu4(itrc,ng)=Rtracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'ad_TNU2') THEN
            Npts=load_r(Nval, Rval, (NAT+NPT)*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                ad_tnu2(itrc,ng)=Rtracer(itrc,ng)
                tl_tnu2(itrc,ng)=Rtracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                ad_tnu2(itrc,ng)=Rtracer(NAT+i,ng)
                tl_tnu2(itrc,ng)=Rtracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'ad_TNU4') THEN
            Npts=load_r(Nval, Rval, (NAT+NPT)*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                ad_tnu4(itrc,ng)=Rtracer(itrc,ng)
                tl_tnu4(itrc,ng)=Rtracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                ad_tnu4(itrc,ng)=Rtracer(NAT+i,ng)
                tl_tnu4(itrc,ng)=Rtracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'VISC2') THEN
            Npts=load_r(Nval, Rval, Ngrids, nl_visc2)
          ELSE IF (TRIM(KeyWord).eq.'VISC4') THEN
            Npts=load_r(Nval, Rval, Ngrids, nl_visc4)
          ELSE IF (TRIM(KeyWord).eq.'ad_VISC2') THEN
            Npts=load_r(Nval, Rval, Ngrids, ad_visc2)
            DO ng=1,Ngrids
              tl_visc2(ng)=ad_visc2(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'ad_VISC4') THEN
            Npts=load_r(Nval, Rval, Ngrids, ad_visc4)
            DO ng=1,Ngrids
              tl_visc4(ng)=ad_visc4(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'AKT_BAK') THEN
            Npts=load_r(Nval, Rval, (NAT+NPT)*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Akt_bak(itrc,ng)=Rtracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Akt_bak(itrc,ng)=Rtracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'ad_AKT_fac') THEN
            Npts=load_r(Nval, Rval, (NAT+NPT)*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                ad_Akt_fac(itrc,ng)=Rtracer(itrc,ng)
                tl_Akt_fac(itrc,ng)=Rtracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                ad_Akt_fac(itrc,ng)=Rtracer(NAT+i,ng)
                tl_Akt_fac(itrc,ng)=Rtracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'AKV_BAK') THEN
            Npts=load_r(Nval, Rval, Ngrids, Akv_bak)
          ELSE IF (TRIM(KeyWord).eq.'ad_AKV_fac') THEN
            Npts=load_r(Nval, Rval, Ngrids, ad_Akv_fac)
            DO ng=1,Ngrids
              tl_Akv_fac(ng)=ad_AKv_fac(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'AKK_BAK') THEN
            Npts=load_r(Nval, Rval, Ngrids, Akk_bak)
          ELSE IF (TRIM(KeyWord).eq.'AKP_BAK') THEN
            Npts=load_r(Nval, Rval, Ngrids, Akp_bak)
          ELSE IF (TRIM(KeyWord).eq.'TKENU2') THEN
            Npts=load_r(Nval, Rval, Ngrids, tkenu2)
          ELSE IF (TRIM(KeyWord).eq.'TKENU4') THEN
            Npts=load_r(Nval, Rval, Ngrids, tkenu4)
          ELSE IF (TRIM(KeyWord).eq.'GLS_P') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_p)
          ELSE IF (TRIM(KeyWord).eq.'GLS_M') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_m)
          ELSE IF (TRIM(KeyWord).eq.'GLS_N') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_n)
          ELSE IF (TRIM(KeyWord).eq.'GLS_Kmin') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_Kmin)
          ELSE IF (TRIM(KeyWord).eq.'GLS_Pmin') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_Pmin)
          ELSE IF (TRIM(KeyWord).eq.'GLS_CMU0') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_cmu0)
          ELSE IF (TRIM(KeyWord).eq.'GLS_C1') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_c1)
          ELSE IF (TRIM(KeyWord).eq.'GLS_C2') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_c2)
          ELSE IF (TRIM(KeyWord).eq.'GLS_C3M') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_c3m)
          ELSE IF (TRIM(KeyWord).eq.'GLS_C3P') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_c3p)
          ELSE IF (TRIM(KeyWord).eq.'GLS_SIGK') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_sigk)
          ELSE IF (TRIM(KeyWord).eq.'GLS_SIGP') THEN
            Npts=load_r(Nval, Rval, Ngrids, gls_sigp)
          ELSE IF (TRIM(KeyWord).eq.'CHARNOK_ALPHA') THEN
            Npts=load_r(Nval, Rval, Ngrids, charnok_alpha)
          ELSE IF (TRIM(KeyWord).eq.'ZOS_HSIG_ALPHA') THEN
            Npts=load_r(Nval, Rval, Ngrids, zos_hsig_alpha)
          ELSE IF (TRIM(KeyWord).eq.'SZ_ALPHA') THEN
            Npts=load_r(Nval, Rval, Ngrids, sz_alpha)
          ELSE IF (TRIM(KeyWord).eq.'CRGBAN_CW') THEN
            Npts=load_r(Nval, Rval, Ngrids, crgban_cw)
          ELSE IF (TRIM(KeyWord).eq.'RDRG') THEN
            Npts=load_r(Nval, Rval, Ngrids, rdrg)
          ELSE IF (TRIM(KeyWord).eq.'RDRG2') THEN
            Npts=load_r(Nval, Rval, Ngrids, rdrg2)
          ELSE IF (TRIM(KeyWord).eq.'Zob') THEN
            Npts=load_r(Nval, Rval, Ngrids, Zob)
          ELSE IF (TRIM(KeyWord).eq.'Zos') THEN
            Npts=load_r(Nval, Rval, Ngrids, Zos)
#ifdef BULK_FLUXES
          ELSE IF (TRIM(KeyWord).eq.'BLK_ZQ') THEN
            Npts=load_r(Nval, Rval, Ngrids, blk_ZQ)
          ELSE IF (TRIM(KeyWord).eq.'BLK_ZT') THEN
            Npts=load_r(Nval, Rval, Ngrids, blk_ZT)
          ELSE IF (TRIM(KeyWord).eq.'BLK_ZW') THEN
            Npts=load_r(Nval, Rval, Ngrids, blk_ZW)
#endif
          ELSE IF (TRIM(KeyWord).eq.'DCRIT') THEN
            Npts=load_r(Nval, Rval, Ngrids, Dcrit)
          ELSE IF (TRIM(KeyWord).eq.'WTYPE') THEN
            Npts=load_i(Nval, Rval, Ngrids, lmd_Jwt)
          ELSE IF (TRIM(KeyWord).eq.'LEVSFRC') THEN
            Npts=load_i(Nval, Rval, Ngrids, levsfrc)
          ELSE IF (TRIM(KeyWord).eq.'LEVBFRC') THEN
            Npts=load_i(Nval, Rval, Ngrids, levbfrc)
          ELSE IF (TRIM(KeyWord).eq.'Vtransform') THEN
            Npts=load_i(Nval, Rval, Ngrids, Vtransform)
            DO ng=1,Ngrids
              IF ((Vtransform(ng).lt.0).or.                             &
     &            (Vtransform(ng).gt.3)) THEN
                IF (Master) WRITE (out,260) 'Vtransform = ',            &
     &                                      Vtransform(ng),             &
     &                                      'Must be either 1, 2 or 3'
                exit_flag=5
                RETURN
              END IF
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Vstretching') THEN
            Npts=load_i(Nval, Rval, Ngrids, Vstretching)
            DO ng=1,Ngrids
              IF ((Vstretching(ng).lt.0).or.                            &
     &            (Vstretching(ng).gt.4)) THEN
                IF (Master) WRITE (out,260) 'Vstretching = ',           &
     &                                      Vstretching(ng),            &
     &                                      'Must between 1 and 4'
                exit_flag=5
                RETURN
              END IF
            END DO
          ELSE IF (TRIM(KeyWord).eq.'THETA_S') THEN
            Npts=load_r(Nval, Rval, Ngrids, theta_s)
          ELSE IF (TRIM(KeyWord).eq.'THETA_B') THEN
            Npts=load_r(Nval, Rval, Ngrids, theta_b)
          ELSE IF (TRIM(KeyWord).eq.'TCLINE') THEN
            Npts=load_r(Nval, Rval, Ngrids, Tcline)
            DO ng=1,Ngrids
              hc(ng)=Tcline(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'RHO0') THEN
            Npts=load_r(Nval, Rval, 1, rho0)
          ELSE IF (TRIM(KeyWord).eq.'BVF_BAK') THEN
            Npts=load_r(Nval, Rval, 1, bvf_bak)
          ELSE IF (TRIM(KeyWord).eq.'DSTART') THEN
            Npts=load_r(Nval, Rval, 1, dstart)
          ELSE IF (TRIM(KeyWord).eq.'TIDE_START') THEN
            Npts=load_r(Nval, Rval, 1, tide_start)
          ELSE IF (TRIM(KeyWord).eq.'TIME_REF') THEN
            Npts=load_r(Nval, Rval, 1, time_ref)
            IF (time_ref .eq. -1) days_year = 360.
            IF (time_ref .gt. 0) days_year = 365.
            r_text=ref_att(time_ref,r_date)
          ELSE IF (TRIM(KeyWord).eq.'TNUDG') THEN
            Npts=load_r(Nval, Rval, (NAT+NPT)*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Tnudg(itrc,ng)=Rtracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Tnudg(itrc,ng)=Rtracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'ZNUDG') THEN
            Npts=load_r(Nval, Rval, Ngrids, Znudg)
          ELSE IF (TRIM(KeyWord).eq.'M2NUDG') THEN
            Npts=load_r(Nval, Rval, Ngrids, M2nudg)
          ELSE IF (TRIM(KeyWord).eq.'M3NUDG') THEN
            Npts=load_r(Nval, Rval, Ngrids, M3nudg)
          ELSE IF (TRIM(KeyWord).eq.'OBCFAC') THEN
            Npts=load_r(Nval, Rval, Ngrids, obcfac)
          ELSE IF (TRIM(KeyWord).eq.'R0') THEN
            Npts=load_r(Nval, Rval, Ngrids, R0)
            DO ng=1,Ngrids
              IF (R0(ng).lt.100.0_r8) R0(ng)=R0(ng)+1000.0_r8
            END DO
          ELSE IF (TRIM(KeyWord).eq.'T0') THEN
            Npts=load_r(Nval, Rval, Ngrids, T0)
          ELSE IF (TRIM(KeyWord).eq.'S0') THEN
            Npts=load_r(Nval, Rval, Ngrids, S0)
          ELSE IF (TRIM(KeyWord).eq.'TCOEF') THEN
            Npts=load_r(Nval, Rval, Ngrids, Tcoef)
            DO ng=1,Ngrids
              Tcoef(ng)=ABS(Tcoef(ng))
            END DO
          ELSE IF (TRIM(KeyWord).eq.'SCOEF') THEN
            Npts=load_r(Nval, Rval, Ngrids, Scoef)
            DO ng=1,Ngrids
              Scoef(ng)=ABS(Scoef(ng))
            END DO
          ELSE IF (TRIM(KeyWord).eq.'GAMMA2') THEN
            Npts=load_r(Nval, Rval, Ngrids, gamma2)
#if defined AD_SENSITIVITY   || defined IS4DVAR_SENSITIVITY || \
    defined OPT_OBSERVATIONS || defined SENSITIVITY_4DVAR   || \
    defined SO_SEMI
          ELSE IF (TRIM(KeyWord).eq.'DstrS') THEN
            Npts=load_r(Nval, Rval, Ngrids, DstrS)
          ELSE IF (TRIM(KeyWord).eq.'DendS') THEN
            Npts=load_r(Nval, Rval, Ngrids, DendS)
          ELSE IF (TRIM(KeyWord).eq.'KstrS') THEN
            Npts=load_i(Nval, Rval, Ngrids, KstrS)
          ELSE IF (TRIM(KeyWord).eq.'KendS') THEN
            Npts=load_i(Nval, Rval, Ngrids, KendS)
          ELSE IF (TRIM(KeyWord).eq.'Lstate(isFsur)') THEN
            IF (isFsur.eq.0) THEN
              IF (Master) WRITE (out,280) 'isFsur'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Lstate(isFsur)=Ladsen(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Lstate(isUbar)') THEN
            IF (isUbar.eq.0) THEN
              IF (Master) WRITE (out,280) 'isUbar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Lstate(isUbar)=Ladsen(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Lstate(isVbar)') THEN
            IF (isVbar.eq.0) THEN
              IF (Master) WRITE (out,280) 'isVbar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Lstate(isVbar)=Ladsen(ng)
            END DO
# ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Lstate(isUvel)') THEN
            IF (isUvel.eq.0) THEN
              IF (Master) WRITE (out,280) 'isUvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Lstate(isUvel)=Ladsen(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Lstate(isVvel)') THEN
            IF (isVvel.eq.0) THEN
              IF (Master) WRITE (out,280) 'isVvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Lstate(isVvel)=Ladsen(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Lstate(isTvar)') THEN
            IF (MAXVAL(isTvar).eq.0) THEN
              IF (Master) WRITE (out,280) 'isTvar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, MT*Ngrids, Ladsen)
            k=0
            DO ng=1,Ngrids
              DO itrc=1,MT
                k=k+1
                i=isTvar(itrc)
                SCALARS(ng)%Lstate(i)=Ladsen(k)
              END DO
            END DO
# endif
#endif
#if defined FORCING_SV || defined SO_SEMI
          ELSE IF (TRIM(KeyWord).eq.'Fstate(isFsur)') THEN
            IF (isFsur.eq.0) THEN
              IF (Master) WRITE (out,280) 'isFsur'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Fstate(isFsur)=Ladsen(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Fstate(isUbar)') THEN
            IF (isUbar.eq.0) THEN
              IF (Master) WRITE (out,280) 'isUbar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Fstate(isUbar)=Ladsen(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Fstate(isVbar)') THEN
            IF (isVbar.eq.0) THEN
              IF (Master) WRITE (out,280) 'isVbar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Fstate(isVbar)=Ladsen(ng)
            END DO
# ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Fstate(isUvel)') THEN
            IF (isUvel.eq.0) THEN
              IF (Master) WRITE (out,280) 'isUvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Fstate(isUvel)=Ladsen(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Fstate(isVvel)') THEN
            IF (isVvel.eq.0) THEN
              IF (Master) WRITE (out,280) 'isVvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Fstate(isVvel)=Ladsen(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Fstate(isTvar)') THEN
            IF (MAXVAL(isTvar).eq.0) THEN
              IF (Master) WRITE (out,280) 'isTvar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, MT*Ngrids, Ladsen)
            k=0
            DO ng=1,Ngrids
              DO itrc=1,MT
                k=k+1
                i=isTvar(itrc)
                SCALARS(ng)%Fstate(i)=Ladsen(k)
              END DO
            END DO
# endif
          ELSE IF (TRIM(KeyWord).eq.'Fstate(isUstr)') THEN
            IF (isUstr.eq.0) THEN
              IF (Master) WRITE (out,280) 'isUstr'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Fstate(isUstr)=Ladsen(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Fstate(isVstr)') THEN
            IF (isUstr.eq.0) THEN
              IF (Master) WRITE (out,280) 'isVstr'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ladsen)
            DO ng=1,Ngrids
              SCALARS(ng)%Fstate(isVstr)=Ladsen(ng)
            END DO
# ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Fstate(isTsur)') THEN
            IF (MAXVAL(isTsur).eq.0) THEN
              IF (Master) WRITE (out,280) 'isTsur'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, MT*Ngrids, Ladsen)
            k=0
            DO ng=1,Ngrids
              DO itrc=1,MT
                k=k+1
                i=isTsur(itrc)
                SCALARS(ng)%Fstate(i)=Ladsen(k)
              END DO
            END DO
# endif
#endif
#ifdef SO_SEMI
          ELSE IF (TRIM(KeyWord).eq.'SO_decay') THEN
            Npts=load_r(Nval, Rval, Ngrids, SO_decay)
          ELSE IF (TRIM(KeyWord).eq.'SO_sdev(isFsur)') THEN
            Npts=load_r(Nval, Rval, Ngrids, SO_sdev(isFsur,1))
          ELSE IF (TRIM(KeyWord).eq.'SO_sdev(isUbar)') THEN
            Npts=load_r(Nval, Rval, Ngrids, SO_sdev(isUbar,1))
          ELSE IF (TRIM(KeyWord).eq.'SO_sdev(isVbar)') THEN
            Npts=load_r(Nval, Rval, Ngrids, SO_sdev(isVbar,1))
# ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'SO_sdev(isUvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, SO_sdev(isUvel,1))
          ELSE IF (TRIM(KeyWord).eq.'SO_sdev(isVvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, SO_sdev(isVvel,1))
          ELSE IF (TRIM(KeyWord).eq.'SO_sdev(isTvar)') THEN
            Npts=load_r(Nval, Rval, MT*Ngrids, tracer)
            k=0
            DO ng=1,Ngrids
              DO itrc=1,MT
                k=k+1
                i=isTvar(itrc)
                SO_sdev(i,ng)=tracer(k,ng)
              END DO
            END DO
# endif
          ELSE IF (TRIM(KeyWord).eq.'SO_sdev(isUstr)') THEN
            Npts=load_r(Nval, Rval, Ngrids, SO_sdev(isUstr,1))
          ELSE IF (TRIM(KeyWord).eq.'SO_sdev(isVstr)') THEN
            Npts=load_r(Nval, Rval, Ngrids, SO_sdev(isVstr,1))
# ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'SO_sdev(isTsur)') THEN
            Npts=load_r(Nval, Rval, MT*Ngrids, tracer)
            k=0
            DO ng=1,Ngrids
              DO itrc=1,MT
                k=k+1
                i=isTsur(itrc)
                SO_sdev(i,ng)=tracer(k,ng)
              END DO
            END DO
# endif
#endif
#if defined SOLVE3D && defined TS_PSOURCE
          ELSE IF (TRIM(KeyWord).eq.'LtracerSrc') THEN
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                LtracerSrc(itrc,ng)=Ltracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                LtracerSrc(itrc,ng)=Ltracer(NAT+i,ng)
              END DO
# endif
            END DO
#endif
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUvel)') THEN
            IF (idUvel.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVvel)') THEN
            IF (idVvel.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWvel)') THEN
            IF (idWvel.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idOvel)') THEN
            IF (idOvel.eq.0) THEN
              IF (Master) WRITE (out,280) 'idOvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idOvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUbar)') THEN
            IF (idUbar.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUbar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUbar,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVbar)') THEN
            IF (idVbar.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVbar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVbar,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idFsur)') THEN
            IF (idFsur.eq.0) THEN
              IF (Master) WRITE (out,280) 'idFsur'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idFsur,:))
#if defined SEDIMENT && defined SED_MORPH
          ELSE IF (TRIM(KeyWord).eq.'Hout(idBath)') THEN
            IF (idbath.eq.0) THEN
              IF (Master) WRITE (out,280) 'idbath'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idBath,:))
#endif
          ELSE IF (TRIM(KeyWord).eq.'Hout(idTvar)') THEN
            IF (MAXVAL(idTvar).eq.0) THEN
              IF (Master) WRITE (out,280) 'idTvar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idTvar(itrc)
                Hout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUsms)') THEN
            IF (idUsms.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUsms'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUsms,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVsms)') THEN
            IF (idVsms.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVsms'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVsms,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUbms)') THEN
            IF (idUbms.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUbms'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUbms,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVbms)') THEN
            IF (idVbms.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVbms'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVbms,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUbrs)') THEN
            IF (idUbrs.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUbrs'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUbrs,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVbrs)') THEN
            IF (idVbrs.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVbrs'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVbrs,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUbws)') THEN
            IF (idUbws.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUbws'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUbws,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVbws)') THEN
            IF (idVbws.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVbws'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVbws,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUbcs)') THEN
            IF (idUbcs.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUbcs'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUbcs,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVbcs)') THEN
            IF (idVbcs.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVbcs'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVbcs,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUbot)') THEN
            IF (idUbot.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUbot'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUbot,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVbot)') THEN
            IF (idVbot.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVbot'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVbot,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUbur)') THEN
            IF (idUbur.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUbur'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUbur,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVbvr)') THEN
            IF (idVbvr.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVbvr'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVbvr,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idW2xx)') THEN
            IF (idW2xx.eq.0) THEN
              IF (Master) WRITE (out,280) 'idW2xx'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idW2xx,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idW2xy)') THEN
            IF (idW2xy.eq.0) THEN
              IF (Master) WRITE (out,280) 'idW2xy'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idW2xy,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idW2yy)') THEN
            IF (idW2yy.eq.0) THEN
              IF (Master) WRITE (out,280) 'idW2yy'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idW2yy,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idU2rs)') THEN
            IF (idU2rs.eq.0) THEN
              IF (Master) WRITE (out,280) 'idU2rs'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idU2rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idV2rs)') THEN
            IF (idV2rs.eq.0) THEN
              IF (Master) WRITE (out,280) 'idV2rs'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idV2rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idU2Sd)') THEN
            IF (idU2Sd.eq.0) THEN
              IF (Master) WRITE (out,280) 'idU2Sd'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idU2Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idV2Sd)') THEN
            IF (idV2Sd.eq.0) THEN
              IF (Master) WRITE (out,280) 'idV2Sd'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idV2Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idW3xx)') THEN
            IF (idW3xx.eq.0) THEN
              IF (Master) WRITE (out,280) 'idW3xx'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idW3xx,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idW3xy)') THEN
            IF (idW3xy.eq.0) THEN
              IF (Master) WRITE (out,280) 'idW3xy'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idW3xy,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idW3yy)') THEN
            IF (idW3yy.eq.0) THEN
              IF (Master) WRITE (out,280) 'idW3yy'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idW3yy,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idW3zx)') THEN
            IF (idW3zx.eq.0) THEN
              IF (Master) WRITE (out,280) 'idW3zx'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idW3zx,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idW3zy)') THEN
            IF (idW3zy.eq.0) THEN
              IF (Master) WRITE (out,280) 'idW3zy'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idW3zy,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idU3rs)') THEN
            IF (idU3rs.eq.0) THEN
              IF (Master) WRITE (out,280) 'idU3rs'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idU3rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idV3rs)') THEN
            IF (idV3rs.eq.0) THEN
              IF (Master) WRITE (out,280) 'idV3rs'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idV3rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idU3Sd)') THEN
            IF (idU3Sd.eq.0) THEN
              IF (Master) WRITE (out,280) 'idU3Sd'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idU3Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idV3Sd)') THEN
            IF (idV3Sd.eq.0) THEN
              IF (Master) WRITE (out,280) 'idV3Sd'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idV3Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWamp)') THEN
            IF (idWamp.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWamp'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWamp,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWlen)') THEN
            IF (idWlen.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWlen'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWlen,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWdir)') THEN
            IF (idWdir.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWdir'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWdir,:))
#ifdef WAVES_TOP_PERIOD
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWptp)') THEN
            IF (idWptp.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWptp'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWptp,:))
#endif
#ifdef WAVES_BOT_PERIOD
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWpbt)') THEN
            IF (idWpbt.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWpbt'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWpbt,:))
#endif
#ifdef WAVES_UB
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWorb)') THEN
            IF (idWorb.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWorb'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWorb,:))
#endif
#if defined TKE_WAVEDISS || defined WAVES_OCEAN
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWdis)') THEN
            IF (idWdis.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWdis'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWdis,:))
#endif
#ifdef SOLVE3D
# if defined BULK_FLUXES || defined ECOSIM || defined ATM_PRESS
          ELSE IF (TRIM(KeyWord).eq.'Hout(idPair)') THEN
            IF (idPair.eq.0) THEN
              IF (Master) WRITE (out,280) 'idPair'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idPair,:))
# endif
# if defined BULK_FLUXES || defined ECOSIM
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUair)') THEN
            IF (idUair.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUair'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUair,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVair)') THEN
            IF (idPair.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVair'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVair,:))
# endif
#endif
          ELSE IF (TRIM(KeyWord).eq.'Hout(idTsur)') THEN
            IF (idTsur(itemp).eq.0) THEN
              IF (Master) WRITE (out,280) 'idTsur'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idTsur(itrc)
                Hout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Hout(idLhea)') THEN
            IF (idLhea.eq.0) THEN
              IF (Master) WRITE (out,280) 'idLhea'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idLhea,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idShea)') THEN
            IF (idShea.eq.0) THEN
              IF (Master) WRITE (out,280) 'idShea'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idShea,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idLrad)') THEN
            IF (idLrad.eq.0) THEN
              IF (Master) WRITE (out,280) 'idLrad'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idLrad,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idSrad)') THEN
            IF (idSrad.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSrad'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idSrad,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idSSSf)') THEN
            IF (idSSSf.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSSSf'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idSSSf,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idEmPf)') THEN
            IF (idEmPf.eq.0) THEN
              IF (Master) WRITE (out,280) 'idEmPf'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idEmPf,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idevap)') THEN
            IF (idevap.eq.0) THEN
              IF (Master) WRITE (out,280) 'idevap'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idevap,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idrain)') THEN
            IF (idrain.eq.0) THEN
              IF (Master) WRITE (out,280) 'idrain'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idrain,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idDano)') THEN
            IF (idDano.eq.0) THEN
              IF (Master) WRITE (out,280) 'idDano'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idDano,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVvis)') THEN
            IF (idVvis.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVvis'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVvis,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idTdif)') THEN
            IF (idTdif.eq.0) THEN
              IF (Master) WRITE (out,280) 'idTdif'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idTdif,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idSdif)') THEN
            IF (idSdif.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSdif'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idSdif,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idHsbl)') THEN
            IF (idHsbl.eq.0) THEN
              IF (Master) WRITE (out,280) 'idHsbl'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idHsbl,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idHbbl)') THEN
            IF (idHbbl.eq.0) THEN
              IF (Master) WRITE (out,280) 'idHbbl'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idHbbl,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idMtke)') THEN
            IF (idMtke.eq.0) THEN
              IF (Master) WRITE (out,280) 'idMtke'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idMtke,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idMtls)') THEN
            IF (idMtls.eq.0) THEN
              IF (Master) WRITE (out,280) 'idMtls'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idMtls,:))
#if defined SOLVE3D && defined T_PASSIVE
          ELSE IF (TRIM(KeyWord).eq.'Hout(inert)') THEN
            Npts=load_l(Nval, Cval, NPT*Ngrids, Linert)
            DO ng=1,Ngrids
              DO i=1,NPT
                itrc=idTvar(inert(i))
# ifdef AGE_DISTRIBUTION
                Hout(itrc,ng)=Linert(1,ng)
# else
                Hout(itrc,ng)=Linert(i,ng)
# endif
              END DO
            END DO
#endif
#ifdef ICE_MODEL
          ELSE IF (TRIM(KeyWord).eq.'Hout(idUice)') THEN
            IF (idUice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idUice,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idVice)') THEN
            IF (idVice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idVice,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idAice)') THEN
            IF (idAice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idAice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idAice,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idHice)') THEN
            IF (idHice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idHice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idHice,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idHsno)') THEN
            IF (idHsno.eq.0) THEN
              IF (Master) WRITE (out,280) 'idHsno'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idHsno,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idTice)') THEN
            IF (idTice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idTice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idTice,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idTimid)') THEN
            IF (idTimid.eq.0) THEN
              IF (Master) WRITE (out,280) 'idTimid'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idTimid,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idTauiw)') THEN
            IF (idTauiw.eq.0) THEN
              IF (Master) WRITE (out,280) 'idTauiw'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idTauiw,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idChuiw)') THEN
            IF (idChuiw.eq.0) THEN
              IF (Master) WRITE (out,280) 'idChuiw'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idChuiw,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idSfwat)') THEN
            IF (idSfwat.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSfwat'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idSfwat,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idAgeice)') THEN
            IF (idAgeice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idAgeice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idAgeice,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idIomflx)') THEN
            IF (idIomflx.eq.0) THEN
              IF (Master) WRITE (out,280) 'idIomflx'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idIomflx,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idSig11)') THEN
            IF (idSig11.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSig11'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idSig11,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idSig12)') THEN
            IF (idSig12.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSig12'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idSig12,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idSig22)') THEN
            IF (idSig22.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSig22'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idSig22,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idT0mk)') THEN
            IF (idT0mk.eq.0) THEN
              IF (Master) WRITE (out,280) 'idT0mk'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idT0mk,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idS0mk)') THEN
            IF (idS0mk.eq.0) THEN
              IF (Master) WRITE (out,280) 'idS0mk'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idS0mk,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWfr)') THEN
            IF (idWfr.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWfr'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWfr,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWai)') THEN
            IF (idWai.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWai'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWai,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWao)') THEN
            IF (idWao.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWao'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWao,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWio)') THEN
            IF (idWio.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWio'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWio,:))
          ELSE IF (TRIM(KeyWord).eq.'Hout(idWro)') THEN
            IF (idWro.eq.0) THEN
              IF (Master) WRITE (out,280) 'idWro'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Hout(idWro,:))
#endif
#if defined SOLVE3D && (defined BBL_MODEL || defined SEDIMENT)
          ELSE IF (TRIM(KeyWord).eq.'Hout(idBott)') THEN
            IF (MAXVAL(idBott).eq.0) THEN
              IF (Master) WRITE (out,280) 'idBott'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, MBOTP*Ngrids, Lbottom)
            DO ng=1,Ngrids
              DO itrc=1,MBOTP
                i=idBott(itrc)
                Hout(i,ng)=Lbottom(itrc,ng)
              END DO
            END DO
#endif
!! Going to assume that we don't need to check for id's being zero
!! since we already did that for Hout.
#if defined SEDIMENT && defined SED_MORPH
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idBath)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idBath,:))
#endif
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idFsur)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idFsur,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idUbar)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idUbar,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idVbar)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idVbar,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idUvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idUvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idVvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idVvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idTvar)') THEN
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idTvar(itrc)
                Aout2(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idUair)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idUair,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idVair)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idVair,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idUsms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idUsms,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idVsms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idVsms,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idWamp)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idWamp,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idWlen)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idWlen,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idWdir)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idWdir,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idTsur)') THEN
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idTsur(itrc)
                Aout2(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idLhea)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idLhea,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idShea)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idShea,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idLrad)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idLrad,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idSrad)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idSrad,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idSSSf)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idSSSf,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idevap)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idevap,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idrain)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idrain,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idDano)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idDano,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idHsbl)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idHsbl,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idHbbl)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idHbbl,:))
#if defined SOLVE3D && defined T_PASSIVE
          ELSE IF (TRIM(KeyWord).eq.'Aout2(inert)') THEN
            Npts=load_l(Nval, Cval, NPT*Ngrids, Linert)
            DO ng=1,Ngrids
              DO itrc=1,NPT
                i=idTvar(inert(itrc))
                Aout2(i,ng)=Linert(itrc,ng)
              END DO
            END DO
#endif
#ifdef ICE_MODEL
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idUice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idUice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idVice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idVice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idAice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idAice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idHice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idHice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idHsno)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idHsno,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idTice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idTice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idTimid)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idTimid,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idTauiw)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idTauiw,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idChuiw)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idChuiw,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idSfwat)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idSfwat,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idAgeice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idAgeice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idIomflx)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idIomflx,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idSig11)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idSig11,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idSig12)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idSig12,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idSig22)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idSig22,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idT0mk)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idT0mk,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idS0mk)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout2(idS0mk,:))
#endif
#if defined SOLVE3D && (defined BBL_MODEL || defined SEDIMENT)
          ELSE IF (TRIM(KeyWord).eq.'Aout2(idBott)') THEN
            Npts=load_l(Nval, Cval, MBOTP*Ngrids, Lbottom)
            DO ng=1,Ngrids
              DO itrc=1,MBOTP
                i=idBott(itrc)
                Aout2(i,ng)=Lbottom(itrc,ng)
              END DO
            END DO
#endif
#if defined AVERAGES    || \
   (defined AD_AVERAGES && defined ADJOINT) || \
   (defined RP_AVERAGES && defined TL_IOMS) || \
   (defined TL_AVERAGES && defined TANGENT)
          ELSE IF (TRIM(KeyWord).eq.'Aout(idUvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idUvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idVvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idVvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idWvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idWvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idOvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idOvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idUbar)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idUbar,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idVbar)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idVbar,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idFsur)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idFsur,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idTvar)') THEN
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idTvar(itrc)
                Aout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Aout(idUsms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idUsms,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idVsms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idVsms,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idUbms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idUbms,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idVbms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idVbms,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idW2xx)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idW2xx,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idW2xy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idW2xy,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idW2yy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idW2yy,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idU2rs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idU2rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idV2rs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idV2rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idU2Sd)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idU2Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idV2Sd)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idV2Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idW3xx)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idW3xx,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idW3xy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idW3xy,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idW3yy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idW3yy,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idW3zx)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idW3zx,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idW3zy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idW3zy,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idU3rs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idU3rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idV3rs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idV3rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idU3Sd)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idU3Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idV3Sd)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idV3Sd,:))
# ifdef SOLVE3D
#  if defined BULK_FLUXES || defined ECOSIM || defined ATM_PRESS
          ELSE IF (TRIM(KeyWord).eq.'Aout(idPair)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idPair,:))
#  endif
#  if defined BULK_FLUXES || defined ECOSIM
          ELSE IF (TRIM(KeyWord).eq.'Aout(idUair)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idUair,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idVair)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idVair,:))
#  endif
# endif
          ELSE IF (TRIM(KeyWord).eq.'Aout(idTsur)') THEN
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idTsur(itrc)
                Aout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Aout(idLhea)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idLhea,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idShea)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idShea,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idLrad)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idLrad,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idSrad)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idSrad,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idSSSf)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idSSSf,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idevap)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idevap,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idrain)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idrain,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idDano)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idDano,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idVvis)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idVvis,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idTdif)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idTdif,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idSdif)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idSdif,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idHsbl)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idHsbl,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idHbbl)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Aout(idHbbl,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(id2dRV)') THEN
            IF (id2dRV.eq.0) THEN
              IF (Master) WRITE (out,280) 'id2dRV'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(id2dRV,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(id3dRV)') THEN
            IF (id3dRV.eq.0) THEN
              IF (Master) WRITE (out,280) 'id3dRV'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(id3dRV,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(id2dPV)') THEN
            IF (id2dPV.eq.0) THEN
              IF (Master) WRITE (out,280) 'id2dPV'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(id2dPV,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(id3dPV)') THEN
            IF (id3dPV.eq.0) THEN
              IF (Master) WRITE (out,280) 'id3dPV'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(id3dPV,:))
# if defined AVERAGES_DETIDE && (defined SSH_TIDES || defined UV_TIDES)
          ELSE IF (TRIM(KeyWord).eq.'Aout(idFsuD)') THEN
            IF (idFsuD.eq.0) THEN
              IF (Master) WRITE (out,280) 'idFsuD'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idFsuD,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idu2dD)') THEN
            IF (idu2dD.eq.0) THEN
              IF (Master) WRITE (out,280) 'idu2dD'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idu2dD,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idv2dD)') THEN
            IF (idv2dD.eq.0) THEN
              IF (Master) WRITE (out,280) 'idv2dD'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idv2dD,:))
#  ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Aout(idu3dD)') THEN
            IF (idu3dD.eq.0) THEN
              IF (Master) WRITE (out,280) 'idu3dD'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idu3dD,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idv3dD)') THEN
            IF (idv3dD.eq.0) THEN
              IF (Master) WRITE (out,280) 'idv3dD'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idv3dD,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idTrcD)') THEN
            IF (MAXVAL(idTrcD).eq.0) THEN
              IF (Master) WRITE (out,280) 'idTrcD'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idTrcD(itrc)
                Aout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
#  endif
# endif
# ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Aout(idHUav)') THEN
            IF (idHUav.eq.0) THEN
              IF (Master) WRITE (out,280) 'idHUav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idHUav,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idHVav)') THEN
            IF (idHVav.eq.0) THEN
              IF (Master) WRITE (out,280) 'idHVav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idHVav,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idUUav)') THEN
            IF (idUUav.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUUav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idUUav,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idUVav)') THEN
            IF (idUVav.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUVav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idUVav,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idVVav)') THEN
            IF (idVVav.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVVav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idVVav,:))
# endif
          ELSE IF (TRIM(KeyWord).eq.'Aout(idU2av)') THEN
            IF (idU2av.eq.0) THEN
              IF (Master) WRITE (out,280) 'idU2av'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idU2av,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idV2av)') THEN
            IF (idV2av.eq.0) THEN
              IF (Master) WRITE (out,280) 'idV2av'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idV2av,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idZZav)') THEN
            IF (idZZav.eq.0) THEN
              IF (Master) WRITE (out,280) 'idZZav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idZZav,:))
# ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Aout(idTTav)') THEN
            IF (MAXVAL(idTTav).eq.0) THEN
              IF (Master) WRITE (out,280) 'idTTav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idTTav(itrc)
                Aout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Aout(idUTav)') THEN
            IF (MAXVAL(idUTav).eq.0) THEN
              IF (Master) WRITE (out,280) 'idUTav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idUTav(itrc)
                Aout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Aout(idVTav)') THEN
            IF (MAXVAL(idVTav).eq.0) THEN
              IF (Master) WRITE (out,280) 'idVTav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=idVTav(itrc)
                Aout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Aout(iHUTav)') THEN
            IF (MAXVAL(iHUTav).eq.0) THEN
              IF (Master) WRITE (out,280) 'iHUTav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=iHUTav(itrc)
                Aout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Aout(iHVTav)') THEN
            IF (MAXVAL(iHVTav).eq.0) THEN
              IF (Master) WRITE (out,280) 'iHVTav'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, NAT*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                i=iHVTav(itrc)
                Aout(i,ng)=Ltracer(itrc,ng)
              END DO
            END DO
#  ifdef ICE_MODEL
          ELSE IF (TRIM(KeyWord).eq.'Aout(idUice)') THEN
            IF (idUice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idUice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idUice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idVice)') THEN
            IF (idVice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idVice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idVice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idAice)') THEN
            IF (idAice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idAice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idAice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idHice)') THEN
            IF (idHice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idHice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idHice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idHsno)') THEN
            IF (idHsno.eq.0) THEN
              IF (Master) WRITE (out,280) 'idHsno'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idHsno,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idTice)') THEN
            IF (idTice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idTice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idTice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idTimid)') THEN
            IF (idTimid.eq.0) THEN
              IF (Master) WRITE (out,280) 'idTimid'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idTimid,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idTauiw)') THEN
            IF (idTauiw.eq.0) THEN
              IF (Master) WRITE (out,280) 'idTauiw'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idTauiw,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idChuiw)') THEN
            IF (idChuiw.eq.0) THEN
              IF (Master) WRITE (out,280) 'idChuiw'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idChuiw,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idSfwat)') THEN
            IF (idSfwat.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSfwat'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idSfwat,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idAgeice)') THEN
            IF (idAgeice.eq.0) THEN
              IF (Master) WRITE (out,280) 'idAgeice'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idAgeice,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idIomflx)') THEN
            IF (idIomflx.eq.0) THEN
              IF (Master) WRITE (out,280) 'idIomflx'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idIomflx,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idSig11)') THEN
            IF (idSig11.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSig11'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idSig11,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idSig12)') THEN
            IF (idSig12.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSig12'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idSig12,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idSig22)') THEN
            IF (idSig22.eq.0) THEN
              IF (Master) WRITE (out,280) 'idSig22'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idSig22,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idT0mk)') THEN
            IF (idT0mk.eq.0) THEN
              IF (Master) WRITE (out,280) 'idT0mk'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idT0mk,:))
          ELSE IF (TRIM(KeyWord).eq.'Aout(idS0mk)') THEN
            IF (idS0mk.eq.0) THEN
              IF (Master) WRITE (out,280) 'idS0mk'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Aout(idS0mk,:))
#  endif
# endif
# if defined SOLVE3D && defined T_PASSIVE
          ELSE IF (TRIM(KeyWord).eq.'Aout(inert)') THEN
            Npts=load_l(Nval, Cval, NPT*Ngrids, Linert)
            DO ng=1,Ngrids
              DO i=1,NPT
                itrc=idTvar(inert(i))
                Aout(itrc,ng)=Linert(i,ng)
              END DO
            END DO
# endif
#endif
#ifdef DIAGNOSTICS_UV
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2rate)') THEN
            IF (M2rate.le.0) THEN
              IF (Master) WRITE (out,280) 'M2rate'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2rate),ng)=Ldiag(ng)
              Dout(idDv2d(M2rate),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2pgrd)') THEN
            IF (M2pgrd.le.0) THEN
              IF (Master) WRITE (out,280) 'M2pgrd'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2pgrd),ng)=Ldiag(ng)
              Dout(idDv2d(M2pgrd),ng)=Ldiag(ng)
            END DO
# ifdef UV_COR
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2fcor)') THEN
            IF (M2fcor.le.0) THEN
              IF (Master) WRITE (out,280) 'M2fcor'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2fcor),ng)=Ldiag(ng)
              Dout(idDv2d(M2fcor),ng)=Ldiag(ng)
            END DO
# endif
# ifdef UV_ADV
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2hadv)') THEN
            IF (M2hadv.le.0) THEN
              IF (Master) WRITE (out,280) 'M2hadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2hadv),ng)=Ldiag(ng)
              Dout(idDv2d(M2hadv),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2xadv)') THEN
            IF (M2xadv.le.0) THEN
              IF (Master) WRITE (out,280) 'M2xadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2xadv),ng)=Ldiag(ng)
              Dout(idDv2d(M2xadv),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2yadv)') THEN
            IF (M2yadv.le.0) THEN
              IF (Master) WRITE (out,280) 'M2yadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2yadv),ng)=Ldiag(ng)
              Dout(idDv2d(M2yadv),ng)=Ldiag(ng)
            END DO
# endif
# ifdef NEARSHORE_MELLOR
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2hrad)') THEN
            IF (M2hrad.le.0) THEN
              IF (Master) WRITE (out,280) 'M2hrad'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2hrad),ng)=Ldiag(ng)
              Dout(idDv2d(M2hrad),ng)=Ldiag(ng)
            END DO
# endif
# if defined UV_VIS2 || defined UV_VIS4
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2hvis)') THEN
            IF (M2hvis.le.0) THEN
              IF (Master) WRITE (out,280) 'M2hvis'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2hvis),ng)=Ldiag(ng)
              Dout(idDv2d(M2hvis),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2xvis)') THEN
            IF (M2xvis.le.0) THEN
              IF (Master) WRITE (out,280) 'M2xvis'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2xvis),ng)=Ldiag(ng)
              Dout(idDv2d(M2xvis),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2yvis)') THEN
            IF (M2yvis.le.0) THEN
              IF (Master) WRITE (out,280) 'M2yvis'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2yvis),ng)=Ldiag(ng)
              Dout(idDv2d(M2yvis),ng)=Ldiag(ng)
            END DO
# endif
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2sstr)') THEN
            IF (M2sstr.le.0) THEN
              IF (Master) WRITE (out,280) 'M2sstr'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2sstr),ng)=Ldiag(ng)
              Dout(idDv2d(M2sstr),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M2bstr)') THEN
            IF (M2bstr.le.0) THEN
              IF (Master) WRITE (out,280) 'M2bstr'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu2d(M2bstr),ng)=Ldiag(ng)
              Dout(idDv2d(M2bstr),ng)=Ldiag(ng)
            END DO
# ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3rate)') THEN
            IF (M3rate.le.0) THEN
              IF (Master) WRITE (out,280) 'M3rate'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3rate),ng)=Ldiag(ng)
              Dout(idDv3d(M3rate),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3pgrd)') THEN
            IF (M3pgrd.le.0) THEN
              IF (Master) WRITE (out,280) 'M3pgrd'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3pgrd),ng)=Ldiag(ng)
              Dout(idDv3d(M3pgrd),ng)=Ldiag(ng)
            END DO
#  ifdef UV_COR
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3fcor)') THEN
            IF (M3fcor.le.0) THEN
              IF (Master) WRITE (out,280) 'M3fcor'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3fcor),ng)=Ldiag(ng)
              Dout(idDv3d(M3fcor),ng)=Ldiag(ng)
            END DO
#  endif
#  ifdef UV_ADV
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3hadv)') THEN
            IF (M3hadv.le.0) THEN
              IF (Master) WRITE (out,280) 'M3hadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3hadv),ng)=Ldiag(ng)
              Dout(idDv3d(M3hadv),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3xadv)') THEN
            IF (M3xadv.le.0) THEN
              IF (Master) WRITE (out,280) 'M3xadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3xadv),ng)=Ldiag(ng)
              Dout(idDv3d(M3xadv),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3yadv)') THEN
            IF (M3yadv.le.0) THEN
              IF (Master) WRITE (out,280) 'M3yadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3yadv),ng)=Ldiag(ng)
              Dout(idDv3d(M3yadv),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3vadv)') THEN
            IF (M3vadv.le.0) THEN
              IF (Master) WRITE (out,280) 'M3vadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3vadv),ng)=Ldiag(ng)
              Dout(idDv3d(M3vadv),ng)=Ldiag(ng)
            END DO
#  endif
#  ifdef NEARSHORE_MELLOR
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3hrad)') THEN
            IF (M3hrad.le.0) THEN
              IF (Master) WRITE (out,280) 'M3hrad'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3hrad),ng)=Ldiag(ng)
              Dout(idDv3d(M3hrad),ng)=Ldiag(ng)
            END DO
#  endif
#  if defined UV_VIS2 || defined UV_VIS4
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3hvis)') THEN
            IF (M3hvis.le.0) THEN
              IF (Master) WRITE (out,280) 'M3hvis'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3hvis),ng)=Ldiag(ng)
              Dout(idDv3d(M3hvis),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3xvis)') THEN
            IF (M3xvis.le.0) THEN
              IF (Master) WRITE (out,280) 'M3xvis'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3xvis),ng)=Ldiag(ng)
              Dout(idDv3d(M3xvis),ng)=Ldiag(ng)
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3yvis)') THEN
            IF (M3yvis.le.0) THEN
              IF (Master) WRITE (out,280) 'M3yvis'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3yvis),ng)=Ldiag(ng)
              Dout(idDv3d(M3yvis),ng)=Ldiag(ng)
            END DO
#  endif
          ELSE IF (TRIM(KeyWord).eq.'Dout(M3vvis)') THEN
            IF (M3vvis.le.0) THEN
              IF (Master) WRITE (out,280) 'M3vvis'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, Ngrids, Ldiag)
            DO ng=1,Ngrids
              Dout(idDu3d(M3vvis),ng)=Ldiag(ng)
              Dout(idDv3d(M3vvis),ng)=Ldiag(ng)
            END DO
# endif
#endif
#if defined DIAGNOSTICS_TS && defined SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Dout(iTrate)') THEN
            IF (iTrate.le.0) THEN
              IF (Master) WRITE (out,280) 'iTrate'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iTrate),ng)=Ltracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iTrate),ng)=Ltracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(iThadv)') THEN
            IF (iThadv.le.0) THEN
              IF (Master) WRITE (out,280) 'iThadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iThadv),ng)=Ltracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iThadv),ng)=Ltracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(iTxadv)') THEN
            IF (iTxadv.le.0) THEN
              IF (Master) WRITE (out,280) 'iTxadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iTxadv),ng)=Ltracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iTxadv),ng)=Ltracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(iTyadv)') THEN
            IF (iTyadv.le.0) THEN
              IF (Master) WRITE (out,280) 'iTyadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iTyadv),ng)=Ltracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iTyadv),ng)=Ltracer(NAT+i,ng)
              END DO
# endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(iTvadv)') THEN
            IF (iTvadv.le.0) THEN
              IF (Master) WRITE (out,280) 'iTvadv'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iTvadv),ng)=Ltracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iTvadv),ng)=Ltracer(NAT+i,ng)
              END DO
# endif
            END DO
# if defined TS_DIF2 || defined TS_DIF4
          ELSE IF (TRIM(KeyWord).eq.'Dout(iThdif)') THEN
            IF (iThdif.le.0) THEN
              IF (Master) WRITE (out,280) 'iThdif'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iThdif),ng)=Ltracer(itrc,ng)
              END DO
#  ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iThdif),ng)=Ltracer(NAT+i,ng)
              END DO
#  endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(iTxdif)') THEN
            IF (iTxdif.le.0) THEN
              IF (Master) WRITE (out,280) 'iTxdif'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iTxdif),ng)=Ltracer(itrc,ng)
              END DO
#  ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iTxdif),ng)=Ltracer(NAT+i,ng)
              END DO
#  endif
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Dout(iTydif)') THEN
            IF (iTydif.le.0) THEN
              IF (Master) WRITE (out,280) 'iTydif'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iTydif),ng)=Ltracer(itrc,ng)
              END DO
#  ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iTydif),ng)=Ltracer(NAT+i,ng)
              END DO
#  endif
            END DO
#  if defined MIX_GEO_TS || defined MIX_ISO_TS
          ELSE IF (TRIM(KeyWord).eq.'Dout(iTsdif)') THEN
            IF (iTsdif.le.0) THEN
              IF (Master) WRITE (out,280) 'iTsdif'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iTsdif),ng)=Ltracer(itrc,ng)
              END DO
#   ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iTsdif),ng)=Ltracer(NAT+i,ng)
              END DO
#   endif
            END DO
#  endif
# endif
          ELSE IF (TRIM(KeyWord).eq.'Dout(iTvdif)') THEN
            IF (iTvdif.le.0) THEN
              IF (Master) WRITE (out,280) 'iTvdif'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, (NAT+NPT)*Ngrids, Ltracer)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Dout(idDtrc(itrc,iTvdif),ng)=Ltracer(itrc,ng)
              END DO
# ifdef T_PASSIVE
              DO i=1,NPT
                itrc=inert(i)
                Dout(idDtrc(itrc,iTvdif),ng)=Ltracer(NAT+i,ng)
              END DO
# endif
            END DO
#endif
          ELSE IF (TRIM(KeyWord).eq.'NUSER') THEN
            Npts=load_i(Nval, Rval, 1, Nuser)
          ELSE IF (TRIM(KeyWord).eq.'USER') THEN
            Npts=load_r(Nval, Rval, MAX(1,Nuser), user)
          ELSE IF (TRIM(KeyWord).eq.'NC_SHUFFLE') THEN
            Npts=load_i(Nval, Rval, 1, shuffle)
          ELSE IF (TRIM(KeyWord).eq.'NC_DEFLATE') THEN
            Npts=load_i(Nval, Rval, 1, deflate)
          ELSE IF (TRIM(KeyWord).eq.'NC_DLEVEL') THEN
            Npts=load_i(Nval, Rval, 1, deflate_level)
          ELSE IF (TRIM(KeyWord).eq.'GSTNAME') THEN
            label='GST - generalized stability theory analysis'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, GST)
          ELSE IF (TRIM(KeyWord).eq.'RSTNAME') THEN
            label='RST - restart fields'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, RST)
          ELSE IF (TRIM(KeyWord).eq.'HISNAME') THEN
            label='HIS - nonlinear model history fields'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, HIS)
          ELSE IF (TRIM(KeyWord).eq.'TLMNAME') THEN
            label='TLM - tangent linear model history fields'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, TLM)
          ELSE IF (TRIM(KeyWord).eq.'TLFNAME') THEN
            label='TLF - tangent linear model impulse forcing'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, TLF)
          ELSE IF (TRIM(KeyWord).eq.'ADJNAME') THEN
            label='ADM - adjoint model history fields'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, ADM)
          ELSE IF (TRIM(KeyWord).eq.'AVGNAME') THEN
            label='AVG - time-averaged history fields'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, AVG)
          ELSE IF (TRIM(KeyWord).eq.'AVG2NAME') THEN
            label='AVG2 - time-averaged history fields'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, AVG2)
          ELSE IF (TRIM(KeyWord).eq.'DIANAME') THEN
            label='DIA - time-averaged diagnostics fields'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, DIA)
          ELSE IF (TRIM(KeyWord).eq.'STANAME') THEN
            label='STA - stations time-series'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, STA)
          ELSE IF (TRIM(KeyWord).eq.'FLTNAME') THEN
            label='FLT - Lagragian particles trajectories'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, FLT)
          ELSE IF (TRIM(KeyWord).eq.'GRDNAME') THEN
            label='GRD - application grid'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, GRD)
          ELSE IF (TRIM(KeyWord).eq.'ININAME') THEN
            label='INI - nonlinear model initial conditions'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, INI)
          ELSE IF (TRIM(KeyWord).eq.'IRPNAME') THEN
            label='IRP - representer model initial conditions'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, IRP)
          ELSE IF (TRIM(KeyWord).eq.'ITLNAME') THEN
            label='ITL - tangent linear model initial conditions'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, ITL)
          ELSE IF (TRIM(KeyWord).eq.'IADNAME') THEN
            label='IAD - adjoint model initial conditions'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, IAD)
          ELSE IF (TRIM(KeyWord).eq.'NFFILES') THEN
            Npts=load_i(Nval, Rval, Ngrids, nFfiles)
            DO ng=1,Ngrids
              IF (nFfiles(ng).le.0) THEN
                IF (Master) WRITE (out,260) 'NFFILES', nFfiles(ng),     &
     &                            'Must be equal or greater than one.'
                exit_flag=4
                RETURN
              END IF
            END DO
            mFfiles=MAXVAL(nFfiles)
            allocate ( FRC(mFfiles,Ngrids) )
            allocate ( FRCids(mFfiles,Ngrids) )
            allocate ( Ncount(mFfiles,Ngrids) )
            FRCids(1:mFfiles,1:Ngrids)=-1
            Ncount(1:mFfiles,1:Ngrids)=0
          ELSE IF (TRIM(KeyWord).eq.'FRCNAME') THEN
            label='FRC - forcing fields'
            Npts=load_s2d(Nval, Cval, line, label, ifile, igrid,        &
     &                    Ncount, mFfiles, FRC)
          ELSE IF (TRIM(KeyWord).eq.'CLMNAME') THEN
            label='CLM - climatology fields'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, CLM)
          ELSE IF (TRIM(KeyWord).eq.'NBCFILES') THEN
            Npts=load_i(Nval, Rval, Ngrids, nBCfiles)
            DO ng=1,Ngrids
              IF (nBCfiles(ng).le.0) THEN
                IF (Master) WRITE (out,260) 'NBCFILES', nBCfiles(ng),   &
     &                            'Must be equal or greater than one.'
                exit_flag=4
                RETURN
              END IF
            END DO
            mFfiles=MAXVAL(nBCfiles)
            allocate ( BRY(mFfiles,Ngrids) )
            allocate ( BRYids(mFfiles,Ngrids) )
            allocate ( Ncount(mFfiles,Ngrids) )
            BRYids(1:mFfiles,1:Ngrids)=-1
            Ncount(1:mFfiles,1:Ngrids)=0
          ELSE IF (TRIM(KeyWord).eq.'BRYNAME') THEN
            label='BRY - lateral open boundary conditions'
            Npts=load_s2d(Nval, Cval, line, label, ifile, igrid,        &
     &                    Ncount, mFfiles, BRY)
          ELSE IF (TRIM(KeyWord).eq.'FWDNAME') THEN
            label='FWD - basic state forward trajectory'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, FWD)
          ELSE IF (TRIM(KeyWord).eq.'ADSNAME') THEN
            label='ADS - adjoint sensitivity functional'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, ADS)
          ELSE IF (TRIM(KeyWord).eq.'APARNAM') THEN
            DO i=1,LEN(aparnam)
              aparnam(i:i)=blank
            END DO
            aparnam=TRIM(ADJUSTL(Cval(Nval)))
          ELSE IF (TRIM(KeyWord).eq.'SPOSNAM') THEN
            DO i=1,LEN(sposnam)
              sposnam(i:i)=blank
            END DO
            sposnam=TRIM(ADJUSTL(Cval(Nval)))
          ELSE IF (TRIM(KeyWord).eq.'FPOSNAM') THEN
            DO i=1,LEN(fposnam)
              fposnam(i:i)=blank
            END DO
            fposnam=TRIM(ADJUSTL(Cval(Nval)))
          ELSE IF (TRIM(KeyWord).eq.'BPARNAM') THEN
            DO i=1,LEN(bparnam)
              bparnam(i:i)=blank
            END DO
            bparnam=TRIM(ADJUSTL(Cval(Nval)))
          ELSE IF (TRIM(KeyWord).eq.'IPARNAM') THEN
            DO i=1,LEN(iparnam)
              iparnam(i:i)=blank
            END DO
            iparnam=TRIM(ADJUSTL(Cval(Nval)))
          ELSE IF (TRIM(KeyWord).eq.'SPARNAM') THEN
            DO i=1,LEN(sparnam)
              sparnam(i:i)=blank
            END DO
            sparnam=TRIM(ADJUSTL(Cval(Nval)))
          ELSE IF (TRIM(KeyWord).eq.'USRNAME') THEN
            DO i=1,LEN(USRname)
              USRname(i:i)=blank
            END DO
            USRname=TRIM(ADJUSTL(Cval(Nval)))
          END IF
          IF (exit_flag.ne.NoError) RETURN
        END IF
      END DO
  10  IF (Master) WRITE (out,50) line
      exit_flag=4
      RETURN
  20  CLOSE (inp)

#if defined BULK_FLUXES && defined NL_BULK_FLUXES
!
!  Allocate and initialize BLK I/O structure with the same values as
!  HIS.
!
      DO ng=1,Ngrids
        Nfiles(ng)=MAX(1,HIS(ng)%Nfiles)
        allocate ( BLK(ng)%Nrec(Nfiles(ng)) )
        allocate ( BLK(ng)%time_min(Nfiles(ng)) )
        allocate ( BLK(ng)%time_max(Nfiles(ng)) )
        allocate ( BLK(ng)%Vid(NV) )
        allocate ( BLK(ng)%Tid(MT) )
        allocate ( BLK(ng)%files(Nfiles(ng)) )
        BLK(ng)%Nfiles=Nfiles(ng)
        BLK(ng)%Fcount=1
        BLK(ng)%Rindex=0
        BLK(ng)%ncid=-1
        BLK(ng)%Vid(1:NV)=-1
        BLK(ng)%Tid(1:MT)=-1
        BLK(ng)%Nrec(1:Nfiles(ng))=0
        BLK(ng)%time_min(1:Nfiles(ng))=0.0_r8
        BLK(ng)%time_max(1:Nfiles(ng))=0.0_r8
        BLK(ng)%label='BLK - nonlinear model bulk fluxes'
      END DO
!
!  Make sure that logical output switches are activated for wind
!  stress and surface active tracers fluxes when using fluxes from
!  the nonlinear model via (bulk_flux).
!
      DO ng=1,Ngrids
        Hout(idUsms,ng)=.TRUE.
        Hout(idVsms,ng)=.TRUE.
# ifdef SOLVE3D
        Hout(idTsur(itemp),ng)=.TRUE.
#  ifdef EMINUSP
        Hout(idEmPf,ng)=.TRUE.
#  endif
# endif
      END DO
#endif

#if defined FORCING_SV || defined SO_SEMI
!
!  Make sure that logical output switches are activated for the
!  Forcing Singular Vectors or Stochastic Optimals variables.
!
      DO ng=1,Ngrids
        IF (SCALARS(ng)%Fstate(isFsur)) Hout(idFsur,ng)=.TRUE.
# ifndef SOLVE3D
        IF (SCALARS(ng)%Fstate(isUbar)) Hout(idUbar,ng)=.TRUE.
        IF (SCALARS(ng)%Fstate(isVbar)) Hout(idVbar,ng)=.TRUE.
# else
        IF (SCALARS(ng)%Fstate(isUvel)) Hout(idUvel,ng)=.TRUE.
        IF (SCALARS(ng)%Fstate(isVvel)) Hout(idVvel,ng)=.TRUE.
        DO itrc=1,NT(ng)
          IF (SCALARS(ng)%Fstate(isTvar(itrc))) THEN
            Hout(idTvar(itrc),ng)=.TRUE.
          END IF
          IF (SCALARS(ng)%Fstate(isTsur(itrc))) THEN
            Hout(idTsur(itrc),ng)=.TRUE.
          END IF
        END DO
# endif
        IF (SCALARS(ng)%Fstate(isUstr)) Hout(idUsms,ng)=.TRUE.
        IF (SCALARS(ng)%Fstate(isVstr)) Hout(idVsms,ng)=.TRUE.
      END DO
#endif
!
!  Set switch to create NetCDF file.
!
      DO ng=1,Ngrids
#ifdef SOLVE3D
        DO i=1,NV
          IF (Hout(i,ng)) LdefHIS(ng)=.TRUE.
        END DO
#else
        IF (Hout(idFsur,ng).or.Hout(idUbar,ng).or.Hout(idVbar,ng)) THEN
          LdefHIS(ng)=.TRUE.
        END IF
#endif
#if defined IS4DVAR || defined WEAK_CONSTRAINT
!
!  If weak constraint, disallow recycling of the adjoint model.
!
        LcycleADJ(ng)=.FALSE.
#endif
#if defined AVERAGES_DETIDE && (defined SSH_TIDES || defined UV_TIDES)
!
!  If computing time-averaged detided fields, make sure the the regular
!  time-averaged switches are activated for such variables.
!
        IF (.not.Aout(idFsur,ng).and.Aout(idFsuD,ng)) THEN
          Aout(idFsur,ng)=.TRUE.
        END IF
        IF (.not.Aout(idUbar,ng).and.Aout(idu2dD,ng)) THEN
          Aout(idUbar,ng)=.TRUE.
        END IF
        IF (.not.Aout(idVbar,ng).and.Aout(idv2dD,ng)) THEN
          Aout(idVbar,ng)=.TRUE.
        END IF
# ifdef SOLVE3D
        IF (.not.Aout(idUvel,ng).and.Aout(idu3dD,ng)) THEN
          Aout(idUvel,ng)=.TRUE.
        END IF
        IF (.not.Aout(idVvel,ng).and.Aout(idv3dD,ng)) THEN
          Aout(idVvel,ng)=.TRUE.
        END IF
        DO itrc=1,NAT
          IF (.not.Aout(idTvar(itrc),ng).and.                           &
     &        Aout(idTrcD(itrc),ng)) THEN
            Aout(idTvar(itrc),ng)=.TRUE.
          END IF
        END DO
# endif
#endif
#if defined IS4DVAR
!
!  If strong constraint, write only final adjoint solution since only
!  we are estimating initial conditions.
!
        nADJ(ng)=ntimes(ng)
!
!  Insure that restart file is written only at the end.  In sequential
!  data assimilation the restart file is used as the first guess for
!  the next assimilation cycle.
!
        nRST(ng)=ntimes(ng)
#endif
#if defined FOUR_DVAR || defined IMPULSE
!
!  Set size of additonal dimension for error covariance normalization
!  and standard deviation factors.
!
# if defined CORRELATION || defined WEAK_CONSTRAINT
        IF (nADJ(ng).lt.ntimes(ng)) THEN
          NSA=2
        ELSE
          NSA=1
        END IF
# else
        NSA=1
# endif
#endif
#ifdef WEAK_CONSTRAINT
!
!  If weak constraint assimilation, set tangent linear number of
!  time-steps between writing of fields the same as the basic
!  state.  Disallow recycling.
!
        nTLM(ng)=nHIS(ng)
        LcycleTLM(ng)=.FALSE.
#endif
#if defined FOUR_DVAR
!
!  If variational data assimilation, disallow creation of multiple
!  output history files.  Otherwise, the forward basic state will
!  not processed correctly.
!
        ndefHIS(ng)=0
        ndefTLM(ng)=0
        ndefADJ(ng)=0
#endif
        IF (((nrrec(ng).eq.0).and.(nAVG(ng).gt.ntimes(ng))).or.         &
     &      (nAVG(ng).eq.0)) THEN
          LdefAVG(ng)=.FALSE.
        END IF
        IF (((nrrec(ng).eq.0).and.(nAVG2(ng).gt.ntimes(ng))).or.         &
     &      (nAVG2(ng).eq.0)) THEN
          LdefAVG2(ng)=.FALSE.
        END IF
        IF (((nrrec(ng).eq.0).and.(nDIA(ng).gt.ntimes(ng))).or.         &
     &      (nDIA(ng).eq.0)) THEN
          LdefDIA(ng)=.FALSE.
        END IF
        IF (((nrrec(ng).eq.0).and.(nFLT(ng).gt.ntimes(ng))).or.         &
     &      (nFLT(ng).eq.0)) THEN
          LdefFLT(ng)=.FALSE.
        END IF
        IF (((nrrec(ng).eq.0).and.(nHIS(ng).gt.ntimes(ng))).or.         &
     &      (nHIS(ng).eq.0)) THEN
          LdefHIS(ng)=.FALSE.
        END IF
        IF (((nrrec(ng).eq.0).and.(nRST(ng).gt.ntimes(ng))).or.         &
     &      (nRST(ng).eq.0)) THEN
          LdefRST(ng)=.FALSE.
        END  IF
        IF (((nrrec(ng).eq.0).and.(nSTA(ng).gt.ntimes(ng))).or.         &
     &      (nSTA(ng).eq.0)) THEN
          LdefSTA(ng)=.FALSE.
        END IF
      END DO
!
!-----------------------------------------------------------------------
!  Report input parameters.
!-----------------------------------------------------------------------
!
      IF (Lwrite) THEN
#ifdef DISTRIBUTE
        WRITE (out,60) TRIM(title), TRIM(my_os), TRIM(my_cpu),          &
     &                 TRIM(my_fort), TRIM(my_fc), TRIM(my_fflags),     &
     &                 TRIM(Iname), TRIM(svn_url), TRIM(svn_rev),       &
     &                 TRIM(Rdir), TRIM(Hdir), TRIM(Hfile), TRIM(Adir)
#else
        WRITE (out,60) TRIM(title), TRIM(my_os), TRIM(my_cpu),          &
     &                 TRIM(my_fort), TRIM(my_fc), TRIM(my_fflags),     &
     &                 TRIM(svn_url), TRIM(svn_rev), TRIM(Rdir),        &
     &                 TRIM(Hdir), TRIM(Hfile), TRIM(Adir)
#endif

        DO ng=1,Ngrids
!
!  Report grid size and domain decomposition.  Check for correct tile
!  decomposition.
!
#ifdef DISTRIBUTE
          WRITE (out,70) ng, Lm(ng), Mm(ng), N(ng), numnodes,           &
     &                   NtileI(ng), NtileJ(ng)
          IF ((NtileI(ng)*NtileJ(ng)).ne.numnodes) THEN
            WRITE (out,80) ng
            exit_flag=6
            RETURN
          END IF
#else
          WRITE (out,90) ng, Lm(ng), Mm(ng), N(ng), numthreads,         &
     &                   NtileI(ng), NtileJ(ng)
          IF (NtileI(ng)*NtileJ(ng).le.0) THEN
            WRITE (out,100) ng
            exit_flag=6
            RETURN
          END IF
          IF (MOD(NtileI(ng)*NtileJ(ng),numthreads).ne.0) THEN
            WRITE (out,100) ng
            exit_flag=6
            RETURN
          END IF
#endif
!
!  Report physical parameters.
!
          WRITE (out,110) ng
          WRITE (out,120) ntimes(ng), 'ntimes',                         &
     &          'Number of timesteps for 3-D equations.'
          WRITE (out,140) dt(ng), 'dt',                                 &
     &          'Timestep size (s) for 3-D equations.'
          WRITE (out,130) ndtfast(ng), 'ndtfast',                       &
     &          'Number of timesteps for 2-D equations between',        &
     &          'each 3D timestep.'
#ifdef AGE_DISTRIBUTION
          WRITE (out,140) dtau(ng), 'dtau',                             &
     &          'Age increment for age distribution function.'
#endif
          WRITE (out,120) ERstr, 'ERstr',                               &
     &          'Starting ensemble/perturbation run number.'
          WRITE (out,120) ERend, 'ERend',                               &
     &          'Ending ensemble/perturbation run number.'
#ifdef FOUR_DVAR
          WRITE (out,120) Nouter, 'Nouter',                             &
     &          'Maximun number of 4DVAR outer loop iterations.'
#endif
#if defined IS4DVAR           || defined IS4DVAR_SENSITIVITY || \
    defined SENSITIVITY_4DVAR || \
    defined TL_W4DPSAS        || defined TL_W4DVAR           || \
    defined W4DPSAS           || defined W4DVAR
          WRITE (out,120) Ninner, 'Ninner',                             &
     &          'Maximun number of 4DVAR inner loop iterations.'
#endif
#ifdef STOCHASTIC_OPT
          WRITE (out,120) Nintervals, 'Nintervals',                     &
     &          'Number of stochastic optimals timestep intervals.'
#endif
#ifdef PROPAGATOR
          WRITE (out,120) NEV, 'NEV',                                   &
     &          'Number of Lanczos/Arnoldi eigenvalues to compute.'
          WRITE (out,120) NCV, 'NCV',                                   &
     &          'Number of Lanczos/Arnoldi eigenvectors to compute.'
#endif
          WRITE (out,120) nrrec(ng), 'nrrec',                           &
     &          'Number of restart records to read from disk.'
          WRITE (out,170) LcycleRST(ng), 'LcycleRST',                   &
     &          'Switch to recycle time-records in restart file.'
          WRITE (out,130) nRST(ng), 'nRST',                             &
     &          'Number of timesteps between the writing of data',      &
     &          'into restart fields.'
          WRITE (out,130) ninfo(ng), 'ninfo',                           &
     &          'Number of timesteps between print of information',     &
     &          'to standard output.'
#ifdef STATIONS
          WRITE (out,130) nSTA(ng), 'nSTA',                             &
     &          'Number of timesteps between the writing of data',      &
     &          'the stations file.'
#endif
#ifdef FLOATS
          WRITE (out,130) nFLT(ng), 'nFLT',                             &
     &          'Number of timesteps between the writing of data',      &
     &          'into floats file.'
#endif
          WRITE (out,170) ldefout(ng), 'ldefout',                       &
     &          'Switch to create a new output NetCDF file(s).'
          WRITE (out,130) nHIS(ng), 'nHIS',                             &
     &          'Number of timesteps between the writing fields',       &
     &          'into history file.'
          IF (ndefHIS(ng).gt.0) THEN
            WRITE (out,130) ndefHIS(ng), 'ndefHIS',                     &
     &            'Number of timesteps between creation of new',        &
     &            'history files.'
          END IF
#if defined AVERAGES    || \
   (defined AD_AVERAGES && defined ADJOINT) || \
   (defined RP_AVERAGES && defined TL_IOMS) || \
   (defined TL_AVERAGES && defined TANGENT)
          WRITE (out,130) ntsAVG(ng), 'ntsAVG',                         &
     &          'Starting timestep for the accumulation of output',     &
     &          'time-averaged data.'
          WRITE (out,130) nAVG(ng), 'nAVG',                             &
     &          'Number of timesteps between the writing of',           &
     &          'time-averaged data into averages file.'
          IF (ndefAVG(ng).gt.0) THEN
            WRITE (out,130) ndefAVG(ng), 'ndefAVG',                     &
     &            'Number of timesteps between creation of new',        &
     &            'time-averaged file.'
          END IF
#endif
#ifdef AVERAGES2
          WRITE (out,130) ntsAVG2(ng), 'ntsAVG2',                         &
     &          'Starting timestep for the accumulation of output',     &
     &          'secondary time-averaged data.'
          WRITE (out,130) nAVG2(ng), 'nAVG2',                             &
     &          'Number of timesteps between the writing of',           &
     &          'secondary time-averaged data into averages file.'
          IF (ndefAVG2(ng).gt.0) THEN
            WRITE (out,130) ndefAVG2(ng), 'ndefAVG2',                     &
     &            'Number of timesteps between creation of new',        &
     &            'time-averaged file.'
          END IF
#endif
#ifdef DIAGNOSTICS
          WRITE (out,130) ntsDIA(ng), 'ntsDIA',                         &
     &          'Starting timestep for the accumulation of output',     &
     &          'time-averaged diagnostics data.'
          WRITE (out,130) nDIA(ng), 'nDIA',                             &
     &          'Number of timesteps between the writing of',           &
     &          'time-averaged data into diagnostics file.'
          IF (ndefDIA(ng).gt.0) THEN
            WRITE (out,130) ndefDIA(ng), 'ndefDIA',                     &
     &            'Number of timesteps between creation of new',        &
     &            'diagnostic file.'
          END IF
#endif
#ifdef TANGENT
          WRITE (out,170) LcycleTLM(ng), 'LcycleTLM',                   &
     &          'Switch to recycle time-records in tangent file.'
          WRITE (out,130) nTLM(ng), 'nTLM',                             &
     &          'Number of timesteps between the writing of',           &
     &          'data into tangent file.'
          IF (ndefTLM(ng).gt.0) THEN
            WRITE (out,130) ndefTLM(ng), 'ndefTLM',                     &
     &            'Number of timesteps between creation of new',        &
     &            'tangent file.'
          END IF
#endif
#ifdef ADJOINT
          WRITE (out,170) LcycleADJ(ng), 'LcycleADJ',                   &
     &          'Switch to recycle time-records in adjoint file.'
          WRITE (out,130) nADJ(ng), 'nADJ',                             &
     &          'Number of timesteps between the writing of',           &
     &          'data into adjoint file.'
          IF (ndefADJ(ng).gt.0) THEN
            WRITE (out,130) ndefADJ(ng), 'ndefADJ',                     &
     &            'Number of timesteps between creation of new',        &
     &            'adjoint file.'
          END IF
#endif
#ifdef ADJUST_BOUNDARY
          WRITE (out,130) nOBC(ng), 'nOBC',                             &
     &          'Number of timesteps between 4DVAR adjustment of',      &
     &          'open boundaries.'
#endif
#if defined ADJUST_STFLUX || defined ADJUST_WSTRESS
          WRITE (out,130) nSFF(ng), 'nSFF',                             &
     &          'Number of timesteps between 4DVAR adjustment of',      &
     &          'surface forcing fields.'
#endif
#ifdef PROPAGATOR
          WRITE (out,170) LmultiGST, 'LmultiGST',                       &
     &          'Switch to write one GST eigenvector per file.'
          WRITE (out,170) LrstGST, 'LrstGST',                           &
     &          'Switch to restart GST analysis.'
          WRITE (out,120) MaxIterGST, 'MaxIterGST',                     &
     &          'Maximum number of GST algorithm iterations.'
          WRITE (out,130) nGST, 'nGST',                                 &
     &          'Number of GST iterations between storing check',       &
     &          'pointing data into NetCDF file.'
          WRITE (out,210) Ritz_tol, 'Ritz_tol',                         &
     &          'Relative accuracy of Ritz values computed in the',     &
     &          'GST analysis.'
#endif
#ifdef SOLVE3D
# ifdef TS_DIF2
          DO i=1,NAT+NPT
            itrc=i
#  ifdef T_PASSIVE
            IF (i.gt.NAT) itrc=inert(i-NAT)
#  endif
            WRITE (out,190) nl_tnu2(itrc,ng), 'nl_tnu2', itrc,          &
     &            'NLM Horizontal, harmonic mixing coefficient',        &
     &            '(m2/s) for tracer ', itrc,                           &
     &            TRIM(Vname(1,idTvar(itrc)))
#  ifdef ADJOINT
            WRITE (out,190) ad_tnu2(itrc,ng), 'ad_tnu2', itrc,          &
     &            'ADM Horizontal, harmonic mixing coefficient',        &
     &            '(m2/s) for tracer ', itrc,                           &
     &            TRIM(Vname(1,idTvar(itrc)))
#  endif
#  if defined TANGENT || defined TL_IOMS
            WRITE (out,190) tl_tnu2(itrc,ng), 'tl_tnu2', itrc,          &
     &            'TLM Horizontal, harmonic mixing coefficient',        &
     &            '(m2/s) for tracer ', itrc,                           &
     &            TRIM(Vname(1,idTvar(itrc)))
#  endif
          END DO
# endif
# ifdef TS_DIF4
          DO i=1,NAT+NPT
            itrc=i
#  ifdef T_PASSIVE
            IF (i.gt.NAT) itrc=inert(i-NAT)
#  endif
            WRITE (out,190) nl_tnu4(itrc,ng), 'nl_tnu4', itrc,          &
     &            'NLM Horizontal, biharmonic mixing coefficient',      &
     &            '(m4/s) for tracer ', itrc,                           &
     &            TRIM(Vname(1,idTvar(itrc)))
#  ifdef ADJOINT
            WRITE (out,190) ad_tnu4(itrc,ng), 'ad_tnu4', itrc,          &
     &            'ADM Horizontal, biharmonic mixing coefficient',      &
     &            '(m4/s) for tracer ', itrc,                           &
     &            TRIM(Vname(1,idTvar(itrc)))
#  endif
#  if defined TANGENT || defined TL_IOMS
            WRITE (out,190) tl_tnu4(itrc,ng), 'tl_tnu4', itrc,          &
     &            'TLM Horizontal, biharmonic mixing coefficient',      &
     &            '(m4/s) for tracer ', itrc,                           &
     &            TRIM(Vname(1,idTvar(itrc)))
#  endif
          END DO
# endif
#endif
#ifdef UV_VIS2
          WRITE (out,210) nl_visc2(ng), 'nl_visc2',                     &
     &          'NLM Horizontal, harmonic mixing coefficient',          &
     &          '(m2/s) for momentum.'
# ifdef ADJOINT
          WRITE (out,210) ad_visc2(ng), 'ad_visc2',                     &
     &          'ADM Horizontal, harmonic mixing coefficient',          &
     &          '(m2/s) for momentum.'
# endif
# if defined TANGENT || defined TL_IOMS
          WRITE (out,210) tl_visc2(ng), 'tl_visc2',                     &
     &          'TLM Horizontal, harmonic mixing coefficient',          &
     &          '(m2/s) for momentum.'
# endif
#endif
#ifdef UV_VIS4
          WRITE (out,210) nl_visc4(ng), 'nl_visc4',                     &
     &          'NLM Horizontal, biharmonic mixing coefficient',        &
     &          '(m4/s) for momentum.'
# ifdef ADJOINT
          WRITE (out,210) ad_visc4(ng), 'ad_visc4',                     &
     &          'ADM Horizontal, biharmonic mixing coefficient',        &
     &          '(m4/s) for momentum.'
# endif
# if defined TANGENT || defined TL_IOMS
          WRITE (out,210) tl_visc4(ng), 'tl_visc4',                     &
     &          'TLM Horizontal, biharmonic mixing coefficient',        &
     &          '(m4/s) for momentum.'
# endif
#endif
#ifdef SOLVE3D
          DO i=1,NAT+NPT
            itrc=i
# ifdef T_PASSIVE
            IF (i.gt.NAT) itrc=inert(i-NAT)
# endif
            WRITE (out,190) Akt_bak(itrc,ng), 'Akt_bak', itrc,          &
     &            'Background vertical mixing coefficient (m2/s)',      &
     &            'for tracer ', itrc, TRIM(Vname(1,idTvar(itrc)))
          END DO
          WRITE (out,210) Akv_bak(ng), 'Akv_bak',                       &
     &          'Background vertical mixing coefficient (m2/s)',        &
     &          'for momentum.'
# if defined MY25_MIXING || defined GLS_MIXING
          WRITE (out,210) Akk_bak(ng), 'Akk_bak',                       &
     &          'Background vertical mixing coefficient (m2/s)',        &
     &          'for turbulent energy.'
          WRITE (out,210) Akp_bak(ng), 'Akp_bak',                       &
     &          'Background vertical mixing coefficient (m2/s)',        &
     &          'for turbulent generic statistical field.'
#  ifdef TKE_DIF2
          WRITE (out,210) tkenu2(ng), 'tkenu2',                         &
     &          'Horizontal, harmonic mixing coefficient (m2/s)',       &
     &          'for turbulent energy.'
#  endif
#  ifdef TKE_DIF4
          WRITE (out,210) tkenu4(ng), 'tkenu4',                         &
     &          'Horizontal, biharmonic mixing coefficient (m4/s)',     &
     &          'for turbulent energy.'
#  endif
# endif
# ifdef GLS_MIXING
          WRITE (out,140) gls_p(ng), 'gls_p',                           &
     &          'GLS stability exponent.'
          WRITE (out,140) gls_m(ng), 'gls_m',                           &
     &          'GLS turbulent kinetic energy exponent.'
          WRITE (out,140) gls_n(ng), 'gls_n',                           &
     &          'GLS turbulent length scale exponent.'
          WRITE (out,200) gls_Kmin(ng), 'gls_Kmin',                     &
     &          'GLS minimum value of turbulent kinetic energy.'
          WRITE (out,200) gls_Pmin(ng), 'gls_Pmin',                     &
     &          'GLS minimum value of dissipation.'
          WRITE (out,200) gls_cmu0(ng), 'gls_cmu0',                     &
     &          'GLS stability coefficient.'
          WRITE (out,200) gls_c1(ng), 'gls_c1',                         &
     &          'GLS shear production coefficient.'
          WRITE (out,200) gls_c2(ng), 'gls_c2',                         &
     &          'GLS dissipation coefficient.'
          WRITE (out,200) gls_c3m(ng), 'gls_c3m',                       &
     &          'GLS stable buoyancy production coefficient.'
          WRITE (out,200) gls_c3p(ng), 'gls_c3p',                       &
     &          'GLS unstable buoyancy production coefficient.'
          WRITE (out,200) gls_sigk(ng), 'gls_sigk',                     &
     &          'GLS constant Schmidt number for TKE.'
          WRITE (out,200) gls_sigp(ng), 'gls_sigp',                     &
     &          'GLS constant Schmidt number for PSI.'
          WRITE (out,140) charnok_alpha(ng), 'charnok_alpha',           &
     &          'Charnok factor for Zos calculation.'
          WRITE (out,140) zos_hsig_alpha(ng), 'zos_hsig_alpha',         &
     &          'Factor for Zos calculation using Hsig(Awave).'
          WRITE (out,140) sz_alpha(ng), 'sz_alpha',                     &
     &          'Factor for Wave dissipation surface tke flux .'
          WRITE (out,140) crgban_cw(ng), 'crgban_cw',                   &
     &          'Factor for Craig/Banner surface tke flux.'
# endif
# ifdef FORWARD_MIXING
          DO i=1,NAT+NPT
            itrc=i
#  ifdef T_PASSIVE
            IF (i.gt.NAT) itrc=inert(i-NAT)
#  endif
#  ifdef ADJOINT
            WRITE (out,190) ad_Akt_fac(itrc,ng), 'ad_Akt_fac', itrc,    &
     &            'ADM basic state vertical mixing scale factor',       &
     &            'for tracer ', itrc, TRIM(Vname(1,idTvar(itrc)))
#  endif
#  if defined TANGENT || defined TL_IOMS
            WRITE (out,190) tl_Akt_fac(itrc,ng), 'tl_Akt_fac', itrc,    &
     &            'TLM basic state vertical mixing scale factor',       &
     &            'for tracer ', itrc, TRIM(Vname(1,idTvar(itrc)))
#  endif
          END DO
#  ifdef ADJOINT
          WRITE (out,210) ad_Akv_fac(ng), 'ad_Akv_fac',                 &
     &          'ADM basic state vertical mixing scale factor',         &
     &          'for momentum.'
#  endif
#  if defined TANGENT || defined TL_IOMS
          WRITE (out,210) tl_Akv_fac(ng), 'tl_Akv_fac',                 &
     &          'TLM basic state vertical mixing scale factor',         &
     &          'for momentum.'
#  endif
# endif
#endif
          WRITE (out,200) rdrg(ng), 'rdrg',                             &
     &          'Linear bottom drag coefficient (m/s).'
          WRITE (out,200) rdrg2(ng), 'rdrg2',                           &
     &          'Quadratic bottom drag coefficient.'
          WRITE (out,200) Zob(ng), 'Zob',                               &
     &          'Bottom roughness (m).'
#ifdef BBL_MODEL
          IF (Zob(ng).le.0.0_r8) THEN
            WRITE (out,265) 'Zob = ', Zob(ng),                          &
     &            'It must be greater than zero when BBL is activated.'
            exit_flag=5
            RETURN
          END IF
#endif
#ifdef SOLVE3D
# ifdef GLS_MIXING
          WRITE (out,200) Zos(ng), 'Zos',                               &
     &          'Surface roughness (m).'
# endif
# ifdef BULK_FLUXES
          WRITE (out,200) blk_ZQ(ng), 'blk_ZQ',                         &
     &          'Height (m) of surface air humidity measurement.'
          IF (blk_ZQ(ng).le.0.0_r8) THEN
            WRITE (out,265) 'blk_ZQ = ', blk_ZQ(ng),                    &
     &            'It must be greater than zero.'
            exit_flag=5
            RETURN
          END IF
          WRITE (out,200) blk_ZT(ng), 'blk_ZT',                         &
     &          'Height (m) of surface air temperature measurement.'
          IF (blk_ZT(ng).le.0.0_r8) THEN
            WRITE (out,265) 'blk_ZT = ', blk_ZT(ng),                    &
     &            'It must be greater than zero.'
            exit_flag=5
            RETURN
          END IF
          WRITE (out,200) blk_ZW(ng), 'blk_ZW',                         &
     &          'Height (m) of surface winds measurement.'
          IF (blk_ZW(ng).le.0.0_r8) THEN
            WRITE (out,265) 'blk_ZW = ', blk_ZW(ng),                    &
     &            'It must be greater than zero.'
            exit_flag=5
            RETURN
          END IF
# endif
#endif
#if defined WET_DRY
          WRITE (out,200) Dcrit(ng), 'Dcrit',                           &
     &          'Minimum depth for wetting and drying (m).'
#endif
#ifdef SOLVE3D
# if defined LMD_SKPP || defined SOLAR_SOURCE
          WRITE (out,120) lmd_Jwt(ng), 'lmd_Jwt',                       &
     &          'Jerlov water type.'
          IF ((lmd_Jwt(ng).lt.1).or.(lmd_Jwt(ng).gt.5)) THEN
            WRITE (out,260) 'lmd_Jwt = ', lmd_Jwt(ng),                  &
     &            'It must between one and five.'
            exit_flag=5
            RETURN
          END IF
# endif
# ifdef BODYFORCE
          WRITE (out,130) levsfrc(ng), 'levsfrc',                       &
     &          'Deepest level to apply surface stress as a',           &
     &          'bodyforce.'
          IF ((levsfrc(ng).lt.1).or.(levsfrc(ng).gt.N(ng))) THEN
            WRITE (out,260) 'levsfrc = ', levsfrc(ng),                  &
     &            'Out of range surface bodyforce level.'
            exit_flag=5
            RETURN
          END IF
          WRITE (out,130) levbfrc(ng), 'levbfrc',                       &
     &          'Shallowest level to apply bottom stress as a',         &
     &          'bodyforce.'
          IF ((levbfrc(ng).lt.1).or.(levbfrc(ng).gt.N(ng))) THEN
            WRITE (out,260) 'levbfrc = ', levbfrc(ng),                  &
     &            'Out of range bottom bodyforce level.'
            exit_flag=5
            RETURN
          END IF
# endif
#endif
#ifdef SOLVE3D
          WRITE (out,120) Vtransform(ng), 'Vtransform',                 &
     &          'S-coordinate transformation equation.'
          WRITE (out,120) Vstretching(ng), 'Vstretching',               &
     &          'S-coordinate stretching function.'
          WRITE (out,200) theta_s(ng), 'theta_s',                       &
     &          'S-coordinate surface control parameter.'
          WRITE (out,200) theta_b(ng), 'theta_b',                       &
     &          'S-coordinate bottom  control parameter.'
          IF (Tcline(ng).gt.1.0E+5_r8) THEN
            WRITE (out,210) Tcline(ng), 'Tcline',                       &
     &            'S-coordinate surface/bottom layer width (m) used',   &
     &            'in vertical coordinate stretching.'
          ELSE
            WRITE (out,160) Tcline(ng), 'Tcline',                       &
     &            'S-coordinate surface/bottom layer width (m) used',   &
     &            'in vertical coordinate stretching.'
          END IF
#endif
          WRITE (out,140) rho0, 'rho0',                                 &
     &          'Mean density (kg/m3) for Boussinesq approximation.'
#if defined SOLVE3D && (defined FOUR_DVAR || defined PROPAGATOR)
          WRITE (out,200) bvf_bak, 'bvf_bak',                           &
     &          'Background Brunt-Vaisala frequency squared (1/s2).'
#endif
          WRITE (out,140) dstart, 'dstart',                             &
     &          'Time-stamp assigned to model initialization (days).'
#if defined SSH_TIDES || defined UV_TIDES || defined POT_TIDES
          WRITE (out,140) tide_start, 'tide_start',                     &
     &          'Reference time origin for tidal forcing (days).'
#endif
          WRITE (out,150) time_ref, 'time_ref',                         &
     &          'Reference time for units attribute (yyyymmdd.dd)'
#ifdef SOLVE3D
          DO i=1,NAT+NPT
            itrc=i
#  ifdef T_PASSIVE
            IF (i.gt.NAT) itrc=inert(i-NAT)
#  endif
            WRITE (out,190) Tnudg(itrc,ng), 'Tnudg', itrc,              &
     &            'Nudging/relaxation time scale (days)',               &
     &            'for tracer ', itrc, TRIM(Vname(1,idTvar(itrc)))
          END DO
# ifdef SCORRECTION
          IF (Tnudg(isalt,ng).le.0.0_r8) THEN
            WRITE (out,265) 'Tnudg(isalt) = ', Tnudg(isalt,ng),         &
     &            'Must be greater than zero for salt flux correction.'
            exit_flag=5
            RETURN
          END IF
# endif
#endif
          WRITE (out,210) Znudg(ng), 'Znudg',                           &
     &          'Nudging/relaxation time scale (days)',                 &
     &          'for free-surface.'
          WRITE (out,210) M2nudg(ng), 'M2nudg',                         &
     &          'Nudging/relaxation time scale (days)',                 &
     &          'for 2D momentum.'
#ifdef SOLVE3D
          WRITE (out,210) M3nudg(ng), 'M3nudg',                         &
     &          'Nudging/relaxation time scale (days)',                 &
     &          'for 3D momentum.'
#endif
          WRITE (out,210) obcfac(ng), 'obcfac',                         &
     &          'Factor between passive and active',                    &
     &          'open boundary conditions.'
#ifdef SOLVE3D
          WRITE (out,140) T0(ng), 'T0',                                 &
     &          'Background potential temperature (C) constant.'
          WRITE (out,140) S0(ng), 'S0',                                 &
     &          'Background salinity (PSU) constant.'
# ifndef NONLIN_EOS
          WRITE (out,160) R0(ng), 'R0',                                 &
     &          'Background density (kg/m3) used in linear Equation',   &
     &          'of State.'
# endif
# if !defined NONLIN_EOS || defined FOUR_DVAR || defined PROPAGATOR
          WRITE (out,200) Tcoef(ng), 'Tcoef',                           &
     &          'Thermal expansion coefficient (1/Celsius).'
          WRITE (out,200) Scoef(ng), 'Scoef',                           &
     &          'Saline contraction coefficient (1/PSU).'
# endif
#endif
          WRITE (out,160) gamma2(ng), 'gamma2',                         &
     &          'Slipperiness variable: free-slip (1.0) or ',           &
     &          '                     no-slip (-1.0).'
#if defined AD_SENSITIVITY   || defined IS4DVAR_SENSITIVITY || \
    defined OPT_OBSERVATIONS || defined SENSITIVITY_4DVAR   || \
    defined SO_SEMI
          WRITE (out,140) DstrS(ng), 'DstrS',                           &
     &          'Starting day for ADM sensitivity forcing.'
          WRITE (out,140) DendS(ng), 'DendS',                           &
     &          'Ending day for ADM sensitivity forcing.'
# ifdef SOLVE3D
          WRITE (out,120) KstrS(ng), 'KstrS',                           &
     &          'Deepest level whose ADM sensitivity is required.'
          IF ((KstrS(ng).lt.1).or.(KstrS(ng).gt.N(ng))) THEN
            WRITE (out,260) 'KstrS = ', KstrS(ng),                      &
     &            'Out of range ADM sensitivity starting level.'
            exit_flag=5
            RETURN
          END IF
          WRITE (out,120) KendS(ng), 'KendS',                           &
     &          'Shallowest level whose ADM sensitivity is required.'
          IF ((KendS(ng).lt.1).or.(KendS(ng).gt.N(ng))) THEN
            WRITE (out,260) 'KendS = ', KendS(ng),                      &
     &            'Out of range ADM sensitivity level.'
            exit_flag=5
            RETURN
          END IF
# endif
          IF (SCALARS(ng)%Lstate(isFsur))                               &
     &       WRITE (out,170) SCALARS(ng)%Lstate(isFsur),                &
     &       'Lstate(isFsur)',                                          &
     &       'Adjoint sensitivity on free-surface.'
          IF (SCALARS(ng)%Lstate(isUbar))                               &
     &       WRITE (out,170) SCALARS(ng)%Lstate(isUbar),                &
     &       'Lstate(isUbar)',                                          &
     &       'Adjoint sensitivity on 2D U-momentum component.'
          IF (SCALARS(ng)%Lstate(isVbar))                               &
     &       WRITE (out,170) SCALARS(ng)%Lstate(isVbar),                &
     &       'Lstate(isVbar)',                                          &
     &       'Adjoint sensitivity on 2D V-momentum component.'
# ifdef SOLVE3D
          IF (SCALARS(ng)%Lstate(isUvel))                               &
     &       WRITE (out,170) SCALARS(ng)%Lstate(isUvel),                &
     &       'Lstate(isUvel)',                                          &
     &       'Adjoint sensitivity on 3D U-momentum component.'
          IF (SCALARS(ng)%Lstate(isVvel))                               &
     &       WRITE (out,170) SCALARS(ng)%Lstate(isVvel),                &
     &       'Lstate(isVvel)',                                          &
     &       'Adjoint sensitivity on 3D V-momentum component.'
          DO itrc=1,NT(ng)
            IF (SCALARS(ng)%Lstate(isTvar(itrc)))                       &
     &         WRITE (out,180) SCALARS(ng)%Lstate(isTvar(itrc)),        &
     &         'Lstate(idTvar)',                                        &
     &         'Adjoint sensitivity on tracer ',                        &
     &         itrc, TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
#endif
#if defined FORCING_SV || defined SO_SEMI
          IF (SCALARS(ng)%Fstate(isFsur))                               &
     &       WRITE (out,170) SCALARS(ng)%Fstate(isFsur),                &
     &       'Fstate(isFsur)',                                          &
# ifdef FORCING_SV
     &       'Singular Forcing Vectors on free-surface.'
# else
     &       'Stochastic Optimals on free-surface.'
# endif
# ifdef SOLVE3D
          IF (SCALARS(ng)%Fstate(isUvel))                               &
     &       WRITE (out,170) SCALARS(ng)%Fstate(isUvel),                &
     &       'Fstate(isUvel)',                                          &
#  ifdef FORCING_SV
     &       'Singular Forcing Vectors on 3D U-momentum component.'
#  else
     &       'Stochastic Optimals on 3D U-momentum component.'
#  endif
          IF (SCALARS(ng)%Fstate(isVvel))                               &
     &       WRITE (out,170) SCALARS(ng)%Fstate(isVvel),                &
     &       'Fstate(isVvel)',                                          &
#  ifdef FORCING_SV
     &       'Singular Forcing Vectors on 3D V-momentum component.'
#  else
     &       'Stochastic Optimals on 3D V-momentum component.'
#  endif
          DO itrc=1,NT(ng)
            IF (SCALARS(ng)%Fstate(isTvar(itrc)))                       &
     &         WRITE (out,180) SCALARS(ng)%Fstate(isTvar(itrc)),        &
     &         'Fstate(idTVar)',                                        &
#  ifdef FORCING_SV
     &         'Singular Forcing Vectors on tracer',                    &
#  else
     &         'Stochastic Optimals on tracer',                         &
#  endif
     &         itrc, TRIM(Vname(1,idTvar(itrc)))
          END DO
# else
          IF (SCALARS(ng)%Fstate(isUbar))                               &
     &       WRITE (out,170) SCALARS(ng)%Fstate(isUbar),                &
     &       'Fstate(isUbar)',                                          &
#  ifdef FORCING_SV
     &       'Singular Forcing Vectors on 2D U-momentum component.'
#  else
     &       'Stochastic Optimals on 2D U-momentum component.'
#  endif
          IF (SCALARS(ng)%Fstate(isVbar))                               &
     &       WRITE (out,170) SCALARS(ng)%Fstate(isVbar),                &
     &       'Fstate(isVbar)',                                          &
#  ifdef FORCING_SV
     &       'Singular Forcing Vectors on 2D V-momentum component.'
#  else
     &       'Stochastic Optimals on 2D V-momentum component.'
#  endif
# endif
          IF (SCALARS(ng)%Fstate(isUstr))                               &
     &       WRITE (out,170) SCALARS(ng)%Fstate(isUstr),                &
     &       'Fstate(isUstr)',                                          &
# ifdef FORCING_SV
     &       'Singular Forcing Vectors on surface U-stress.'
# else
     &       'Stochastic Optimals on surface U-stress.'
# endif
          IF (SCALARS(ng)%Fstate(isVstr))                               &
     &       WRITE (out,170) SCALARS(ng)%Fstate(isVstr),                &
     &       'Fstate(isVstr)',                                          &
# ifdef FORCING_SV
     &       'Singular Forcing Vectors on surface V-stress.'
# else
     &       'Stochastic Optimals on surface V-stress.'
# endif
# ifdef SOLVE3D
          DO itrc=1,NT(ng)
            IF (SCALARS(ng)%Fstate(isTsur(itrc)))                       &
     &         WRITE (out,180) SCALARS(ng)%Fstate(isTsur(itrc)),        &
     &         'Fstate(idTsur)',                                        &
#  ifdef FORCING_SV
     &         'Singular Forcing Vectors on surface flux of tracer',    &
#  else
     &         'Stochastic Optimals on surface flux of tracer',         &
#  endif
     &         itrc, TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
#endif
#ifdef SO_SEMI
# ifndef SO_SEMI_WHITE
          WRITE (out,140) SO_decay(ng), 'SO_decay',                     &
     &          'Stochastic optimals time decorrelation scale (days).'
# endif
          IF (SCALARS(ng)%Fstate(isFsur))                               &
            WRITE (out,200) SO_sdev(isFsur,ng), 'SO_sdev(isFsur)',      &
     &          'Stochastic Optimals scale, free-surface'
# ifdef SOLVE3D
          IF (SCALARS(ng)%Fstate(isUvel))                               &
            WRITE (out,200) SO_sdev(isUvel,ng), 'SO_sdev(isUvel)',      &
     &          'Stochastic Optimals scale, 3D U-momentum'
          IF (SCALARS(ng)%Fstate(isVvel))                               &
            WRITE (out,200) SO_sdev(isVvel,ng), 'SO_sdev(isVvel)',      &
     &          'Stochastic Optimals scale, 3D V-momentum'
          DO itrc=1,NT(ng)
            IF (SCALARS(ng)%Fstate(isTvar(itrc)))                       &
     &         WRITE (out,195) SO_sdev(isTvar(itrc),ng),                &
     &         'SO_sdev(idTvar)',                                       &
     &         'Stochastic Optimals scale, tracer',                     &
     &         itrc, TRIM(Vname(1,idTvar(itrc)))
          END DO
# else
          IF (SCALARS(ng)%Fstate(isUbar))                               &
            WRITE (out,200) SO_sdev(isUbar,ng), 'SO_sdev(isUbar)',      &
     &          'Stochastic Optimals scale, 2D U-momentum'
          IF (SCALARS(ng)%Fstate(isVbar))                               &
            WRITE (out,200) SO_sdev(isVbar,ng), 'SO_sdev(isVbar)',      &
     &          'Stochastic Optimals scale, 2D V-momentum'
# endif
          IF (SCALARS(ng)%Fstate(isUstr))                               &
            WRITE (out,200) SO_sdev(isUstr,ng), 'SO_sdev(isUstr)',      &
     &          'Stochastic Optimals scale, surface U-stress'
          IF (SCALARS(ng)%Fstate(isVstr))                               &
            WRITE (out,200) SO_sdev(isVstr,ng), 'SO_sdev(isVstr)',      &
     &          'Stochastic Optimals scale, surface V-stress'
# ifdef SOLVE3D
          DO itrc=1,NT(ng)
            IF (SCALARS(ng)%Fstate(isTsur(itrc)))                       &
     &         WRITE (out,195) SO_sdev(isTsur(itrc),ng),                &
     &         'SO_sdev(idTsur)',                                       &
     &         'Stochastic Optimals scale, surface flux of tracer',     &
     &         itrc, TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
#endif
#if defined SOLVE3D && defined TS_PSOURCE
          DO itrc=1,NAT
            WRITE (out,185) LtracerSrc(itrc,ng), 'LtracerSrc', itrc,    &
     &            'Processing point sources/Sink on tracer ', itrc,     &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            WRITE (out,185) LtracerSrc(i,ng), 'LtracerSrc', itrc,       &
     &            'Processing point sources/Sink on tracer ', itrc,     &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
#endif
#if defined SEDIMENT && defined SED_MORPH
          IF (Hout(idBath,ng)) WRITE (out,170) Hout(idBath,ng),         &
     &       'Hout(idBath)',                                            &
     &       'Write out time-dependent bathymetry.'
#endif
          IF (Hout(idFsur,ng)) WRITE (out,170) Hout(idFsur,ng),         &
     &       'Hout(idFsur)',                                            &
     &       'Write out free-surface.'
          IF (Hout(idUbar,ng)) WRITE (out,170) Hout(idUbar,ng),         &
     &       'Hout(idUbar)',                                            &
     &       'Write out 2D U-momentum component.'
          IF (Hout(idVbar,ng)) WRITE (out,170) Hout(idVbar,ng),         &
     &       'Hout(idVbar)',                                            &
     &       'Write out 2D V-momentum component.'
#ifdef SOLVE3D
          IF (Hout(idUvel,ng)) WRITE (out,170) Hout(idUvel,ng),         &
     &       'Hout(idUvel)',                                            &
     &       'Write out 3D U-momentum component.'
          IF (Hout(idVvel,ng)) WRITE (out,170) Hout(idVvel,ng),         &
     &       'Hout(idVvel)',                                            &
     &       'Write out 3D V-momentum component.'
          IF (Hout(idWvel,ng)) WRITE (out,170) Hout(idWvel,ng),         &
     &       'Hout(idWvel)',                                            &
     &       'Write out W-momentum component.'
          IF (Hout(idOvel,ng)) WRITE (out,170) Hout(idOvel,ng),         &
     &       'Hout(idOvel)',                                            &
     &       'Write out omega vertical velocity.'
          DO itrc=1,NAT
            IF (Hout(idTvar(itrc),ng)) WRITE (out,180)                  &
     &          Hout(idTvar(itrc),ng), 'Hout(idTvar)',                  &
     &          'Write out tracer ', itrc, TRIM(Vname(1,idTvar(itrc)))
          END DO
#endif
#ifdef ICE_MODEL
          IF (Hout(idUice,ng)) WRITE (out,170) Hout(idUice,ng),         &
     &       'Hout(idUice)',                                            &
     &       'Write out U-component ice velocity.'
          IF (Hout(idVice,ng)) WRITE (out,170) Hout(idVice,ng),         &
     &       'Hout(idVice)',                                            &
     &       'Write out V-component ice velocity.'
          IF (Hout(idAice,ng)) WRITE (out,170) Hout(idAice,ng),         &
     &       'Hout(idAice)',                                            &
     &       'Write out ice concentration.'
          IF (Hout(idHice,ng)) WRITE (out,170) Hout(idHice,ng),         &
     &       'Hout(idHice)',                                            &
     &       'Write out average ice thickness.'
          IF (Hout(idHsno,ng)) WRITE (out,170) Hout(idHsno,ng),         &
     &       'Hout(idHsno)',                                            &
     &       'Write out snow thickness.'
          IF (Hout(idTice,ng)) WRITE (out,170) Hout(idTice,ng),         &
     &       'Hout(idTice)',                                            &
     &       'Write out ice/snow surface temperature.'
          IF (Hout(idTimid,ng)) WRITE (out,170) Hout(idTimid,ng),       &
     &       'Hout(idTimid)',                                           &
     &       'Write out interior ice temperature.'
          IF (Hout(idSfwat,ng)) WRITE (out,170) Hout(idSfwat,ng),       &
     &       'Hout(idSfwat)',                                           &
     &       'Write out surface water (on ice) thickness.'
          IF (Hout(idAgeice,ng)) WRITE (out,170) Hout(idAgeice,ng),     &
     &       'Hout(idAgeice)',                                          &
     &       'Write out ice age.'
          IF (Hout(idIomflx,ng)) WRITE (out,170) Hout(idIomflx,ng),     &
     &       'Hout(idIomflx)',                                          &
     &       'Write out ice-ocean mass flux'
          IF (Hout(idSig11,ng)) WRITE (out,170) Hout(idSig11,ng),       &
     &       'Hout(idSig11)',                                           &
     &       'Write out internal ice stress component 11.'
          IF (Hout(idSig12,ng)) WRITE (out,170) Hout(idSig12,ng),       &
     &       'Hout(idSig12)',                                           &
     &       'Write out internal ice stress component 12.'
          IF (Hout(idSig22,ng)) WRITE (out,170) Hout(idSig22,ng),       &
     &       'Hout(idSig22)',                                           &
     &       'Write out internal ice stress component 22.'
          IF (Hout(idTauiw,ng)) WRITE (out,170) Hout(idTauiw,ng),       &
     &       'Hout(idTauiw)',                                           &
     &       'Write out ice-water friction velocity.'
          IF (Hout(idChuiw,ng)) WRITE (out,170) Hout(idChuiw,ng),       &
     &       'Hout(idChuiw)',                                           &
     &       'Write out ice-water momentum transfer coefficient.'
          IF (Hout(idT0mk,ng)) WRITE (out,170) Hout(idT0mk,ng),         &
     &       'Hout(idT0mk)',                                            &
     &       'Write out temperature of molecular sublayer under ice.'
          IF (Hout(idS0mk,ng)) WRITE (out,170) Hout(idS0mk,ng),         &
     &       'Hout(idS0mk)',                                            &
     &       'Write out salinity of molecular sublayer under ice.'
          IF (Hout(idWfr,ng)) WRITE (out,170) Hout(idWfr,ng),           &
     &       'Hout(idWfr)',                                             &
     &       'Write out frazil ice growth rate.'
          IF (Hout(idWai,ng)) WRITE (out,170) Hout(idWai,ng),           &
     &       'Hout(idWai)',                                             &
     &       'Write out ice growth/melt rate.'
          IF (Hout(idWao,ng)) WRITE (out,170) Hout(idWao,ng),           &
     &       'Hout(idWao)',                                             &
     &       'Write out ice growth/melt rate.'
          IF (Hout(idWio,ng)) WRITE (out,170) Hout(idWio,ng),           &
     &       'Hout(idWio)',                                             &
     &       'Write out ice growth/melt rate.'
          IF (Hout(idWro,ng)) WRITE (out,170) Hout(idWro,ng),           &
     &       'Hout(idWro)',                                             &
     &       'Write out ice melt runoff rate.'
#endif
          IF (Hout(idUsms,ng)) WRITE (out,170) Hout(idUsms,ng),         &
     &       'Hout(idUsms)',                                            &
     &       'Write out surface U-momentum stress.'
          IF (Hout(idVsms,ng)) WRITE (out,170) Hout(idVsms,ng),         &
     &       'Hout(idVsms)',                                            &
     &       'Write out surface V-momentum stress.'
          IF (Hout(idUbms,ng)) WRITE (out,170) Hout(idUbms,ng),         &
     &       'Hout(idUbms)',                                            &
     &       'Write out bottom U-momentum stress.'
          IF (Hout(idVbms,ng)) WRITE (out,170) Hout(idVbms,ng),         &
     &       'Hout(idVbms)',                                            &
     &       'Write out bottom V-momentum stress.'
#ifdef BBL_MODEL
          IF (Hout(idUbrs,ng)) WRITE (out,170) Hout(idUbrs,ng),         &
     &       'Hout(idUbrs)',                                            &
     &       'Write out bottom U-current stress.'
          IF (Hout(idVbrs,ng)) WRITE (out,170) Hout(idVbrs,ng),         &
     &       'Hout(idVbrs)',                                            &
     &       'Write out bottom V-current stress.'
          IF (Hout(idUbws,ng)) WRITE (out,170) Hout(idUbws,ng),         &
     &       'Hout(idUbws)',                                            &
     &       'Write out wind-induced, bottom U-wave stress.'
          IF (Hout(idVbws,ng)) WRITE (out,170) Hout(idVbws,ng),         &
     &       'Hout(idVbws)',                                            &
     &       'Write out wind-induced, bottom V-wave stress.'
          IF (Hout(idUbcs,ng)) WRITE (out,170) Hout(idUbcs,ng),         &
     &       'Hout(idUbcs)',                                            &
     &       'Write out max wind + current, bottom U-wave stress.'
          IF (Hout(idVbcs,ng)) WRITE (out,170) Hout(idVbcs,ng),         &
     &       'Hout(idVbcs)',                                            &
     &       'Write out max wind + current, bottom V-wave stress.'
          IF (Hout(idUbot,ng)) WRITE (out,170) Hout(idUbot,ng),         &
     &       'Hout(idUbot)',                                            &
     &       'Write out bed wave orbital U-velocity.'
          IF (Hout(idVbot,ng)) WRITE (out,170) Hout(idVbot,ng),         &
     &       'Hout(idVbot)',                                            &
     &       'Write out bed wave orbital V-velocity.'
          IF (Hout(idUbur,ng)) WRITE (out,170) Hout(idUbur,ng),         &
     &       'Hout(idUbur)',                                            &
     &       'Write out bottom U-momentum above bed.'
          IF (Hout(idVbvr,ng)) WRITE (out,170) Hout(idVbvr,ng),         &
     &       'Hout(idVbvr)',                                            &
     &       'Write out bottom V-momentum above bed.'
#endif
#if defined NEARSHORE_MELLOR
          IF (Hout(idW2xx,ng)) WRITE (out,170) Hout(idW2xx,ng),         &
     &       'Hout(idW2xx)',                                            &
     &       'Write out 2D radiation stress, Sxx.'
          IF (Hout(idW2xy,ng)) WRITE (out,170) Hout(idW2xy,ng),         &
     &       'Hout(idW2xy)',                                            &
     &       'Write out 2D radiation stress, Sxy.'
          IF (Hout(idW2yy,ng)) WRITE (out,170) Hout(idW2yy,ng),         &
     &       'Hout(idW2yy)',                                            &
     &       'Write out 2D radiation stress, Syy.'
          IF (Hout(idU2rs,ng)) WRITE (out,170) Hout(idU2rs,ng),         &
     &       'Hout(idU2rs)',                                            &
     &       'Write out total 2D u-radiation stress.'
          IF (Hout(idV2rs,ng)) WRITE (out,170) Hout(idV2rs,ng),         &
     &       'Hout(idV2rs)',                                            &
     &       'Write out total 2D v-radiation stress.'
          IF (Hout(idU2Sd,ng)) WRITE (out,170) Hout(idU2Sd,ng),         &
     &       'Hout(idU2Sd)',                                            &
     &       'Write out 2D u-momentum stokes velocity.'
          IF (Hout(idV2Sd,ng)) WRITE (out,170) Hout(idV2Sd,ng),         &
     &       'Hout(idV2Sd)',                                            &
     &       'Write out 2D v-momentum stokes velocity.'
# ifdef SOLVE3D
          IF (Hout(idW3xx,ng)) WRITE (out,170) Hout(idW3xx,ng),         &
     &       'Hout(idW3xx)',                                            &
     &       'Write out 3D radiation stress, Sxx.'
          IF (Hout(idW3xy,ng)) WRITE (out,170) Hout(idW3xy,ng),         &
     &       'Hout(idW3xy)',                                            &
     &       'Write out 3D radiation stress, Sxy.'
          IF (Hout(idW3yy,ng)) WRITE (out,170) Hout(idW3yy,ng),         &
     &       'Hout(idW3yy)',                                            &
     &       'Write out 3D radiation stress, Syy.'
#  ifdef NEARSHORE_MELLOR05
          IF (Hout(idW3zx,ng)) WRITE (out,170) Hout(idW3zx,ng),         &
     &       'Hout(idW3zx)',                                            &
     &       'Write out 3D radiation stress, Szx.'
          IF (Hout(idW3zy,ng)) WRITE (out,170) Hout(idW3zy,ng),         &
     &       'Hout(idW3zy)',                                            &
     &       'Write out 3D radiation stress, Szy.'
#  endif
          IF (Hout(idU3rs,ng)) WRITE (out,170) Hout(idU3rs,ng),         &
     &       'Hout(idU3rs)',                                            &
     &       'Write out total 3D u-radiation stress.'
          IF (Hout(idV3rs,ng)) WRITE (out,170) Hout(idV3rs,ng),         &
     &       'Hout(idV3rs)',                                            &
     &       'Write out total 3D v-radiation stress.'
          IF (Hout(idU3Sd,ng)) WRITE (out,170) Hout(idU3Sd,ng),         &
     &       'Hout(idU3Sd)',                                            &
     &       'Write out 3D u-momentum stokes velocity.'
          IF (Hout(idV3Sd,ng)) WRITE (out,170) Hout(idV3Sd,ng),         &
     &       'Hout(idV3Sd)',                                            &
     &       'Write out 3D v-momentum stokes velocity.'
# endif
#endif
#ifdef WAVES_HEIGHT
          IF (Hout(idWamp,ng)) WRITE (out,170) Hout(idWamp,ng),         &
     &       'Hout(idWamp)',                                            &
     &       'Write out wave height.'
#endif
#ifdef WAVES_LENGTH
          IF (Hout(idWlen,ng)) WRITE (out,170) Hout(idWlen,ng),         &
     &       'Hout(idWlen)',                                            &
     &       'Write out wavelength.'
#endif
#ifdef WAVES_DIR
          IF (Hout(idWdir,ng)) WRITE (out,170) Hout(idWdir,ng),         &
     &       'Hout(idWdir)',                                            &
     &       'Write out wave direction.'
#endif
#ifdef WAVES_TOP_PERIOD
          IF (Hout(idWptp,ng)) WRITE (out,170) Hout(idWptp,ng),         &
     &       'Hout(idWptp)',                                            &
     &       'Write out wave surface period.'
#endif
#ifdef WAVES_BOT_PERIOD
          IF (Hout(idWpbt,ng)) WRITE (out,170) Hout(idWpbt,ng),         &
     &       'Hout(idWpbt)',                                            &
     &       'Write out wave bottom period.'
#endif
#ifdef WAVES_UB
          IF (Hout(idWorb,ng)) WRITE (out,170) Hout(idWorb,ng),         &
     &       'Hout(idWorb)',                                            &
     &       'Write out wave bottom orbital velocity.'
#endif
#if defined TKE_WAVEDISS || defined WAVES_OCEAN
          IF (Hout(idWdis,ng)) WRITE (out,170) Hout(idWdis,ng),         &
     &       'Hout(idWdis)',                                            &
     &       'Write out wave dissipation.'
#endif
#if defined SOLVE3D && defined T_PASSIVE
          DO itrc=1,NPT
            IF (Hout(idTvar(inert(itrc)),ng)) WRITE (out,180)           &
     &          Hout(idTvar(inert(itrc)),ng), 'Hout(inert)',            &
     &          'Write out inert passive tracer ', itrc,                &
     &          TRIM(Vname(1,idTvar(inert(itrc))))
          END DO
#endif
#if defined SOLVE3D && (defined BBL_MODEL || defined SEDIMENT)
          DO itrc=1,MBOTP
            IF (Hout(idBott(itrc),ng)) WRITE (out,180)                  &
     &          Hout(idBott(itrc),ng), 'Hout(idBott)',                  &
     &          'Write out bottom property ', itrc,                     &
     &          TRIM(Vname(1,idBott(itrc)))
          END DO
#endif
#ifdef SOLVE3D
# if defined BULK_FLUXES || defined ECOSIM || defined ATM_PRESS
          IF (Hout(idPair,ng)) WRITE (out,170) Hout(idPair,ng),         &
     &       'Hout(idPair)',                                            &
     &       'Write out surface air pressure.'
# endif
# if defined BULK_FLUXES || defined ECOSIM
          IF (Hout(idUair,ng)) WRITE (out,170) Hout(idUair,ng),         &
     &       'Hout(idUair)',                                            &
     &       'Write out surface U-wind component.'
          IF (Hout(idVair,ng)) WRITE (out,170) Hout(idVair,ng),         &
     &       'Hout(idVair)',                                            &
     &       'Write out surface V-wind component.'
# endif
          IF (Hout(idTsur(itemp),ng)) WRITE (out,170)                   &
     &        Hout(idTsur(itemp),ng), 'Hout(idTsur)',                   &
     &       'Write out surface net heat flux.'
          IF (Hout(idTsur(isalt),ng)) WRITE (out,170)                   &
     &        Hout(idTsur(isalt),ng), 'Hout(idTsur)',                   &
     &       'Write out surface net salt flux.'
# ifdef SHORTWAVE
          IF (Hout(idSrad,ng)) WRITE (out,170) Hout(idSrad,ng),         &
     &       'Hout(idSrad)',                                            &
     &       'Write out shortwave radiation flux.'
# endif
          IF (Hout(idSSSf,ng)) WRITE (out,170) Hout(idSSSf,ng),         &
     &       'Hout(idSSSf)',                                            &
     &       'Write out sea surface salinity correction flux.'
# ifdef BULK_FLUXES
          IF (Hout(idLrad,ng)) WRITE (out,170) Hout(idLrad,ng),         &
     &       'Hout(idLrad)',                                            &
     &       'Write out longwave radiation flux.'
          IF (Hout(idLhea,ng)) WRITE (out,170) Hout(idLhea,ng),         &
     &       'Hout(idLhea)',                                            &
     &       'Write out latent heat flux.'
          IF (Hout(idShea,ng)) WRITE (out,170) Hout(idShea,ng),         &
     &       'Hout(idShea)',                                            &
     &       'Write out sensible heat flux.'
#  ifdef EMINUSP
          IF (Hout(idEmPf,ng)) WRITE (out,170) Hout(idEmPf,ng),         &
     &       'Hout(idEmPf)',                                            &
     &       'Write out E-P flux.'
          IF (Hout(idevap,ng)) WRITE (out,170) Hout(idevap,ng),         &
     &       'Hout(idevap)',                                            &
     &       'Write out evaporation rate.'
          IF (Hout(idrain,ng)) WRITE (out,170) Hout(idrain,ng),         &
     &       'Hout(idrain)',                                            &
     &       'Write out rain rate.'
#  endif
# endif
          IF (Hout(idDano,ng)) WRITE (out,170) Hout(idDano,ng),         &
     &       'Hout(idDano)',                                            &
     &       'Write out density anomaly.'
          IF (Hout(idVvis,ng)) WRITE (out,170) Hout(idVvis,ng),         &
     &       'Hout(idVvis)',                                            &
     &       'Write out vertical viscosity: AKv.'
          IF (Hout(idTdif,ng)) WRITE (out,170) Hout(idTdif,ng),         &
     &       'Hout(idTdif)',                                            &
     &       'Write out vertical diffusion: AKt(itemp).'
          IF (Hout(idSdif,ng)) WRITE (out,170) Hout(idSdif,ng),         &
     &       'Hout(idSdif)',                                            &
     &       'Write out vertical diffusion: AKt(isalt).'
# ifdef LMD_SKPP
          IF (Hout(idHsbl,ng)) WRITE (out,170) Hout(idHsbl,ng),         &
     &       'Hout(idHsbl)',                                            &
     &       'Write out depth of surface boundary layer.'
# endif
# ifdef LMD_BKPP
          IF (Hout(idHbbl,ng)) WRITE (out,170) Hout(idHbbl,ng),         &
     &       'Hout(idHbbl)',                                            &
     &       'Write out depth of bottom boundary layer.'
# endif
# if defined GLS_MIXING || defined MY25_MIXING
          IF (Hout(idMtke,ng)) WRITE (out,170) Hout(idMtke,ng),         &
     &       'Hout(idMtke)',                                            &
     &       'Write out turbulent kinetic energy.'
          IF (Hout(idMtls,ng)) WRITE (out,170) Hout(idMtls,ng),         &
     &       'Hout(idMtls)',                                            &
     &       'Write out turbulent generic length-scale.'
# endif
#endif
#if defined SEDIMENT && defined SED_MORPH
          IF (Aout2(idBath,ng)) WRITE (out,170) Aout2(idBath,ng),       &
     &       'Aout2(idBath)',                                           &
     &       'Write out time-dependent bathymetry.'
#endif
          IF (Aout2(idFsur,ng)) WRITE (out,170) Aout2(idFsur,ng),       &
     &       'Aout2(idFsur)',                                           &
     &       'Write out free-surface.'
          IF (Aout2(idUbar,ng)) WRITE (out,170) Aout2(idUbar,ng),       &
     &       'Aout2(idUbar)',                                           &
     &       'Write out 2D U-momentum component.'
          IF (Aout2(idVbar,ng)) WRITE (out,170) Aout2(idVbar,ng),       &
     &       'Aout2(idVbar)',                                           &
     &       'Write out 2D V-momentum component.'
#ifdef SOLVE3D
          IF (Aout2(idUvel,ng)) WRITE (out,170) Aout2(idUvel,ng),       &
     &       'Aout2(idUvel)',                                           &
     &       'Write out 3D U-momentum component.'
          IF (Aout2(idVvel,ng)) WRITE (out,170) Aout2(idVvel,ng),       &
     &       'Aout2(idVvel)',                                           &
     &       'Write out 3D V-momentum component.'
          IF (Aout2(idWvel,ng)) WRITE (out,170) Aout2(idWvel,ng),       &
     &       'Aout2(idWvel)',                                           &
     &       'Write out W-momentum component.'
          IF (Aout2(idOvel,ng)) WRITE (out,170) Aout2(idOvel,ng),       &
     &       'Aout2(idOvel)',                                           &
     &       'Write out omega vertical velocity.'
          DO itrc=1,NAT
            IF (Aout2(idTvar(itrc),ng)) WRITE (out,180)                 &
     &          Aout2(idTvar(itrc),ng), 'Aout2(idTvar)',                &
     &          'Write out tracer ', itrc, TRIM(Vname(1,idTvar(itrc)))
          END DO
#endif
#ifdef ICE_MODEL
          IF (Aout2(idUice,ng)) WRITE (out,170) Aout2(idUice,ng),       &
     &       'Aout2(idUice)',                                           &
     &       'Write out U-component ice velocity.'
          IF (Aout2(idVice,ng)) WRITE (out,170) Aout2(idVice,ng),       &
     &       'Aout2(idVice)',                                           &
     &       'Write out V-component ice velocity.'
          IF (Aout2(idAice,ng)) WRITE (out,170) Aout2(idAice,ng),       &
     &       'Aout2(idAice)',                                           &
     &       'Write out ice concentration.'
          IF (Aout2(idHice,ng)) WRITE (out,170) Aout2(idHice,ng),       &
     &       'Aout2(idHice)',                                           &
     &       'Write out average ice thickness.'
          IF (Aout2(idHsno,ng)) WRITE (out,170) Aout2(idHsno,ng),       &
     &       'Aout2(idHsno)',                                           &
     &       'Write out snow thickness.'
          IF (Aout2(idTice,ng)) WRITE (out,170) Aout2(idTice,ng),       &
     &       'Aout2(idTice)',                                           &
     &       'Write out ice/snow surface temperature.'
          IF (Aout2(idTimid,ng)) WRITE (out,170) Aout2(idTimid,ng),     &
     &       'Aout2(idTimid)',                                          &
     &       'Write out interior ice temperature.'
          IF (Aout2(idSfwat,ng)) WRITE (out,170) Aout2(idSfwat,ng),     &
     &       'Aout2(idSfwat)',                                          &
     &       'Write out surface water (on ice) thickness.'
          IF (Aout2(idAgeice,ng)) WRITE (out,170) Aout2(idAgeice,ng),   &
     &       'Aout2(idAgeice)',                                         &
     &       'Write out ice age.'
          IF (Aout2(idIomflx,ng)) WRITE (out,170) Aout2(idIomflx,ng),   &
     &       'Aout2(idIomflx)',                                         &
     &       'Write out ice-ocean mass flux'
          IF (Aout2(idSig11,ng)) WRITE (out,170) Aout2(idSig11,ng),     &
     &       'Aout2(idSig11)',                                          &
     &       'Write out internal ice stress component 11.'
          IF (Aout2(idSig12,ng)) WRITE (out,170) Aout2(idSig12,ng),     &
     &       'Aout2(idSig12)',                                          &
     &       'Write out internal ice stress component 12.'
          IF (Aout2(idSig22,ng)) WRITE (out,170) Aout2(idSig22,ng),     &
     &       'Aout2(idSig22)',                                          &
     &       'Write out internal ice stress component 22.'
          IF (Aout2(idTauiw,ng)) WRITE (out,170) Aout2(idTauiw,ng),     &
     &       'Aout2(idTauiw)',                                          &
     &       'Write out ice-water friction velocity.'
          IF (Aout2(idChuiw,ng)) WRITE (out,170) Aout2(idChuiw,ng),     &
     &       'Aout2(idChuiw)',                                          &
     &       'Write out ice-water momentum transfer coefficient.'
          IF (Aout2(idT0mk,ng)) WRITE (out,170) Aout2(idT0mk,ng),       &
     &       'Aout2(idT0mk)',                                           &
     &       'Write out temperature of molecular sublayer under ice.'
          IF (Aout2(idS0mk,ng)) WRITE (out,170) Aout2(idS0mk,ng),       &
     &       'Aout2(idS0mk)',                                           &
     &       'Write out salinity of molecular sublayer under ice.'
#endif
          IF (Aout2(idUair,ng)) WRITE (out,170) Aout2(idUair,ng),       &
     &       'Aout2(idUair)',                                           &
     &       'Write out surface U-winds.'
          IF (Aout2(idVair,ng)) WRITE (out,170) Aout2(idVair,ng),       &
     &       'Aout2(idVair)',                                           &
     &       'Write out surface V-winds.'
          IF (Aout2(idUsms,ng)) WRITE (out,170) Aout2(idUsms,ng),       &
     &       'Aout2(idUsms)',                                           &
     &       'Write out surface U-momentum stress.'
          IF (Aout2(idVsms,ng)) WRITE (out,170) Aout2(idVsms,ng),       &
     &       'Aout2(idVsms)',                                           &
     &       'Write out surface V-momentum stress.'
          IF (Aout2(idUbms,ng)) WRITE (out,170) Aout2(idUbms,ng),       &
     &       'Aout2(idUbms)',                                           &
     &       'Write out bottom U-momentum stress.'
          IF (Aout2(idVbms,ng)) WRITE (out,170) Aout2(idVbms,ng),       &
     &       'Aout2(idVbms)',                                           &
     &       'Write out bottom V-momentum stress.'
#ifdef BBL_MODEL
          IF (Aout2(idUbrs,ng)) WRITE (out,170) Aout2(idUbrs,ng),       &
     &       'Aout2(idUbrs)',                                           &
     &       'Write out bottom U-current stress.'
          IF (Aout2(idVbrs,ng)) WRITE (out,170) Aout2(idVbrs,ng),       &
     &       'Aout2(idVbrs)',                                           &
     &       'Write out bottom V-current stress.'
          IF (Aout2(idUbws,ng)) WRITE (out,170) Aout2(idUbws,ng),       &
     &       'Aout2(idUbws)',                                           &
     &       'Write out wind-induced, bottom U-wave stress.'
          IF (Aout2(idVbws,ng)) WRITE (out,170) Aout2(idVbws,ng),       &
     &       'Aout2(idVbws)',                                           &
     &       'Write out wind-induced, bottom V-wave stress.'
          IF (Aout2(idUbcs,ng)) WRITE (out,170) Aout2(idUbcs,ng),       &
     &       'Aout2(idUbcs)',                                           &
     &       'Write out max wind + current, bottom U-wave stress.'
          IF (Aout2(idVbcs,ng)) WRITE (out,170) Aout2(idVbcs,ng),       &
     &       'Aout2(idVbcs)',                                           &
     &       'Write out max wind + current, bottom V-wave stress.'
          IF (Aout2(idUbot,ng)) WRITE (out,170) Aout2(idUbot,ng),       &
     &       'Aout2(idUbot)',                                           &
     &       'Write out bed wave orbital U-velocity.'
          IF (Aout2(idVbot,ng)) WRITE (out,170) Aout2(idVbot,ng),       &
     &       'Aout2(idVbot)',                                           &
     &       'Write out bed wave orbital V-velocity.'
          IF (Aout2(idUbur,ng)) WRITE (out,170) Aout2(idUbur,ng),       &
     &       'Aout2(idUbur)',                                           &
     &       'Write out bottom U-momentum above bed.'
          IF (Aout2(idVbvr,ng)) WRITE (out,170) Aout2(idVbvr,ng),       &
     &       'Aout2(idVbvr)',                                           &
     &       'Write out bottom V-momentum above bed.'
#endif
#if defined NEARSHORE_MELLOR
          IF (Aout2(idW2xx,ng)) WRITE (out,170) Aout2(idW2xx,ng),       &
     &       'Aout2(idW2xx)',                                           &
     &       'Write out 2D radiation stress, Sxx.'
          IF (Aout2(idW2xy,ng)) WRITE (out,170) Aout2(idW2xy,ng),       &
     &       'Aout2(idW2xy)',                                           &
     &       'Write out 2D radiation stress, Sxy.'
          IF (Aout2(idW2yy,ng)) WRITE (out,170) Aout2(idW2yy,ng),       &
     &       'Aout2(idW2yy)',                                           &
     &       'Write out 2D radiation stress, Syy.'
          IF (Aout2(idU2rs,ng)) WRITE (out,170) Aout2(idU2rs,ng),       &
     &       'Aout2(idU2rs)',                                           &
     &       'Write out total 2D u-radiation stress.'
          IF (Aout2(idV2rs,ng)) WRITE (out,170) Aout2(idV2rs,ng),       &
     &       'Aout2(idV2rs)',                                           &
     &       'Write out total 2D v-radiation stress.'
          IF (Aout2(idU2Sd,ng)) WRITE (out,170) Aout2(idU2Sd,ng),       &
     &       'Aout2(idU2Sd)',                                           &
     &       'Write out 2D u-momentum stokes velocity.'
          IF (Aout2(idV2Sd,ng)) WRITE (out,170) Aout2(idV2Sd,ng),       &
     &       'Aout2(idV2Sd)',                                           &
     &       'Write out 2D v-momentum stokes velocity.'
# ifdef SOLVE3D
          IF (Aout2(idW3xx,ng)) WRITE (out,170) Aout2(idW3xx,ng),       &
     &       'Aout2(idW3xx)',                                           &
     &       'Write out 3D horizonrtal radiation stress, Sxx.'
          IF (Aout2(idW3xy,ng)) WRITE (out,170) Aout2(idW3xy,ng),       &
     &       'Aout2(idW3xy)',                                           &
     &       'Write out 3D horizonrtal radiation stress, Sxy.'
          IF (Aout2(idW3yy,ng)) WRITE (out,170) Aout2(idW3yy,ng),       &
     &       'Aout2(idW3yy)',                                           &
     &       'Write out 3D horizonrtal radiation stress, Syy.'
          IF (Aout2(idW3zx,ng)) WRITE (out,170) Aout2(idW3zx,ng),       &
     &       'Aout2(idW3zx)',                                           &
     &       'Write out 3D vertical radiation stress, Szx.'
          IF (Aout2(idW3zy,ng)) WRITE (out,170) Aout2(idW3zy,ng),       &
     &       'Aout2(idW3zy)',                                           &
     &       'Write out 3D vertical radiation stress, Szy.'
          IF (Aout2(idU3rs,ng)) WRITE (out,170) Aout2(idU3rs,ng),       &
     &       'Aout2(idU3rs)',                                           &
     &       'Write out total 3D u-radiation stress.'
          IF (Aout2(idV3rs,ng)) WRITE (out,170) Aout2(idV3rs,ng),       &
     &       'Aout2(idV3rs)',                                           &
     &       'Write out total 3D v-radiation stress.'
          IF (Aout2(idU3Sd,ng)) WRITE (out,170) Aout2(idU3Sd,ng),       &
     &       'Aout2(idU3Sd)',                                           &
     &       'Write out 3D u-momentum stokes velocity.'
          IF (Aout2(idV3Sd,ng)) WRITE (out,170) Aout2(idV3Sd,ng),       &
     &       'Aout2(idV3Sd)',                                           &
     &       'Write out 3D v-momentum stokes velocity.'
# endif
#endif
          IF (Aout2(idWamp,ng)) WRITE (out,170) Aout2(idWamp,ng),       &
     &       'Aout2(idWamp)',                                           &
     &       'Write out wave height.'
          IF (Aout2(idWlen,ng)) WRITE (out,170) Aout2(idWlen,ng),       &
     &       'Aout2(idWlen)',                                           &
     &       'Write out wave length.'
          IF (Aout2(idWdir,ng)) WRITE (out,170) Aout2(idWdir,ng),       &
     &       'Aout2(idWdir)',                                           &
     &       'Write out wave direction.'
#if defined SOLVE3D && defined T_PASSIVE
          DO itrc=1,NPT
            IF (Aout2(idTvar(inert(itrc)),ng)) WRITE (out,180)          &
     &          Aout2(idTvar(inert(itrc)),ng), 'Aout2(inert)',          &
     &          'Write out inert passive tracer ', itrc,                &
     &          TRIM(Vname(1,idTvar(inert(itrc))))
          END DO
#endif
#if defined SEDIMENT && defined BEDLOAD
          DO itrc=1,NST
            IF (Aout2(idUbld(itrc),ng)) WRITE (out,180)                 &
     &          Aout2(idUbld(itrc),ng), 'Aout2(idUbld)',                &
     &          'Write out bed load u-direction ', itrc,                &
     &          TRIM(Vname(1,idUbld(itrc)))
            IF (Aout2(idVbld(itrc),ng)) WRITE (out,180)                 &
     &          Aout2(idVbld(itrc),ng), 'Aout2(idVbld)',                &
     &          'Write out bed load v-direction ', itrc,                &
     &          TRIM(Vname(1,idVbld(itrc)))
          END DO
#endif
#if defined SOLVE3D && (defined BBL_MODEL || defined SEDIMENT)
          DO itrc=1,MBOTP
            IF (Aout2(idBott(itrc),ng)) WRITE (out,180)                 &
     &          Aout2(idBott(itrc),ng), 'Aout2(idBott)',                &
     &          'Write out bottom property ', itrc,                     &
     &          TRIM(Vname(1,idBott(itrc)))
          END DO
#endif
#ifdef SOLVE3D
          IF (Aout2(idTsur(itemp),ng)) WRITE (out,170)                  &
     &        Aout2(idTsur(itemp),ng), 'Aout2(idTsur)',                 &
     &       'Write out surface net heat flux.'
          IF (Aout2(idTsur(isalt),ng)) WRITE (out,170)                  &
     &        Aout2(idTsur(isalt),ng), 'Aout2(idTsur)',                 &
     &       'Write out surface net salt flux.'
# ifdef SHORTWAVE
          IF (Aout2(idSrad,ng)) WRITE (out,170) Aout2(idSrad,ng),       &
     &       'Aout2(idSrad)',                                           &
     &       'Write out shortwave radiation flux.'
# endif
          IF (Aout2(idSSSf,ng)) WRITE (out,170) Aout2(idSSSf,ng),       &
     &       'Aout2(idSSSf)',                                           &
     &       'Write out sea surface salinity correction flux.'
# ifdef BULK_FLUXES
          IF (Aout2(idLrad,ng)) WRITE (out,170) Aout2(idLrad,ng),       &
     &       'Aout2(idLrad)',                                           &
     &       'Write out longwave radiation flux.'
          IF (Aout2(idLhea,ng)) WRITE (out,170) Aout2(idLhea,ng),       &
     &       'Aout2(idLhea)',                                           &
     &       'Write out latent heat flux.'
          IF (Aout2(idShea,ng)) WRITE (out,170) Aout2(idShea,ng),       &
     &       'Aout2(idShea)',                                           &
     &       'Write out sensible heat flux.'
#  ifdef EMINUSP
          IF (Aout2(idevap,ng)) WRITE (out,170) Aout2(idevap,ng),       &
     &       'Aout2(idevap)',                                           &
     &       'Write out evaporation rate.'
          IF (Aout2(idrain,ng)) WRITE (out,170) Aout2(idrain,ng),       &
     &       'Aout2(idrain)',                                           &
     &       'Write out rain rate.'
#  endif
# endif
          IF (Aout2(idDano,ng)) WRITE (out,170) Aout2(idDano,ng),       &
     &       'Aout2(idDano)',                                           &
     &       'Write out density anomaly.'
          IF (Aout2(idVvis,ng)) WRITE (out,170) Aout2(idVvis,ng),       &
     &       'Aout2(idVvis)',                                           &
     &       'Write out vertical viscosity coefficient.'
          IF (Aout2(idTdif,ng)) WRITE (out,170) Aout2(idTdif,ng),       &
     &       'Aout2(idTdif)',                                           &
     &       'Write out vertical T-diffusion coefficient.'
          IF (Aout2(idSdif,ng)) WRITE (out,170) Aout2(idSdif,ng),       &
     &       'Aout2(idSdif)',                                           &
     &       'Write out vertical S-diffusion coefficient.'
# ifdef LMD_SKPP
          IF (Aout2(idHsbl,ng)) WRITE (out,170) Aout2(idHsbl,ng),       &
     &       'Aout2(idHsbl)',                                           &
     &       'Write out depth of surface boundary layer.'
# endif
# ifdef LMD_BKPP
          IF (Aout2(idHbbl,ng)) WRITE (out,170) Aout2(idHbbl,ng),       &
     &       'Aout2(idHbbl)',                                           &
     &       'Write out depth of bottom boundary layer.'
# endif
# if defined GLS_MIXING || defined MY25_MIXING
          IF (Aout2(idMtke,ng)) WRITE (out,170) Aout2(idMtke,ng),       &
     &       'Aout2(idMtke)',                                           &
     &       'Write out turbulent kinetic energy.'
          IF (Aout2(idMtls,ng)) WRITE (out,170) Aout2(idMtls,ng),       &
     &       'Aout2(idMtls)',                                           &
     &       'Write out turbulent generic length-scale.'
# endif
#endif
#if defined AVERAGES    || \
   (defined AD_AVERAGES && defined ADJOINT) || \
   (defined RP_AVERAGES && defined TL_IOMS) || \
   (defined TL_AVERAGES && defined TANGENT)
          WRITE (out,'(1x)')
          IF (Aout(idFsur,ng)) WRITE (out,170) Aout(idFsur,ng),         &
     &       'Aout(idFsur)',                                            &
     &       'Write out averaged free-surface.'
          IF (Aout(idUbar,ng)) WRITE (out,170) Aout(idUbar,ng),         &
     &       'Aout(idUbar)',                                            &
     &       'Write out averaged 2D U-momentum component.'
          IF (Aout(idVbar,ng)) WRITE (out,170) Aout(idVbar,ng),         &
     &       'Aout(idVbar)',                                            &
     &       'Write out averaged 2D V-momentum component.'
# ifdef SOLVE3D
          IF (Aout(idUvel,ng)) WRITE (out,170) Aout(idUvel,ng),         &
     &       'Aout(idUvel)',                                            &
     &       'Write out averaged 3D U-momentum component.'
          IF (Aout(idVvel,ng)) WRITE (out,170) Aout(idVvel,ng),         &
     &       'Aout(idVvel)',                                            &
     &       'Write out averaged 3D V-momentum component.'
          IF (Aout(idWvel,ng)) WRITE (out,170) Aout(idWvel,ng),         &
     &       'Aout(idWvel)',                                            &
     &       'Write out averaged W-momentum component.'
          IF (Aout(idOvel,ng)) WRITE (out,170) Aout(idOvel,ng),         &
     &       'Aout(idOvel)',                                            &
     &       'Write out averaged omega vertical velocity.'
          DO itrc=1,NAT
            IF (Aout(idTvar(itrc),ng)) WRITE (out,180)                  &
     &          Aout(idTvar(itrc),ng), 'Aout(idTvar)',                  &
     &          'Write out averaged tracer ', itrc,                     &
     &          TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
# ifdef ICE_MODEL
          IF (Aout(idUice,ng)) WRITE (out,170) Aout(idUice,ng),         &
     &       'Aout(idUice)',                                            &
     &       'Write out time-averaged U-component ice velocity.'
          IF (Aout(idVice,ng)) WRITE (out,170) Aout(idVice,ng),         &
     &       'Aout(idVice)',                                            &
     &       'Write out time-averaged V-component ice velocity.'
          IF (Aout(idAice,ng)) WRITE (out,170) Aout(idAice,ng),         &
     &       'Aout(idAice)',                                            &
     &       'Write out time-averaged ice concentration.'
          IF (Aout(idHice,ng)) WRITE (out,170) Aout(idHice,ng),         &
     &       'Aout(idHice)',                                            &
     &       'Write out time-averaged average ice thickness.'
          IF (Aout(idHsno,ng)) WRITE (out,170) Aout(idHsno,ng),         &
     &       'Aout(idHsno)',                                            &
     &       'Write out time-averaged snow thickness.'
          IF (Aout(idTice,ng)) WRITE (out,170) Aout(idTice,ng),         &
     &       'Aout(idTice)',                                            &
     &       'Write out time-averaged ice/snow surface temperature.'
          IF (Aout(idTimid,ng)) WRITE (out,170) Aout(idTimid,ng),       &
     &       'Aout(idTimid)',                                           &
     &       'Write out time-averaged interior ice temperature.'
          IF (Aout(idSfwat,ng)) WRITE (out,170) Aout(idSfwat,ng),       &
     &       'Aout(idSfwat)',                                           &
     &       'Write out time-averaged surface water (on ice) thickness.'
          IF (Aout(idAgeice,ng)) WRITE (out,170) Aout(idAgeice,ng),     &
     &       'Aout(idAgeice)',                                          &
     &       'Write out time-averaged ice age.'
          IF (Aout(idIomflx,ng)) WRITE (out,170) Aout(idIomflx,ng),     &
     &       'Aout(idIomflx)',                                          &
     &       'Write out time-averaged ice-ocean mass flux'
          IF (Aout(idSig11,ng)) WRITE (out,170) Aout(idSig11,ng),       &
     &       'Aout(idSig11)',                                           &
     &       'Write out time-averaged internal ice stress component 11.'
          IF (Aout(idSig12,ng)) WRITE (out,170) Aout(idSig12,ng),       &
     &       'Aout(idSig12)',                                           &
     &       'Write out time-averaged internal ice stress component 12.'
          IF (Aout(idSig22,ng)) WRITE (out,170) Aout(idSig22,ng),       &
     &       'Aout(idSig22)',                                           &
     &       'Write out time-averaged internal ice stress component 22.'
          IF (Aout(idTauiw,ng)) WRITE (out,170) Aout(idTauiw,ng),       &
     &       'Aout(idTauiw)',                                           &
     &       'Write out time-averaged ice-water friction velocity.'
          IF (Aout(idChuiw,ng)) WRITE (out,170) Aout(idChuiw,ng),       &
     &       'Aout(idChuiw)',                                           &
     &       'Write out time-averaged ice-water transfer coefficient.'
          IF (Aout(idT0mk,ng)) WRITE (out,170) Aout(idT0mk,ng),         &
     &       'Aout(idT0mk)',                                            &
     &       'Write out time-averaged under ice temperature.'
          IF (Aout(idS0mk,ng)) WRITE (out,170) Aout(idS0mk,ng),         &
     &       'Aout(idS0mk)',                                            &
     &       'Write out time-averaged under ice salinity.'
          IF (Aout(idWfr,ng)) WRITE (out,170) Aout(idWfr,ng),           &
     &       'Aout(idWfr)',                                             &
     &       'Write out time-averaged frazil ice growth rate.'
          IF (Aout(idWai,ng)) WRITE (out,170) Aout(idWai,ng),           &
     &       'Aout(idWai)',                                             &
     &       'Write out time-averaged ice growth/melt rate.'
          IF (Aout(idWao,ng)) WRITE (out,170) Aout(idWao,ng),           &
     &       'Aout(idWao)',                                             &
     &       'Write out time-averaged ice growth/melt rate.'
          IF (Aout(idWio,ng)) WRITE (out,170) Aout(idWio,ng),           &
     &       'Aout(idWio)',                                             &
     &       'Write out time-averaged ice growth/melt rate.'
          IF (Aout(idWro,ng)) WRITE (out,170) Aout(idWro,ng),           &
     &       'Aout(idWro)',                                             &
     &       'Write out time-averaged ice melt runoff rate.'
#endif
          IF (Aout(idUsms,ng)) WRITE (out,170) Aout(idUsms,ng),         &
     &       'Aout(idUsms)',                                            &
     &       'Write out averaged surface U-momentum stress.'
          IF (Aout(idVsms,ng)) WRITE (out,170) Aout(idVsms,ng),         &
     &       'Aout(idVsms)',                                            &
     &       'Write out averaged surface V-momentum stress.'
          IF (Aout(idUbms,ng)) WRITE (out,170) Aout(idUbms,ng),         &
     &       'Aout(idUbms)',                                            &
     &       'Write out averaged bottom U-momentum stress.'
          IF (Aout(idVbms,ng)) WRITE (out,170) Aout(idVbms,ng),         &
     &       'Aout(idVbms)',                                            &
     &       'Write out averaged bottom V-momentum stress.'
# if defined NEARSHORE_MELLOR
          IF (Aout(idW2xx,ng)) WRITE (out,170) Aout(idW2xx,ng),         &
     &       'Aout(idW2xx)',                                            &
     &       'Write out averaged 2D radiation stress, Sxx.'
          IF (Aout(idW2xy,ng)) WRITE (out,170) Aout(idW2xy,ng),         &
     &       'Aout(idW2xy)',                                            &
     &       'Write out averaged 2D radiation stress, Sxy.'
          IF (Aout(idW2yy,ng)) WRITE (out,170) Aout(idW2yy,ng),         &
     &       'Aout(idW2yy)',                                            &
     &       'Write out averaged 2D radiation stress, Syy.'
          IF (Aout(idU2rs,ng)) WRITE (out,170) Aout(idU2rs,ng),         &
     &       'Aout(idU2rs)',                                            &
     &       'Write out averaged total 2D u-radiation stress.'
          IF (Aout(idV2rs,ng)) WRITE (out,170) Aout(idV2rs,ng),         &
     &       'Aout(idV2rs)',                                            &
     &       'Write out averaged total 2D v-radiation stress.'
          IF (Aout(idU2Sd,ng)) WRITE (out,170) Aout(idU2Sd,ng),         &
     &       'Aout(idU2Sd)',                                            &
     &       'Write out averaged 2D u-momentum stokes velocity.'
          IF (Aout(idV2Sd,ng)) WRITE (out,170) Aout(idV2Sd,ng),         &
     &       'Aout(idV2Sd)',                                            &
     &       'Write out averaged 2D v-momentum stokes velocity.'
#  ifdef SOLVE3D
          IF (Aout(idW3xx,ng)) WRITE (out,170) Aout(idW3xx,ng),         &
     &       'Aout(idW3xx)',                                            &
     &       'Write out averaged 3D radiation stress, Sxx.'
          IF (Aout(idW3xy,ng)) WRITE (out,170) Aout(idW3xy,ng),         &
     &       'Aout(idW3xy)',                                            &
     &       'Write out averaged 3D radiation stress, Sxy.'
          IF (Aout(idW3yy,ng)) WRITE (out,170) Aout(idW3yy,ng),         &
     &       'Aout(idW3yy)',                                            &
     &       'Write out averaged 3D radiation stress, Syy.'
          IF (Aout(idW3zx,ng)) WRITE (out,170) Aout(idW3zx,ng),         &
     &       'Aout(idW3zx)',                                            &
     &       'Write out averaged 3D radiation stress, Szx.'
          IF (Aout(idW3zy,ng)) WRITE (out,170) Aout(idW3zy,ng),         &
     &       'Aout(idW3zy)',                                            &
     &       'Write out averaged 3D radiation stress, Szy.'
          IF (Aout(idU3rs,ng)) WRITE (out,170) Aout(idU3rs,ng),         &
     &       'Aout(idU3rs)',                                            &
     &       'Write out averaged total 3D u-radiation stress.'
          IF (Aout(idV3rs,ng)) WRITE (out,170) Aout(idV3rs,ng),         &
     &       'Aout(idV3rs)',                                            &
     &       'Write out averaged total 3D v-radiation stress.'
          IF (Aout(idU3Sd,ng)) WRITE (out,170) Aout(idU3Sd,ng),         &
     &       'Aout(idU3Sd)',                                            &
     &       'Write out averaged 3D u-momentum stokes velocity.'
          IF (Aout(idV3Sd,ng)) WRITE (out,170) Aout(idV3Sd,ng),         &
     &       'Aout(idV3Sd)',                                            &
     &       'Write out averaged 3D v-momentum stokes velocity.'
#  endif
# endif
# if defined SOLVE3D && defined T_PASSIVE
          DO itrc=1,NPT
            IF (Aout(idTvar(inert(itrc)),ng)) WRITE (out,180)           &
     &          Aout(idTvar(inert(itrc)),ng), 'Aout(inert)',            &
     &          'Write out  averaged inert passive tracer ', itrc,      &
     &          TRIM(Vname(1,idTvar(inert(itrc))))
          END DO
# endif
# ifdef SOLVE3D
#  if defined BULK_FLUXES || defined ECOSIM || defined ATM_PRESS
          IF (Aout(idPair,ng)) WRITE (out,170) Aout(idPair,ng),         &
     &       'Aout(idPair)',                                            &
     &       'Write out averaged surface air pressure.'
#  endif
#  if defined BULK_FLUXES || defined ECOSIM
          IF (Aout(idUair,ng)) WRITE (out,170) Aout(idUair,ng),         &
     &       'Aout(idUair)',                                            &
     &       'Write out averaged surface U-wind component.'
          IF (Aout(idVair,ng)) WRITE (out,170) Aout(idVair,ng),         &
     &       'Aout(idVair)',                                            &
     &       'Write out averaged surface V-wind component.'
#  endif
          IF (Aout(idTsur(itemp),ng)) WRITE (out,170)                   &
     &        Aout(idTsur(itemp),ng), 'Aout(idTsur)',                   &
     &       'Write out averaged surface net heat flux.'
          IF (Aout(idTsur(isalt),ng)) WRITE (out,170)                   &
     &        Aout(idTsur(isalt),ng), 'Aout(idTsur)',                   &
     &       'Write out averaged surface net salt flux.'
#  ifdef SHORTWAVE
          IF (Aout(idSrad,ng)) WRITE (out,170) Aout(idSrad,ng),         &
     &       'Aout(idSrad)',                                            &
     &       'Write out averaged shortwave radiation flux.'
#  endif
          IF (Aout(idSSSf,ng)) WRITE (out,170) Aout(idSSSf,ng),         &
     &       'Aout(idSSSf)',                                            &
     &       'Write out averaged shortwave radiation flux.'
#  ifdef BULK_FLUXES
          IF (Aout(idLrad,ng)) WRITE (out,170) Aout(idLrad,ng),         &
     &       'Aout(idLrad)',                                            &
     &       'Write out averaged longwave radiation flux.'
          IF (Aout(idLhea,ng)) WRITE (out,170) Aout(idLhea,ng),         &
     &       'Aout(idLhea)',                                            &
     &       'Write out averaged latent heat flux.'
          IF (Aout(idShea,ng)) WRITE (out,170) Aout(idShea,ng),         &
     &       'Aout(idShea)',                                            &
     &       'Write out averaged sensible heat flux.'
#   ifdef EMINUSP
          IF (Aout(idevap,ng)) WRITE (out,170) Aout(idevap,ng),         &
     &       'Aout(idevap)',                                            &
     &       'Write out averaged evaporation rate.'
          IF (Aout(idrain,ng)) WRITE (out,170) Aout(idrain,ng),         &
     &       'Aout(idrain)',                                            &
     &       'Write out averaged rain rate.'
#   endif
#  endif
          IF (Aout(idDano,ng)) WRITE (out,170) Aout(idDano,ng),         &
     &       'Aout(idDano)',                                            &
     &       'Write out averaged density anomaly.'
#  ifdef NEMURO_SED1
          IF (Aout(idPONsed,ng)) WRITE (out,170) Aout(idPONsed,ng),     &
     &       'Aout(idPONsed)',                                          &
     &       'Write out averaged PON in sediment.'
          IF (Aout(idOPALsed,ng)) WRITE (out,170) Aout(idOPALsed,ng),   &
     &       'Aout(idOPALsed)',                                         &
     &       'Write out averaged OPAL in sediment.'
          IF (Aout(idDENITsed,ng)) WRITE (out,170) Aout(idDENITsed,ng), &
     &       'Aout(idDENITsed)',                                        &
     &       'Write out averaged DENIT in sediment.'
          IF (Aout(idPONbur,ng)) WRITE (out,170) Aout(idPONbur,ng),     &
     &       'Aout(idPONbur)',                                          &
     &       'Write out averaged buried PON in sediment.'
          IF (Aout(idOPALbur,ng)) WRITE (out,170) Aout(idOPALbur,ng),   &
     &       'Aout(idOPALbur)',                                         &
     &       'Write out averaged buried OPAL in sediment.'
#  endif
#  if defined LMD_MIXING || defined MY25_MIXING || defined GLS_MIXING
          IF (Aout(idVvis,ng)) WRITE (out,170) Aout(idVvis,ng),         &
     &       'Aout(idVvis)',                                            &
     &       'Write out averaged vertical viscosity: AKv.'
          IF (Aout(idTdif,ng)) WRITE (out,170) Aout(idTdif,ng),         &
     &       'Aout(idTdif)',                                            &
     &       'Write out averaged vertical diffusion: AKt(itemp).'
          IF (Aout(idSdif,ng)) WRITE (out,170) Aout(idSdif,ng),         &
     &       'Aout(idSdif)',                                            &
     &       'Write out averaged vertical diffusion: AKt(isalt).'
#  endif
#  ifdef LMD_SKPP
          IF (Aout(idHsbl,ng)) WRITE (out,170) Aout(idHsbl,ng),         &
     &       'Aout(idHsbl)',                                            &
     &       'Write out averaged depth of surface boundary layer.'
#  endif
#  ifdef LMD_BKPP
          IF (Aout(idHbbl,ng)) WRITE (out,170) Aout(idHbbl,ng),         &
     &       'Aout(idHbbl)',                                            &
     &       'Write out averaged depth of bottom boundary layer.'
#  endif
# endif
          IF (Aout(id2dRV,ng)) WRITE (out,170) Aout(id2dRV,ng),         &
     &       'Aout(id2dRV)',                                            &
     &       'Write out averaged 2D relative vorticity.'
          IF (Aout(id2dPV,ng)) WRITE (out,170) Aout(id2dPV,ng),         &
     &       'Aout(id2dPV)',                                            &
     &       'Write out averaged 2D potential vorticity.'
# ifdef SOLVE3D
          IF (Aout(id3dRV,ng)) WRITE (out,170) Aout(id3dRV,ng),         &
     &       'Aout(id3dRV)',                                            &
     &       'Write out averaged 3D relative vorticity.'
          IF (Aout(id3dPV,ng)) WRITE (out,170) Aout(id3dPV,ng),         &
     &       'Aout(id3dPV)',                                            &
     &       'Write out averaged 3D potential vorticity.'
# endif
          IF (Aout(idZZav,ng)) WRITE (out,170) Aout(idZZav,ng),         &
     &       'Aout(idZZav)',                                            &
     &       'Write out averaged quadratic <zeta*zeta> term.'
          IF (Aout(idU2av,ng)) WRITE (out,170) Aout(idU2av,ng),         &
     &       'Aout(idU2av)',                                            &
     &       'Write out averaged quadratic <ubar*ubar> term.'
          IF (Aout(idV2av,ng)) WRITE (out,170) Aout(idV2av,ng),         &
     &       'Aout(idV2av)',                                            &
     &       'Write out averaged quadratic <vbar*vbar> term.'
# ifdef SOLVE3D
          IF (Aout(idHUav,ng)) WRITE (out,170) Aout(idHUav,ng),         &
     &       'Aout(idHUav)',                                            &
     &       'Write out averaged u-volume flux, Huon.'
          IF (Aout(idHVav,ng)) WRITE (out,170) Aout(idHVav,ng),         &
     &       'Aout(idHVav)',                                            &
     &       'Write out averaged v-volume flux, Hvom.'
          IF (Aout(idUUav,ng)) WRITE (out,170) Aout(idUUav,ng),         &
     &       'Aout(idUUav)',                                            &
     &       'Write out averaged quadratic <u*u> term.'
          IF (Aout(idUVav,ng)) WRITE (out,170) Aout(idUVav,ng),         &
     &       'Aout(idUVav)',                                            &
     &       'Write out averaged quadratic <u*v> term.'
          IF (Aout(idVVav,ng)) WRITE (out,170) Aout(idVVav,ng),         &
     &       'Aout(idVVav)',                                            &
     &       'Write out averaged quadratic <v*v> term.'
          DO itrc=1,NAT
            IF (Aout(idTTav(itrc),ng)) WRITE (out,180)                  &
     &          Aout(idTTav(itrc),ng), 'Aout(idTTav)',                  &
     &          'Write out averaged <t*t> for tracer ', itrc,           &
     &          TRIM(Vname(1,idTvar(itrc)))
          END DO
          DO itrc=1,NAT
            IF (Aout(idUTav(itrc),ng)) WRITE (out,180)                  &
     &          Aout(idUTav(itrc),ng), 'Aout(idUTav)',                  &
     &          'Write out averaged <u*t> for tracer ', itrc,           &
     &          TRIM(Vname(1,idTvar(itrc)))
          END DO
          DO itrc=1,NAT
            IF (Aout(idVTav(itrc),ng)) WRITE (out,180)                  &
     &          Aout(idVTav(itrc),ng), 'Aout(idVTav)',                  &
     &          'Write out averaged <v*t> for tracer ', itrc,           &
     &          TRIM(Vname(1,idTvar(itrc)))
          END DO
          DO itrc=1,NAT
            IF (Aout(iHUTav(itrc),ng)) WRITE (out,180)                  &
     &          Aout(iHUTav(itrc),ng), 'Aout(iHUTav)',                  &
     &          'Write out averaged <Huon*t> for tracer ', itrc,        &
     &          TRIM(Vname(1,idTvar(itrc)))
          END DO
          DO itrc=1,NAT
            IF (Aout(iHVTav(itrc),ng)) WRITE (out,180)                  &
     &          Aout(iHVTav(itrc),ng), 'Aout(iHVTav)',                  &
     &          'Write out averaged <Hvom*t> for tracer ', itrc,        &
     &          TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
# if defined AVERAGES_DETIDE && (defined SSH_TIDES || defined UV_TIDES)
          WRITE (out,'(1x)')
          IF (Aout(idFsuD,ng)) WRITE (out,170) Aout(idFsuD,ng),         &
     &       'Aout(idFsuD)',                                            &
     &       'Write out detided free-surface.'
          IF (Aout(idu2dD,ng)) WRITE (out,170) Aout(idu2dD,ng),         &
     &       'Aout(idu2dD)',                                            &
     &       'Write out detided 2D U-velocity.'
          IF (Aout(idv2dD,ng)) WRITE (out,170) Aout(idv2dD,ng),         &
     &       'Aout(idv2dD)',                                            &
     &       'Write out detided 2D V-velocity.'
#  ifdef SOLVE3D
          IF (Aout(idu3dD,ng)) WRITE (out,170) Aout(idu3dD,ng),         &
     &       'Aout(idu3dD)',                                            &
     &       'Write out detided 3D U-velocity.'
          IF (Aout(idv3dD,ng)) WRITE (out,170) Aout(idv3dD,ng),         &
     &       'Aout(idv3dD)',                                            &
     &       'Write out detided 3D V-velocity.'
          DO itrc=1,NAT
            IF (Aout(idTrcD(itrc),ng)) WRITE (out,180)                  &
     &          Aout(idTrcD(itrc),ng), 'Aout(idTrcD)',                  &
     &          'Write out detided tracer ', itrc,                      &
     &          TRIM(Vname(1,idTvar(itrc)))
          END DO
#  endif
# endif
#endif
#ifdef DIAGNOSTICS_UV
          WRITE (out,'(1x)')
          IF (Dout(idDu2d(M2rate),ng).or.Dout(idDv2d(M2rate),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2rate)',                    &
     &       'Write out 2D momentun acceleration.'
          IF (Dout(idDu2d(M2pgrd),ng).or.Dout(idDv2d(M2pgrd),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2pgrd)',                    &
     &       'Write out 2D momentum pressure gradient.'
# ifdef UV_COR
          IF (Dout(idDu2d(M2fcor),ng).or.Dout(idDv2d(M2fcor),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2fcor)',                    &
     &       'Write out 2D momentum Coriolis force.'
# endif
# ifdef UV_ADV
          IF (Dout(idDu2d(M2hadv),ng).or.Dout(idDv2d(M2hadv),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2hadv)',                    &
     &       'Write out 2D momentum horizontal advection.'
          IF (Dout(idDu2d(M2xadv),ng).or.Dout(idDv2d(M2xadv),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2xadv)',                    &
     &       'Write out 2D momentum horizontal X-advection.'
          IF (Dout(idDu2d(M2yadv),ng).or.Dout(idDv2d(M2yadv),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2yadv)',                    &
     &       'Write out 2D momentum horizontal Y-advection.'
# endif
# ifdef NEARSHORE_MELLOR
          IF (Dout(idDu2d(M2hrad),ng).or.Dout(idDv2d(M2hrad),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2hrad)',                    &
     &       'Write out 2D momentum horizontal radiation stress.'
# endif
# if defined UV_VIS2 || defined UV_VIS4
          IF (Dout(idDu2d(M2hvis),ng).or.Dout(idDv2d(M2hvis),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2hvis)',                    &
     &       'Write out 2D momentum horizontal viscosity.'
          IF (Dout(idDu2d(M2xvis),ng).or.Dout(idDv2d(M2xvis),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2xvis)',                    &
     &       'Write out 2D momentum horizontal X-viscosity.'
          IF (Dout(idDu2d(M2yvis),ng).or.Dout(idDv2d(M2yvis),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2yvis)',                    &
     &       'Write out 2D momentum horizontal Y-viscosity.'
# endif
          IF (Dout(idDu2d(M2sstr),ng).or.Dout(idDv2d(M2sstr),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2sstr)',                    &
     &       'Write out 2D momentum surface stress.'
          IF (Dout(idDu2d(M2bstr),ng).or.Dout(idDv2d(M2bstr),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M2bstr)',                    &
     &       'Write out 2D momentum bottom stress.'
# ifdef SOLVE3D
          WRITE (out,'(1x)')
          IF (Dout(idDu3d(M3rate),ng).or.Dout(idDv3d(M3rate),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3rate)',                    &
     &       'Write out 3D momentun acceleration.'
          IF (Dout(idDu3d(M3pgrd),ng).or.Dout(idDv3d(M3pgrd),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3pgrd)',                    &
     &       'Write out 3D momentum pressure gradient.'
#  ifdef UV_COR
          IF (Dout(idDu3d(M3fcor),ng).or.Dout(idDv3d(M3fcor),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3fcor)',                    &
     &       'Write out 3D momentum Coriolis force.'
#  endif
#  ifdef UV_ADV
          IF (Dout(idDu3d(M3hadv),ng).or.Dout(idDv3d(M3hadv),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3hadv)',                    &
     &       'Write out 3D momentum horizontal advection.'
          IF (Dout(idDu3d(M3xadv),ng).or.Dout(idDv3d(M3xadv),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3xadv)',                    &
     &       'Write out 3D momentum horizontal X-advection.'
          IF (Dout(idDu3d(M3yadv),ng).or.Dout(idDv3d(M3yadv),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3yadv)',                    &
     &       'Write out 3D momentum horizontal Y-advection.'
          IF (Dout(idDu3d(M3vadv),ng).or.Dout(idDv3d(M3vadv),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3vadv)',                    &
     &       'Write out 3D momentum vertical advection.'
#  endif
#  ifdef NEARSHORE_MELLOR
          IF (Dout(idDu3d(M3hrad),ng).or.Dout(idDv3d(M3hrad),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3hrad)',                    &
     &       'Write out 3D momentum horizontal radiation stress.'
          IF (Dout(idDu3d(M3vrad),ng).or.Dout(idDv3d(M3vrad),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3vrad)',                    &
     &       'Write out 3D momentum vertical radiation stress.'
#  endif
#  if defined UV_VIS2 || defined UV_VIS4
          IF (Dout(idDu3d(M3hvis),ng).or.Dout(idDv3d(M3hvis),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3hvis)',                    &
     &       'Write out 3D momentum horizontal viscosity.'
          IF (Dout(idDu3d(M3xvis),ng).or.Dout(idDv3d(M3xvis),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3xvis)',                    &
     &       'Write out 3D momentum horizontal X-viscosity.'
          IF (Dout(idDu3d(M3yvis),ng).or.Dout(idDv3d(M3yvis),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3yvis)',                    &
     &       'Write out 3D momentum horizontal Y-viscosity.'
#  endif
          IF (Dout(idDu3d(M3vvis),ng).or.Dout(idDv3d(M3vvis),ng))       &
     &       WRITE (out,170) .TRUE., 'Dout(M3vvis)',                    &
     &       'Write out 3D momentum vertical viscosity.'
# endif
#endif
#if defined DIAGNOSTICS_TS && defined SOLVE3D
          WRITE (out,'(1x)')
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iTrate),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTrate)',                   &
     &            'Write out rate of change of tracer ', itrc,          &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(itrc,iTrate),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTrate)',                   &
     &            'Write out rate of change of tracer ', itrc,          &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iThadv),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iThadv)',                   &
     &            'Write out horizontal advection, tracer ', itrc,      &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(itrc,iThadv),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iThadv)',                   &
     &            'Write out horizontal advection, tracer ', itrc,      &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iTxadv),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTxadv)',                   &
     &            'Write out horizontal X-advection, tracer ', itrc,    &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(itrc,iTxadv),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTxadv)',                   &
     &            'Write out horizontal X-advection, tracer ', itrc,    &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iTyadv),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTyadv)',                   &
     &            'Write out horizontal Y-advection, tracer ', itrc,    &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(itrc,iTyadv),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTyadv)',                   &
     &            'Write out horizontal Y-advection, tracer ', itrc,    &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iTvadv),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTvadv)',                   &
     &            'Write out vertical advection, tracer ', itrc,        &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(itrc,iTvadv),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTvadv)',                   &
     &            'Write out vertical advection, tracer ', itrc,        &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
# if defined TS_DIF2 || defined TS_DIF4
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iThdif),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iThdif)',                   &
     &            'Write out horizontal diffusion, tracer ', itrc,      &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#  ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(itrc,iThdif),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iThdif)',                   &
     &            'Write out horizontal diffusion, tracer ', itrc,      &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#  endif
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iTxdif),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTxdif)',                   &
     &            'Write out horizontal X-diffusion, tracer ', itrc,    &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#  ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(i,iTxdif),ng))                              &
     &        WRITE (out,180) .TRUE., 'Dout(iTxdif)',                   &
     &            'Write out horizontal X-diffusion, tracer ', itrc,    &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#  endif
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iTydif),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTydif)',                   &
     &            'Write out horizontal Y-diffusion , tracer ', itrc,   &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#  ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(itrc,iTydif),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTydif)',                   &
     &            'Write out horizontal Y-diffusion, tracer ', itrc,    &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#  endif
#  if defined MIX_GEO_TS || defined MIX_ISO_TS
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iTsdif),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTsdif)',                   &
     &            'Write out horizontal S-diffusion, tracer ', itrc,    &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#   ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(itrc,iTsdif),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTsdif)',                   &
     &            'Write out horizontal S-diffusion, tracer ', itrc,    &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#   endif
#  endif
# endif
          DO itrc=1,NAT
            IF (Dout(idDtrc(itrc,iTvdif),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTvdif)',                   &
     &            'Write out vertical diffusion, tracer ', itrc,        &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# ifdef T_PASSIVE
          DO i=1,NPT
            itrc=inert(i)
            IF (Dout(idDtrc(itrc,iTvdif),ng))                           &
     &        WRITE (out,180) .TRUE., 'Dout(iTvdif)',                   &
     &            'Write out vertical diffusion, tracer ', itrc,        &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
# endif
#endif
#if defined HDF5 && defined DEFLATE
          WRITE (out,120) shuffle, 'shuffle',                           &
     &          'NetCDF-4/HDF5 file format shuffle filer flag.'
          WRITE (out,120) deflate, 'deflate',                           &
     &          'NetCDF-4/HDF5 file format deflate filer flag.'
          WRITE (out,120) deflate_level, 'deflate_level',               &
     &          'NetCDF-4/HDF5 file format deflate level parameter.'
#endif
!
!-----------------------------------------------------------------------
!  Report output/input files and check availability of input files.
!-----------------------------------------------------------------------
!
          WRITE (out,220)
#ifdef PROPAGATOR
          WRITE (out,230) '       Output GST Restart File:  ',          &
     &                    TRIM(GST(ng)%name)
#endif
          WRITE (out,230) '           Output Restart File:  ',          &
     &                    TRIM(RST(ng)%name)
          IF (LdefHIS(ng)) THEN
            IF (ndefHIS(ng).eq.0) THEN
              WRITE (out,230) '           Output History File:  ',      &
     &                        TRIM(HIS(ng)%name)
            ELSE
              WRITE (out,230) '      Prefix for History Files:  ',      &
     &                        TRIM(HIS(ng)%base)
            END IF
          END IF
#ifdef TANGENT
          IF (ndefTLM(ng).eq.0) THEN
            WRITE (out,230) '           Output Tangent File:  ',        &
     &                      TRIM(TLM(ng)%name)
          ELSE
            WRITE (out,230) '      Prefix for Tangent Files:  ',        &
     &                      TRIM(TLM(ng)%base)
          END IF
#endif
#ifdef WEAK_CONSTRAINT
          WRITE (out,230) '   Output Impulse Forcing File:  ',          &
     &                    TRIM(TLF(ng)%name)
#endif
#ifdef ADJOINT
          IF (ndefADJ(ng).eq.0) THEN
            WRITE (out,230) '           Output Adjoint File:  ',        &
     &                      TRIM(ADM(ng)%name)
          ELSE
            WRITE (out,230) '      Prefix for Adjoint Files:  ',        &
     &                      TRIM(ADM(ng)%base)
          END IF
#endif
#if defined FORWARD_WRITE && !defined FOUR_DVAR
          WRITE (out,230) '     Output Forward State File:  ',          &
     &                    TRIM(FWD(ng)%name)
#endif
#if defined AVERAGES    || \
   (defined AD_AVERAGES && defined ADJOINT) || \
   (defined RP_AVERAGES && defined TL_IOMS) || \
   (defined TL_AVERAGES && defined TANGENT)
          IF (ndefAVG(ng).eq.0) THEN
            WRITE (out,230) '          Output Averages File:  ',        &
     &                      TRIM(AVG(ng)%name)
          ELSE
            WRITE (out,230) '     Prefix for Averages Files:  ',        &
     &                      TRIM(AVG(ng)%base)
          END IF
#endif
#ifdef AVERAGES2
          IF (ndefAVG2(ng).eq.0) THEN
            WRITE (out,230) '          Output Secondary File:  ',        &
     &                      TRIM(AVG2(ng)%name)
          ELSE
            WRITE (out,230) '     Prefix for Secondary Files:  ',        &
     &                      TRIM(AVG2(ng)%base)
          END IF
#endif
#ifdef DIAGNOSTICS
          IF (ndefDIA(ng).eq.0) THEN
            WRITE (out,230) '       Output Diagnostics File:  ',        &
     &                      TRIM(DIA(ng)%name)
          ELSE
            WRITE (out,230) '  Prefix for Diagnostics Files:  ',        &
     &                      TRIM(DIA(ng)%base)
          END IF
#endif
#ifdef STATIONS
          WRITE (out,230) '          Output Stations File:  ',          &
     &                    TRIM(STA(ng)%name)
#endif
#ifdef FLOATS
          WRITE (out,230) '            Output Floats File:  ',          &
     &                    TRIM(FLT(ng)%name)
#endif
#ifdef MODEL_COUPLING
          WRITE (out,230) '      Physical parameters File:  ',          &
     &                    TRIM(Iname)
#endif
#ifndef ANA_GRID
          fname=GRD(ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '               Input Grid File:  ',          &
     &                    TRIM(fname)
#endif
#ifdef INI_FILE
# if defined NONLINEAR && !defined OFFLINE
! Don't search for INI file if doing OFFLINE FLOATS
          fname=INI(ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '  Input Nonlinear Initial File:  ',          &
     &                    TRIM(fname)
# endif
# if defined TANGENT && \
    !(defined FOUR_DVAR         || defined IS4DVAR_SENSITIVITY || \
      defined OPT_OBSERVATIONS  || defined SANITY_CHECK        || \
      defined SENSITIVITY_4DVAR || defined TLM_CHECK)
          fname=ITL(ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '    Input Tangent Initial File:  ',          &
     &                    TRIM(fname)
# endif
# if defined WEAK_CONSTRAINT && \
    !(defined W4DPSAS        || defined W4DPSAS_SENSITIVITY)
          fname=IRP(ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) 'Input Representer Initial File:  ',          &
     &                    TRIM(fname)
# endif
# if defined ADJOINT && \
    !(defined AD_SENSITIVITY      || defined FOUR_DVAR         || \
      defined IS4DVAR_SENSITIVITY || defined FORCING_SV        || \
      defined OPT_OBSERVATIONS    || defined OPT_PERTURBATION  || \
      defined SANITY_CHECK        || defined SENSITIVITY_4DVAR || \
      defined SO_SEMI)
          fname=IAD(ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '    Input Adjoint Initial File:  ',          &
     &                    TRIM(fname)
# endif
#endif
#if defined FRC_FILE && !defined OFFLINE_FLOATS
! Don't check for forcing files if doing OFFLINE_FLOATS
          DO i=1,nFfiles(ng)
            DO ifile=1,FRC(i,ng)%Nfiles
              fname=FRC(i,ng)%files(ifile)
              IF (.not.find_file(ng, fname)) GO TO 30
              IF (ifile.eq.1) THEN
                WRITE (out,310) '         Input Forcing File ', i,      &
     &                          ':  ', TRIM(fname)
              ELSE
                WRITE (out,'(35x,a)') TRIM(fname)
              END IF
            END DO
          END DO
#endif
#ifdef CLM_FILE
          DO ifile=1,CLM(ng)%Nfiles
            fname=CLM(ng)%files(ifile)
            IF (.not.find_file(ng, fname)) GO TO 30
            IF (ifile.eq.1) THEN
              WRITE (out,230) '        Input Climatology File:  ',      &
     &                        TRIM(fname)
            ELSE
              WRITE (out,'(35x,a)') TRIM(fname)
            END IF
          END DO
#endif
#if defined FORWARD_READ && !(defined FOUR_DVAR || defined PICARD_TEST)
          fname=FWD(ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '      Input Forward State File:  ',          &
     &                    TRIM(fname)
#endif
#if defined AD_SENSITIVITY   || defined IS4DVAR_SENSITIVITY || \
    defined OPT_OBSERVATIONS || defined SENSITIVITY_4DVAR   || \
    defined SO_SEMI
          fname=ADS(ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) 'Input Adjoint Sensitivity File:  ',          &
     &                    TRIM(fname)
#endif
#ifdef OBC_DATA
          DO i=1,nBCfiles(ng)
            DO ifile=1,BRY(i,ng)%Nfiles
              fname=BRY(i,ng)%files(ifile)
              IF (.not.find_file(ng, fname)) GO TO 30
              IF (ifile.eq.1) THEN
                WRITE (out,230) '           Input Boundary File:  ',    &
     &                        TRIM(fname)
              ELSE
                WRITE (out,'(35x,a)') TRIM(fname)
              END IF
            END DO
          END DO
#endif
#ifdef STATIONS
          fname=sposnam
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '        Station positions File:  ',          &
     &                    TRIM(fname)
#endif
#ifdef FOUR_DVAR
          fname=aparnam
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '  Assimilation Parameters File:  ',          &
     &                    TRIM(fname)
#endif
#ifdef FLOATS
          fname=fposnam
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) ' Initial Floats Positions File:  ',          &
     &                    TRIM(fname)
#endif
#ifdef BIOLOGY
          fname=bparnam
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '       Biology Parameters File:  ',          &
     &                    TRIM(fname)
#endif
#ifdef ICE_MODEL
          fname=iparnam
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '       Ice Model Parameters File:  ',        &
     &                    TRIM(fname)
#endif
          fname=varname
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,230) '  IO Variable Information File:  ',          &
     &                    TRIM(fname)
          GO TO 40
  30      IF (Master) WRITE (out,270) TRIM(fname)
          exit_flag=4
          RETURN
  40      CONTINUE
        END DO
        IF (Nuser.gt.0) THEN
          WRITE (out,230) '        Input/Output USER File:  ',          &
     &                    TRIM(USRname)
        END IF
!
!-----------------------------------------------------------------------
!  Report generic USER parameters.
!-----------------------------------------------------------------------
!
        IF (Nuser.gt.0) THEN
          WRITE (out,240)
          DO i=1,Nuser
            WRITE (out,250) user(i), i, i
          END DO
        END IF
      END IF

#if defined WEAK_CONSTRAINT   && \
   (defined POSTERIOR_EOFS    || defined POSTERIOR_ERROR_F || \
    defined POSTERIOR_ERROR_I)
!
!-----------------------------------------------------------------------
!  If weak constraint and estimating posterior analysis error
!  covariance matrix, stop it using Nouter > 1. Currently, the
!  analysis is only possible for Nouter = 1.
!-----------------------------------------------------------------------
!
        IF (Nouter.gt.1) THEN
          IF (Master) THEN
            WRITE (out,320) 'Nouter = ', Nouter,                        &
     &        'Posterior analysis error available for Nouter=1 only.'
          END IF
          exit_flag=5
          RETURN
        END IF
#endif

#ifdef SOLVE3D
!
!-----------------------------------------------------------------------
!  Rescale active tracer parameters
!-----------------------------------------------------------------------
!
      DO ng=1,Ngrids
        DO i=1,NAT+NPT
          itrc=i
# ifdef T_PASSIVE
          IF (i.gt.NAT) itrc=inert(i-NAT)
# endif
!
!  Take the square root of the biharmonic coefficients so it can
!  be applied to each harmonic operator.
!
          nl_tnu4(itrc,ng)=SQRT(ABS(nl_tnu4(itrc,ng)))
#ifdef ADJOINT
          ad_tnu4(itrc,ng)=SQRT(ABS(ad_tnu4(itrc,ng)))
#endif
#if defined TANGENT || defined TL_IOMS
          tl_tnu4(itrc,ng)=SQRT(ABS(tl_tnu4(itrc,ng)))
#endif
!
!  Compute inverse nudging coefficients (1/s) used in various tasks.
!
          IF (Tnudg(itrc,ng).gt.0.0_r8) THEN
            Tnudg(itrc,ng)=1.0_r8/(Tnudg(itrc,ng)*86400.0_r8)
          ELSE
            Tnudg(itrc,ng)=0.0_r8
          END IF
        END DO
      END DO
#endif

  50  FORMAT (/,' READ_PhyPar - Error while processing line: ',/,a)
#ifdef DISTRIBUTE
  60  FORMAT (/,1x,a,/,                                                 &
     &        /,1x,'Operating system : ',a,                             &
     &        /,1x,'CPU/hardware     : ',a,                             &
     &        /,1x,'Compiler system  : ',a,                             &
     &        /,1x,'Compiler command : ',a,                             &
     &        /,1x,'Compiler flags   : ',a,/,                           &
     &        /,1x,'Input Script  : ',a,/,                              &
     &        /,1x,'SVN Root URL  : ',a,                                &
     &        /,1x,'SVN Revision  : ',a,/,                              &
     &        /,1x,'Local Root    : ',a,                                &
     &        /,1x,'Header Dir    : ',a,                                &
     &        /,1x,'Header file   : ',a,                                &
     &        /,1x,'Analytical Dir: ',a)
#else
  60  FORMAT (/,1x,a,/,                                                 &
     &        /,1x,'Operating system : ',a,                             &
     &        /,1x,'CPU/hardware     : ',a,                             &
     &        /,1x,'Compiler system  : ',a,                             &
     &        /,1x,'Compiler command : ',a,                             &
     &        /,1x,'Compiler flags   : ',a,/,                           &
     &        /,1x,'SVN Root URL  : ',a,                                &
     &        /,1x,'SVN Revision  : ',a,/,                              &
     &        /,1x,'Local Root    : ',a,                                &
     &        /,1x,'Header Dir    : ',a,                                &
     &        /,1x,'Header file   : ',a,                                &
     &        /,1x,'Analytical Dir: ',a)
#endif
  70  FORMAT (/,' Resolution, Grid ',i2.2,': ',i4.4,'x',i4.4,'x',i3.3,  &
     &        ',',2x,'Parallel Nodes: ',i3,',',2x,'Tiling: ',i3.3,      &
     &        'x',i3.3)
  80  FORMAT (/,' ROMS/TOMS: Wrong choice of domain ',i2.2,1x,          &
     &        'partition or number of parallel threads.',               &
     &        /,12x,'NtileI * NtileJ  must be equal to the number of ', &
     &        'parallel nodes.',                                        &
     &        /,12x,'Change -np value to mpirun or',                    &
     &        /,12x,'change domain partition in input script.')
  90  FORMAT (/,' Resolution, Grid ',i2.2,': ',i4.4,'x',i4.4,'x',i3.3,  &
     &        ',',2x,'Parallel Threads: ',i2,',',2x,'Tiling: ',i3.3,    &
     &        'x',i3.3)
 100  FORMAT (/,' ROMS/TOMS: Wrong choice of domain ',i3.3,1x,          &
     &        'partition or number of parallel threads.',               &
     &        /,12x,'NtileI*NtileJ must be a positive multiple of the', &
     &        ' number of threads.',                                    &
     &        /,12x,'Change number of threads (environment variable) ', &
     &        'or',/,12x,'change domain partition in input script.')
 110  FORMAT (/,/,' Physical Parameters, Grid: ',i2.2,                  &
     &        /,  ' =============================',/)
 120  FORMAT (1x,i10,2x,a,t30,a)
 130  FORMAT (1x,i10,2x,a,t30,a,/,t32,a)
 140  FORMAT (f11.3,2x,a,t30,a)
 150  FORMAT (f11.2,2x,a,t30,a)
 160  FORMAT (f11.3,2x,a,t30,a,/,t32,a)
 170  FORMAT (10x,l1,2x,a,t30,a)
 180  FORMAT (10x,l1,2x,a,t30,a,i2.2,':',1x,a)
 185  FORMAT (10x,l1,2x,a,'(',i2.2,')',t30,a,i2.2,':',1x,a)
 190  FORMAT (1p,e11.4,2x,a,'(',i2.2,')',t30,a,/,t32,a,i2.2,':',1x,a)
 195  FORMAT (1p,e11.4,2x,a,t30,a,i2.2,':',1x,a)
 200  FORMAT (1p,e11.4,2x,a,t30,a)
 210  FORMAT (1p,e11.4,2x,a,t30,a,/,t32,a)
 220  FORMAT (/,' Output/Input Files:',/)
 230  FORMAT (2x,a,a)
 240  FORMAT (/,' Generic User Parameters:',/)
 250  FORMAT (1p,e11.4,2x,'user(',i2.2,')',t30,                         &
     &        'User parameter ',i2.2,'.')
 260  FORMAT (/,' READ_PHYPAR - Invalid input parameter, ',a,           &
     &        i4,/,15x,a)
 265  FORMAT (/,' READ_PHYPAR - Invalid input parameter, ',a,           &
     &        1p,e11.4,/,15x,a)
 270  FORMAT (/,' READ_PHYPAR - could not find input file:  ',a)
 280  FORMAT (/,' READ_PHYPAR - variable info not yet loaded, ', a)
 290  FORMAT (/,' READ_PHYPAR - Invalid dimension parameter, ',a,i4,    &
     &        /,15x,a)
 300  FORMAT (/,' READ_PHYPAR - Invalid dimension parameter, ',a,'(',   &
     &        i2.2,')',/,15x,a)
 310  FORMAT (2x,a,i2.2,a,a)
 320  FORMAT (/,' READ_PHYPAR - Invalid input parameter, ',a,i4,/,15x,a)
 330  FORMAT (/,' READ_PHYPAR - could not find input parameter: ', a,   &
     &        /,15x,'in ROMS standard input script.',/,15x,a)

      RETURN
      END SUBROUTINE read_PhyPar

#ifdef ICE_MODEL
      SUBROUTINE read_IcePar (inp, out, Lwrite)
!
!=======================================================================
!  Copyright (c) 2002 ROMS/TOMS Group                                  !
!================================================== Hernan G. Arango ===
!                                                                      !
!  This routine reads in ice model input parameters.                   !
!                                                                      !
!=======================================================================
!
      USE mod_param
      USE mod_parallel
      USE mod_ncparam
      USE mod_scalars
!
      implicit none
!
!  Imported variable declarations
!
      logical, intent(in) :: Lwrite
      integer, intent(in) :: inp, out
!
!  Local variable declarations.
!
      integer :: Lstr, Lval, Npts, Nval, i, ng, itrc, status

      integer :: decode_line, lenstr, load_i, load_l, load_r

      real(r8), dimension(100) :: Rval

      character (len=40) :: KeyWord
      character (len=80) :: line
      character (len=80), dimension(100) :: Cval

!
!-----------------------------------------------------------------------
!  Read in ice model parameters.
!-----------------------------------------------------------------------
!
      DO WHILE (.true.)
        READ (inp,'(a)',ERR=10,END=20) line
        status=decode_line(line, KeyWord, Nval, Cval, Rval)
        IF (status.gt.0) THEN
          IF (TRIM(KeyWord).eq.'Lice') THEN
            Npts=load_l(Nval, Cval, Ngrids, Lice)
          ELSE IF (TRIM(KeyWord).eq.'DTICE') THEN
            Npts=load_r(Nval, Rval, Ngrids, dtice)
          ELSE IF (TRIM(KeyWord).eq.'DTICE_EQ') THEN
            Npts=load_r(Nval, Rval, Ngrids, dtice_eq)
          ELSE IF (TRIM(KeyWord).eq.'nstrs') THEN
            Npts=load_i(Nval, Rval, Ngrids, nstrs)
          ELSE IF (TRIM(KeyWord).eq.'nevp') THEN
            Npts=load_i(Nval, Rval, Ngrids, nevp)
          ELSE IF (TRIM(KeyWord).eq.'rhoice') THEN
            Npts=load_r(Nval, Rval, Ngrids, rhoice)
          ELSE IF (TRIM(KeyWord).eq.'cdiw') THEN
            Npts=load_r(Nval, Rval, Ngrids, cdiw)
          ELSE IF (TRIM(KeyWord).eq.'cdai') THEN
            Npts=load_r(Nval, Rval, Ngrids, cdai)
          ELSE IF (TRIM(KeyWord).eq.'rho_air') THEN
            Npts=load_r(Nval, Rval, Ngrids, rho_air)
          ELSE IF (TRIM(KeyWord).eq.'rhosnow_dry') THEN
            Npts=load_r(Nval, Rval, Ngrids, rhosnow_dry)
          ELSE IF (TRIM(KeyWord).eq.'rhosnow_wet') THEN
            Npts=load_r(Nval, Rval, Ngrids, rhosnow_wet)
          ELSE IF (TRIM(KeyWord).eq.'pstar') THEN
            Npts=load_r(Nval, Rval, Ngrids, pstar)
          ELSE IF (TRIM(KeyWord).eq.'astren') THEN
            Npts=load_r(Nval, Rval, Ngrids, astren)
          ELSE IF (TRIM(KeyWord).eq.'zetamax') THEN
            Npts=load_r(Nval, Rval, Ngrids, zetamax)
          ELSE IF (TRIM(KeyWord).eq.'zetamin') THEN
            Npts=load_r(Nval, Rval, Ngrids, zetamin)
          ELSE IF (TRIM(KeyWord).eq.'ellip_sq') THEN
            Npts=load_r(Nval, Rval, Ngrids, ellip_sq)
          ELSE IF (TRIM(KeyWord).eq.'alphai') THEN
            Npts=load_r(Nval, Rval, Ngrids, alphai)
            do ng=1,Ngrids
               alphai(ng) = alphai(ng)*deg2rad
            enddo
          ELSE IF (TRIM(KeyWord).eq.'tol') THEN
            Npts=load_r(Nval, Rval, 1, tol)
          ELSE IF (TRIM(KeyWord).eq.'min_h') THEN
            Npts=load_r(Nval, Rval, Ngrids, min_h)
          ELSE IF (TRIM(KeyWord).eq.'min_a') THEN
            Npts=load_r(Nval, Rval, Ngrids, min_a)
          ELSE IF (TRIM(KeyWord).eq.'max_a') THEN
            Npts=load_r(Nval, Rval, Ngrids, max_a)
          ELSE IF (TRIM(KeyWord).eq.'sfwat_max') THEN
            Npts=load_r(Nval, Rval, Ngrids, sfwat_max)
          ELSE IF (TRIM(KeyWord).eq.'stressang') THEN
            Npts=load_r(Nval, Rval, Ngrids, stressang)
            do ng=1,Ngrids
               stressang(ng) = stressang(ng)*deg2rad
            enddo
          ELSE IF (TRIM(KeyWord).eq.'ice_emiss') THEN
            Npts=load_r(Nval, Rval, 1, ice_emiss)
          ELSE IF (TRIM(KeyWord).eq.'spec_heat_air') THEN
            Npts=load_r(Nval, Rval, 1, spec_heat_air)
          ELSE IF (TRIM(KeyWord).eq.'trans_coeff') THEN
            Npts=load_r(Nval, Rval, 1, trans_coeff)
          ELSE IF (TRIM(KeyWord).eq.'sublim_latent_heat') THEN
            Npts=load_r(Nval, Rval, 1, sublim_latent_heat)
          ELSE IF (TRIM(KeyWord).eq.'t0deg') THEN
            Npts=load_r(Nval, Rval, 1, t0deg)
          END IF
        END IF
      END DO
  10  IF (Master) WRITE (out,30) line
      exit_flag=4
      RETURN
  20  CLOSE (inp)

! Set ice time step to ocean time step

      DO ng = 1,Ngrids
        dtice(ng) = dt(ng)
      END DO
!
!-----------------------------------------------------------------------
!  Report input parameters.
!-----------------------------------------------------------------------
!
      IF (Lwrite) THEN
        DO ng=1,Ngrids
          IF (Lice(ng)) THEN
            WRITE (out,40) ng
            WRITE(out,*) 'Ice time step = ocean time step'
            WRITE (out,100) dtice(ng), 'DTICE',                         &
     &            'Ice model time step (s).'
            WRITE (out,100) dtice_eq(ng), 'DTICE_EQ',                   &
     &            'Ice drift update (equilibrium) time step (s).'
            WRITE (out,50) nstrs(ng), 'nstrs',                          &
     &            'Number of iterations for nonlinear ice dynamics.'
            WRITE (out,50) nevp(ng), 'nevp',                            &
     &            'Number of elastic steps per plastic step in EVP.'
            WRITE (out,100) rhoice(ng), 'rhoice',                       &
     &            'Density of sea ice (kg/m3).'
            WRITE (out,100) cdiw(ng), 'cdiw',                           &
     &            'Ice-water drag coefficient (nondimensional).'
            WRITE (out,100) cdai(ng), 'cdai',                           &
     &            'Air-ice drag coefficient (nondimensional).'
            WRITE (out,100) rho_air(ng), 'rho_air',                     &
     &            'Air density (kg/m3).'
            WRITE (out,100) rhosnow_dry(ng), 'rhosnow_dry',             &
     &            'Dry snow density (kg/m3).'
            WRITE (out,100) rhosnow_wet(ng), 'rhosnow_wet',             &
     &            'Wet snow density (kg/m3).'
            WRITE (out,100) alphai(ng)*rad2deg, 'alphai',               &
     &            'Mohr-Coulomb stress angle (degrees).'
            WRITE (out,100) min_h(ng), 'min_h',                         &
     &            'Minimum average ice thickness (m).'
            WRITE (out,100) min_a(ng), 'min_a',                         &
     &            'Minimum ice concentration (nondimensional).'
            WRITE (out,100) max_a(ng), 'max_a',                         &
     &            'Maximum ice concentration (nondimensional).'
            WRITE (out,100) sfwat_max(ng)*rad2deg, 'sfwat_max',         &
     &            'Maximum surface fresh water (nondimensional).'
            WRITE (out,100) stressang(ng)*rad2deg, 'stressang',         &
     &            'Turning angle for ice-water drag (degrees).'
            WRITE (out,100) tol, 'tol',                                 &
     &            'Numerical tolerance in rheology calculations .'
            WRITE (out,100) ice_emiss, 'ice_emiss',                     &
     &            'Ice emissivity.'
            WRITE (out,100) spec_heat_air, 'spec_heat_air',             &
     &            'Specific heat of air.'
            WRITE (out,100) trans_coeff, 'trans_coeff',                 &
     &            'Transfer coefficient.'
            WRITE (out,100) sublim_latent_heat, 'sublim_latent_heat',   &
     &            'Latent_heat of sublimation.'
            WRITE (out,100) t0deg, 't0deg',                             &
     &            'Zero degrees Celsius in degrees Kelvin.'
          END IF
        END DO
      END IF

  30  FORMAT (/,' READ_IcePar - Error while processing line: ',/,a)
  40  FORMAT (/,/,' Ice Parameters, Grid: ',i2.2,                   &
     &        /,' ============================',/)
  50  FORMAT (1x,i10,2x,a,t28,a)
  60  FORMAT (10x,l1,2x,a,t28,a,i2.2,':',1x,a)
  70  FORMAT (f11.3,2x,a,t28,a)
  80  FORMAT (f11.3,2x,a,t28,a,/,t30,a)
  90  FORMAT (1p,e11.4,2x,a,'(',i2.2,')',t28,a,/,t30,a,i2.2,':',1x,a)
 100  FORMAT (1p,e11.4,2x,a,t28,a)
 110  FORMAT (1p,e11.4,2x,a,t28,a,/,t30,a)
 120  FORMAT (10x,l1,2x,a,t28,a)
 280  FORMAT (/,' READ_IcePar - variable info not yet loaded, ', a)
      RETURN
      END SUBROUTINE read_IcePar
#endif

#if defined FOUR_DVAR || defined VERIFICATION
      SUBROUTINE read_AssPar (model, inp, out, Lwrite)
!
!=======================================================================
!                                                                      !
!  This subroutine reads in input model assimilation parameters.       !
!                                                                      !
!=======================================================================
!
      USE mod_param
      USE mod_parallel
# if defined FOUR_DVAR || defined VERIFICATION
      USE mod_fourdvar
# endif
      USE mod_iounits
      USE mod_ncparam
      USE mod_scalars
!
      implicit none
!
!  Imported variable declarations
!
      logical, intent(in) :: Lwrite
      integer, intent(in) :: model, inp, out
!
!  Local variable declarations.
!
      logical :: find_file

      integer :: Npts, Nval
      integer :: i, ib, igrid, itrc, k, ng, status

      integer :: decode_line, load_i, load_l, load_r, load_s1d

      integer :: Nfiles(Ngrids)
# if defined FOUR_DVAR || defined VERIFICATION
      logical, dimension(MT) :: Ltracer
#  if defined ADJUST_STFLUX && defined SOLVE3D
      logical, dimension(MT,Ngrids) :: Ltsur
#  endif
#  ifdef ADJUST_BOUNDARY
      logical, dimension(4,Ngrids) :: Lbry
#   ifdef SOLVE3D
      logical, dimension(4,MT,Ngrids) :: Lbry_trc
      logical, dimension(MT,4) :: Lboundary
      real(r8), dimension(MT,4,Ngrids) :: Rboundary
#   endif
#  endif
      real(r8), dimension(MT,Ngrids) :: Rtracer
# endif
      real(r8), dimension(100) :: Rval

      character (len=1 ), parameter :: blank = ' '
# ifdef ADJUST_BOUNDARY
      character (len=7) :: Text
# endif
      character (len=40 ) :: KeyWord
      character (len=50 ) :: label
      character (len=256) :: fname, line
      character (len=256), dimension(100) :: Cval
!
!-----------------------------------------------------------------------
!  Initialize.
!-----------------------------------------------------------------------
!
      igrid=1
      Nfiles(1:Ngrids)=0
      DO i=1,LEN(label)
        label(i:i)=blank
      END DO

# if defined FOUR_DVAR || defined VERIFICATION
!
!-----------------------------------------------------------------------
!  Read in 4DVAR assimilation parameters. Then, load input data into
!  module.
!-----------------------------------------------------------------------
!
      DO WHILE (.TRUE.)
        READ (inp,'(a)',ERR=10,END=20) line
        status=decode_line(line, KeyWord, Nval, Cval, Rval)
        IF (status.gt.0) THEN
          IF (TRIM(KeyWord).eq.'dTdz_min') THEN
            Npts=load_r(Nval, Rval, Ngrids, dTdz_min)
          ELSE IF (TRIM(KeyWord).eq.'ml_depth') THEN
            Npts=load_r(Nval, Rval, Ngrids, ml_depth)
            DO ng=1,Ngrids
              ml_depth(ng)=ABS(ml_depth(ng))
            END DO
#  if defined BALANCE_OPERATOR && defined ZETA_ELLIPTIC
          ELSE IF (TRIM(KeyWord).eq.'Nbico') THEN
            Npts=load_i(Nval, Rval, Ngrids, Nbico)
#  endif
          ELSE IF (TRIM(KeyWord).eq.'LNM_depth') THEN
            Npts=load_r(Nval, Rval, Ngrids, LNM_depth)
            DO ng=1,Ngrids
              LNM_depth(ng)=ABS(LNM_depth(ng))
            END DO
          ELSE IF (TRIM(KeyWord).eq.'LNM_flag') THEN
            Npts=load_i(Nval, Rval, 1, LNM_flag)
#  if defined WEAK_CONSTRAINT && \
     (defined ARRAY_MODES     || defined CLIPPING)
          ELSE IF (TRIM(KeyWord).eq.'Nvct') THEN
            Npts=load_i(Nval, Rval, 1, Nvct)
#  endif
          ELSE IF (TRIM(KeyWord).eq.'GradErr') THEN
            Npts=load_r(Nval, Rval, 1, GradErr)
          ELSE IF (TRIM(KeyWord).eq.'HevecErr') THEN
            Npts=load_r(Nval, Rval, 1, HevecErr)
          ELSE IF (TRIM(KeyWord).eq.'LhessianEV') THEN
            Npts=load_l(Nval, Cval, 1, LhessianEV)
          ELSE IF (TRIM(KeyWord).eq.'LhotStart') THEN
            Npts=load_l(Nval, Cval, 1, LhotStart)
          ELSE IF (TRIM(KeyWord).eq.'Lprecond') THEN
            Npts=load_l(Nval, Cval, 1, Lprecond)
#  if defined WEAK_CONSTRAINT
            IF ( LhessianEV.and.Lprecond ) THEN
              LhessianEV=.FALSE.
            END IF
#  endif
          ELSE IF (TRIM(KeyWord).eq.'Lritz') THEN
            Npts=load_l(Nval, Cval, 1, Lritz)
          ELSE IF (TRIM(KeyWord).eq.'NritzEV') THEN
            Npts=load_i(Nval, Rval, 1, NritzEV)
          ELSE IF (TRIM(KeyWord).eq.'NpostI') THEN
            Npts=load_i(Nval, Rval, 1, NpostI)
          ELSE IF (TRIM(KeyWord).eq.'tl_M2diff') THEN
            Npts=load_r(Nval, Rval, Ngrids, tl_M2diff)
          ELSE IF (TRIM(KeyWord).eq.'tl_M3diff') THEN
            Npts=load_r(Nval, Rval, Ngrids, tl_M3diff)
          ELSE IF (TRIM(KeyWord).eq.'tl_Tdiff') THEN
            Npts=load_r(Nval, Rval, MT*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NT(ng)
                tl_Tdiff(itrc,ng)=Rtracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'LdefNRM') THEN
            Npts=load_l(Nval, Cval, 4*Ngrids, LdefNRM)
          ELSE IF (TRIM(KeyWord).eq.'LwrtNRM') THEN
            Npts=load_l(Nval, Cval, 4*Ngrids, LwrtNRM)
          ELSE IF (TRIM(KeyWord).eq.'CnormM(isFsur)') THEN
            IF (isFsur.eq.0) THEN
              IF (Master) WRITE (out,190) 'isFsur'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, 1, Cnorm(2,isFsur))
          ELSE IF (TRIM(KeyWord).eq.'CnormM(isUbar)') THEN
            IF (isUbar.eq.0) THEN
              IF (Master) WRITE (out,190) 'isUbar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, 1, Cnorm(2,isUbar))
          ELSE IF (TRIM(KeyWord).eq.'CnormM(isVbar)') THEN
            IF (isVbar.eq.0) THEN
              IF (Master) WRITE (out,190) 'isVbar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, 1, Cnorm(2,isVbar))
#  ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'CnormM(isUvel)') THEN
            IF (isUvel.eq.0) THEN
              IF (Master) WRITE (out,190) 'isUvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, 1, Cnorm(2,isUvel))
          ELSE IF (TRIM(KeyWord).eq.'CnormM(isVvel)') THEN
            IF (isVvel.eq.0) THEN
              IF (Master) WRITE (out,190) 'isVvel'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, 1, Cnorm(2,isVvel))
          ELSE IF (TRIM(KeyWord).eq.'CnormM(isTvar)') THEN
            IF (MAXVAL(isTvar).eq.0) THEN
              IF (Master) WRITE (out,190) 'isTvar'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, MT, Ltracer)
            DO itrc=1,MT
              i=isTvar(itrc)
              Cnorm(2,i)=Ltracer(itrc)
            END DO
#  endif
          ELSE IF (TRIM(KeyWord).eq.'CnormI(isFsur)') THEN
            Npts=load_l(Nval, Cval, 1, Cnorm(1,isFsur))
          ELSE IF (TRIM(KeyWord).eq.'CnormI(isUbar)') THEN
            Npts=load_l(Nval, Cval, 1, Cnorm(1,isUbar))
          ELSE IF (TRIM(KeyWord).eq.'CnormI(isVbar)') THEN
            Npts=load_l(Nval, Cval, 1, Cnorm(1,isVbar))
#  ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'CnormI(isUvel)') THEN
            Npts=load_l(Nval, Cval, 1, Cnorm(1,isUvel))
          ELSE IF (TRIM(KeyWord).eq.'CnormI(isVvel)') THEN
            Npts=load_l(Nval, Cval, 1, Cnorm(1,isVvel))
          ELSE IF (TRIM(KeyWord).eq.'CnormI(isTvar)') THEN
            Npts=load_l(Nval, Cval, MT, Ltracer)
            DO itrc=1,MT
              i=isTvar(itrc)
              Cnorm(1,i)=Ltracer(itrc)
            END DO
#  endif
#  ifdef ADJUST_BOUNDARY
          ELSE IF (TRIM(KeyWord).eq.'CnormB(isFsur)') THEN
            Npts=load_l(Nval, Cval, 4, CnormB(isFsur,:))
          ELSE IF (TRIM(KeyWord).eq.'CnormB(isUbar)') THEN
            Npts=load_l(Nval, Cval, 4, CnormB(isUbar,:))
          ELSE IF (TRIM(KeyWord).eq.'CnormB(isVbar)') THEN
            Npts=load_l(Nval, Cval, 4, CnormB(isVbar,:))
#   ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'CnormB(isUvel)') THEN
            Npts=load_l(Nval, Cval, 4, CnormB(isUvel,:))
          ELSE IF (TRIM(KeyWord).eq.'CnormB(isVvel)') THEN
            Npts=load_l(Nval, Cval, 4, CnormB(isVvel,:))
          ELSE IF (TRIM(KeyWord).eq.'CnormB(isTvar)') THEN
            Npts=load_l(Nval, Cval, MT*4, Lboundary)
            DO ib=1,4
              DO itrc=1,MT
                i=isTvar(itrc)
                CnormB(i,ib)=Lboundary(itrc,ib)
              END DO
            END DO
#   endif
#  endif
#  ifdef ADJUST_WSTRESS
          ELSE IF (TRIM(KeyWord).eq.'CnormF(isUstr)') THEN
            IF (isUstr.eq.0) THEN
              IF (Master) WRITE (out,190) 'isUstr'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, 1, Cnorm(1,isUstr))
          ELSE IF (TRIM(KeyWord).eq.'CnormF(isVstr)') THEN
            IF (isVstr.eq.0) THEN
              IF (Master) WRITE (out,190) 'isVstr'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, 1, Cnorm(1,isVstr))
#  endif
#  if defined ADJUST_STFLUX && defined SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'CnormF(isTsur)') THEN
            IF (MAXVAL(isTsur).eq.0) THEN
              IF (Master) WRITE (out,190) 'isTsur'
              exit_flag=5
              RETURN
            END IF
            Npts=load_l(Nval, Cval, MT, Ltracer)
            DO itrc=1,MT
              i=isTsur(itrc)
              Cnorm(1,i)=Ltracer(itrc)
            END DO
#  endif
          ELSE IF (TRIM(KeyWord).eq.'balance(isSalt)') THEN
            Npts=load_l(Nval, Cval, 1, balance(isTvar(isalt)))
          ELSE IF (TRIM(KeyWord).eq.'balance(isFsur)') THEN
            Npts=load_l(Nval, Cval, 1, balance(isFsur))
          ELSE IF (TRIM(KeyWord).eq.'balance(isVbar)') THEN
            Npts=load_l(Nval, Cval, 1, balance(isVbar))
          ELSE IF (TRIM(KeyWord).eq.'balance(isVvel)') THEN
            Npts=load_l(Nval, Cval, 1, balance(isVvel))
          ELSE IF (TRIM(KeyWord).eq.'Nmethod') THEN
            Npts=load_i(Nval, Rval, Ngrids, Nmethod)
          ELSE IF (TRIM(KeyWord).eq.'Rscheme') THEN
            Npts=load_i(Nval, Rval, Ngrids, Rscheme)
          ELSE IF (TRIM(KeyWord).eq.'Nrandom') THEN
            Npts=load_i(Nval, Rval, 1, Nrandom)
          ELSE IF (TRIM(KeyWord).eq.'Hgamma') THEN
            Npts=load_r(Nval, Rval, 4, Hgamma)
#  ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Vgamma') THEN
            Npts=load_r(Nval, Rval, 4, Vgamma)
#  endif
          ELSE IF (TRIM(KeyWord).eq.'HdecayM(isFsur)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(2,isFsur,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayM(isUbar)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(2,isUbar,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayM(isVbar)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(2,isVbar,:))
#  ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'HdecayM(isUvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(2,isUvel,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayM(isVvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(2,isVvel,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayM(isTvar)') THEN
            Npts=load_r(Nval, Rval, MT*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NT(ng)
                Hdecay(2,isTvar(itrc),ng)=Rtracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'VdecayM(isUvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Vdecay(2,isUvel,:))
          ELSE IF (TRIM(KeyWord).eq.'VdecayM(isVvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Vdecay(2,isVvel,:))
          ELSE IF (TRIM(KeyWord).eq.'VdecayM(isTvar)') THEN
            Npts=load_r(Nval, Rval, MT*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NT(ng)
                Vdecay(2,isTvar(itrc),ng)=Rtracer(itrc,ng)
              END DO
            END DO
#  endif
          ELSE IF (TRIM(KeyWord).eq.'HdecayI(isFsur)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(1,isFsur,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayI(isUbar)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(1,isUbar,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayI(isVbar)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(1,isVbar,:))
#  ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'HdecayI(isUvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(1,isUvel,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayI(isVvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(1,isVvel,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayI(isTvar)') THEN
            Npts=load_r(Nval, Rval, MT*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NT(ng)
                Hdecay(1,isTvar(itrc),ng)=Rtracer(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'VdecayI(isUvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Vdecay(1,isUvel,:))
          ELSE IF (TRIM(KeyWord).eq.'VdecayI(isVvel)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Vdecay(1,isVvel,:))
          ELSE IF (TRIM(KeyWord).eq.'VdecayI(isTvar)') THEN
            Npts=load_r(Nval, Rval, MT*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NT(ng)
                Vdecay(1,isTvar(itrc),ng)=Rtracer(itrc,ng)
              END DO
            END DO
#  endif
#  ifdef ADJUST_BOUNDARY
          ELSE IF (TRIM(KeyWord).eq.'HdecayB(isFsur)') THEN
            Npts=load_r(Nval, Rval, 4*Ngrids, HdecayB(isFsur,:,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayB(isUbar)') THEN
            Npts=load_r(Nval, Rval, 4*Ngrids, HdecayB(isUbar,:,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayB(isVbar)') THEN
            Npts=load_r(Nval, Rval, 4*Ngrids, HdecayB(isVbar,:,:))
#   ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'HdecayB(isUvel)') THEN
            Npts=load_r(Nval, Rval, 4*Ngrids, HdecayB(isUvel,:,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayB(isVvel)') THEN
            Npts=load_r(Nval, Rval, 4*Ngrids, HdecayB(isVvel,:,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayB(isTvar)') THEN
            Npts=load_r(Nval, Rval, 4*MT*Ngrids, Rboundary)
            DO ng=1,Ngrids
              DO ib=1,4
                DO itrc=1,NT(ng)
                  HdecayB(isTvar(itrc),ib,ng)=Rboundary(itrc,ib,ng)
                END DO
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'VdecayB(isUvel)') THEN
            Npts=load_r(Nval, Rval, 4*Ngrids, VdecayB(isUvel,:,:))
          ELSE IF (TRIM(KeyWord).eq.'VdecayB(isVvel)') THEN
            Npts=load_r(Nval, Rval, 4*Ngrids, VdecayB(isVvel,:,:))
          ELSE IF (TRIM(KeyWord).eq.'VdecayB(isTvar)') THEN
            Npts=load_r(Nval, Rval, 4*MT*Ngrids, Rboundary)
            DO ng=1,Ngrids
              DO ib=1,4
                DO itrc=1,NT(ng)
                  VdecayB(isTvar(itrc),ib,ng)=Rboundary(itrc,ib,ng)
                END DO
              END DO
            END DO
#   endif
#  endif
#  ifdef ADJUST_WSTRESS
          ELSE IF (TRIM(KeyWord).eq.'HdecayF(isUstr)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(1,isUstr,:))
          ELSE IF (TRIM(KeyWord).eq.'HdecayF(isVstr)') THEN
            Npts=load_r(Nval, Rval, Ngrids, Hdecay(1,isVstr,:))
#  endif
#  if defined ADJUST_STFLUX && defined SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'HdecayF(isTsur)') THEN
            Npts=load_r(Nval, Rval, MT*Ngrids, Rtracer)
            DO ng=1,Ngrids
              DO itrc=1,NT(ng)
                Hdecay(1,isTsur(itrc),ng)=Rtracer(itrc,ng)
              END DO
            END DO
#  endif
#  if defined ADJUST_STFLUX && defined SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Lstflux') THEN
            Npts=load_l(Nval, Cval, MT*Ngrids, Ltsur)
            DO ng=1,Ngrids
              DO itrc=1,NT(ng)
                Lstflux(itrc,ng)=Ltsur(itrc,ng)
              END DO
            END DO
#  endif
#  ifdef ADJUST_BOUNDARY
          ELSE IF (TRIM(KeyWord).eq.'Lobc(isFsur)') THEN
            Npts=load_l(Nval, Cval, 4*Ngrids, Lbry)
            DO ng=1,Ngrids
              DO ib=1,4
                Lobc(ib,isFsur,ng)=Lbry(ib,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Lobc(isUbar)') THEN
            Npts=load_l(Nval, Cval, 4*Ngrids, Lbry)
            DO ng=1,Ngrids
              DO ib=1,4
                Lobc(ib,isUbar,ng)=Lbry(ib,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Lobc(isVbar)') THEN
            Npts=load_l(Nval, Cval, 4*Ngrids, Lbry)
            DO ng=1,Ngrids
              DO ib=1,4
                Lobc(ib,isVbar,ng)=Lbry(ib,ng)
              END DO
            END DO
#   ifdef SOLVE3D
          ELSE IF (TRIM(KeyWord).eq.'Lobc(isUvel)') THEN
            Npts=load_l(Nval, Cval, 4*Ngrids, Lbry)
            DO ng=1,Ngrids
              DO ib=1,4
                Lobc(ib,isUvel,ng)=Lbry(ib,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Lobc(isVvel)') THEN
            Npts=load_l(Nval, Cval, 4*Ngrids, Lbry)
            DO ng=1,Ngrids
              DO ib=1,4
                Lobc(ib,isVvel,ng)=Lbry(ib,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Lobc(isTvar)') THEN
            Npts=load_l(Nval, Cval, 4*MT*Ngrids, Lbry_trc)
            DO ng=1,Ngrids
              DO itrc=1,NT(ng)
                i=isTvar(itrc)
                DO ib=1,4
                  Lobc(ib,i,ng)=Lbry_trc(ib,itrc,ng)
                END DO
              END DO
            END DO
#   endif
#  endif
          ELSE IF (TRIM(KeyWord).eq.'STDnameI') THEN
            label='STD - initial conditions standard deviation'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles,       &
     &                    STD(1,:))
          ELSE IF (TRIM(KeyWord).eq.'STDnameM') THEN
            label='STD - model error standard deviation'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles,       &
     &                    STD(2,:))
          ELSE IF (TRIM(KeyWord).eq.'STDnameB') THEN
            label='STD - boundary conditions standard deviation'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles,       &
     &                    STD(3,:))
          ELSE IF (TRIM(KeyWord).eq.'STDnameF') THEN
            label='STD - surface forcing standard deviation'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles,       &
     &                    STD(4,:))
          ELSE IF (TRIM(KeyWord).eq.'NRMnameI') THEN
            label='NRM - initial conditions normalization'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles,       &
     &                    NRM(1,:))
          ELSE IF (TRIM(KeyWord).eq.'NRMnameM') THEN
            label='NRM - model error normalization'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles,       &
     &                    NRM(2,:))
          ELSE IF (TRIM(KeyWord).eq.'NRMnameB') THEN
            label='NRM - boundary conditions normalization'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles,       &
     &                    NRM(3,:))
          ELSE IF (TRIM(KeyWord).eq.'NRMnameF') THEN
            label='NRM - surface forcing normalization'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles,       &
     &                    NRM(4,:))
          ELSE IF (TRIM(KeyWord).eq.'OBSname') THEN
            label='OBS - data assimilation observations'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, OBS)
          ELSE IF (TRIM(KeyWord).eq.'HSSname') THEN
            label='HSS - Hessian eigenvectors'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, HSS)
          ELSE IF (TRIM(KeyWord).eq.'LCZname') THEN
            label='LCZ - Lanczos vectors'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, LCZ)
          ELSE IF (TRIM(KeyWord).eq.'MODname') THEN
            label='DAV - 4D-Var data assimilation variables'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, DAV)
          ELSE IF (TRIM(KeyWord).eq.'ERRname') THEN
            label='ERR - 4D-Var posterior error covariance'
            Npts=load_s1d(Nval, Cval, line, label, igrid, Nfiles, ERR)
          END IF
        END IF
      END DO
 10   IF (Master) WRITE (out,50) line
      exit_flag=4
      RETURN
 20   CONTINUE

#  ifdef ADJUST_BOUNDARY
!
!-----------------------------------------------------------------------
!  Check switches to adjust boundaries for consistency.
!-----------------------------------------------------------------------
!
!  Make sure that both momentum components are activated for processing.
!  If adjusting 2D momentum in 3D applications, make sure that the
!  free-surface and 3D momentum switches are activated. This is because
!  the 2D momentum adjustments are computed from the vertical integral
!  of the 3D momentum increments.
!
      DO ng=1,Ngrids
        DO ib=1,4
          IF (.not.Lobc(ib,isUbar,ng).and.Lobc(ib,isVbar,ng)) THEN
            Lobc(ib,isUbar,ng)=.TRUE.
          END IF
          IF (.not.Lobc(ib,isVbar,ng).and.Lobc(ib,isUbar,ng)) THEN
            Lobc(ib,isVbar,ng)=.TRUE.
          END IF
#   ifdef SOLVE3D
          IF (.not.Lobc(ib,isUvel,ng).and.Lobc(ib,isVvel,ng)) THEN
            Lobc(ib,isUvel,ng)=.TRUE.
          END IF
          IF (.not.Lobc(ib,isVvel,ng).and.Lobc(ib,isUvel,ng)) THEN
            Lobc(ib,isVvel,ng)=.TRUE.
          END IF
          IF (.not.Lobc(ib,isFsur,ng).and.Lobc(ib,isUbar,ng)) THEN
            Lobc(ib,isFsur,ng)=.TRUE.
          END IF
          IF (.not.Lobc(ib,isUvel,ng).and.Lobc(ib,isUbar,ng)) THEN
            Lobc(ib,isUvel,ng)=.TRUE.
            Lobc(ib,isVvel,ng)=.TRUE.
          END IF
#   endif
        END DO
      END DO
#  endif
#  if defined WEAK_CONSTRAINT && \
     (defined ARRAY_MODES     || defined CLIPPING)
!
!-----------------------------------------------------------------------
!  Check array modes parameter
!-----------------------------------------------------------------------
!
!  Array modes parameter must be greater than zero and less or equal
!  to Ninner.
!
      IF ((Nvct.lt.1).or.(Nvct.gt.Ninner)) THEN
        IF (Lwrite) THEN
          WRITE (out,55) 'Illegal parameter for array modes, Nvct = ',  &
     &                   Nvct, Ninner, '1 =< Nvct =< Ninner.'
        END IF
        exit_flag=6
        RETURN
      END IF
#  endif
#  ifdef BALANCE_OPERATOR
!
!-----------------------------------------------------------------------
!  Check balance operator switches for consitency.
!-----------------------------------------------------------------------
!
#   ifdef SOLVE3D
      IF (.not.balance(isTvar(isalt)).and.balance(isFsur)) THEN
        balance(isTvar(isalt))=.TRUE.
      END IF
      IF (.not.balance(isTvar(isalt)).and.balance(isVvel)) THEN
        balance(isTvar(isalt))=.TRUE.
      END IF
      IF (balance(isTvar(isalt))) THEN
        balance(isTvar(itemp))=.TRUE.
      END IF
      IF (balance(isVvel)) THEN
        balance(isUvel)=.TRUE.
      END IF
      IF (balance(isVbar)) THEN
        balance(isVbar)=.FALSE.
      END IF
#   else
      IF (balance(isVbar)) THEN
        balance(isUbar)=.TRUE.
      END IF
#   endif
#  endif
!
!-----------------------------------------------------------------------
!  Report input parameters.
!-----------------------------------------------------------------------
!
      IF (Lwrite) THEN
        DO ng=1,Ngrids
#  if defined FOUR_DVAR
          WRITE (out,60) ng
#   ifdef WEAK_CONSTRAINT
#    ifdef RPM_RELAXATION
          WRITE (out,120) tl_M2diff, 'tl_M2diff',                       &
     &            'RPM 2D momentum diffusive relaxation coefficient.'
#     ifdef SOLVE3D
          WRITE (out,130) tl_M3diff, 'tl_M3diff',                       &
     &            'RPM 3D momentum diffusive relaxation coefficient.'
          DO itrc=1,NT(ng)
            WRITE (out,130) tl_Tdiff(itrc,ng), 'tl_Tdiff',              &
     &            'RPM tracer diffusive relaxation coefficient, ',      &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#     endif
#    endif
#   endif
#   ifndef IS4DVAR_SENSITIVITY
#    ifdef IS4DVAR
          WRITE (out,100) GradErr, 'GradErr',                           &
     &            'Upper bound on relative error of the gradient.'
          WRITE (out,100) HevecErr, 'HevecErr',                         &
     &            'Accuracy required for Hessian eigenvectors.'
          WRITE (out,70) LhessianEV, 'LhessianEV',                      &
     &            'Switch to compute Hessian eigenvectors.'
#    endif
#    ifdef WEAK_CONSTRAINT
          WRITE (out,70) LhotStart, 'LhotStart',                        &
     &            'Switch for hot start of subsequent outer loops.'
#    endif
          WRITE (out,70) Lprecond, 'Lprecond',                          &
     &            'Switch for conjugate gradient preconditioning.'
          WRITE (out,70) Lritz, 'Lritz',                                &
     &            'Switch for Ritz limited-memory preconditioning.'
#    ifdef WEAK_CONSTRAINT
          IF (Lprecond.and.(NritzEV.gt.0)) THEN
            WRITE (out,80) NritzEV, 'NritzEV',                          &
     &            'Number of preconditioning eigenpairs to use.'
          END IF
#    endif
#   endif
#   ifdef BALANCE_OPERATOR
#    ifdef ZETA_ELLIPTIC
          WRITE (out,80) Nbico(ng), 'Nbico',                            &
     &            'Number of iterations in SSH elliptic equation.'
#    endif
          WRITE (out,100) dTdz_min(ng), 'dTdz_min',                     &
     &            'Minimum dTdz (C/m) used in balanced salinity.'
          WRITE (out,100) ml_depth(ng), 'ml_depth',                     &
     &            'Mixed-layer depth (m) used in balanced salinity.'
          IF (balance(isFsur)) THEN
            WRITE (out,100) LNM_depth(ng), 'LNM_depth',                 &
     &            'Level of no motion (m) in balanced free-sruface.'
            WRITE (out,80) LNM_flag, 'LNM_flag',                        &
     &            'Level of no motion integration flag.'
          END IF
          WRITE (out,70) balance(isFsur), 'balance(isFsur)',            &
                  'Switch to include free-surface in balance operator.'
#    ifdef SOLVE3D
          WRITE (out,70) balance(isTvar(isalt)), 'balance(isSalt)',     &
                  'Switch to include salinity in balance operator.'
          WRITE (out,70) balance(isVvel), 'balance(isVvel)',            &
                  'Switch to include 3D momentum in balance operator.'
#    else
          WRITE (out,70) balance(isVbar), 'balance(isVbar)',            &
                  'Switch to include 2D momentum in balance operator.'
#    endif
#   endif
#   ifdef WEAK_CONSTRAINT
#    if defined ARRAY_MODES
          WRITE (out,80) Nvct, 'Nvct',                                  &
     &            'Representer array mode eigenvector to process.'
#    elif defined CLIPPING
          WRITE (out,80) Nvct, 'Nvct',                                  &
     &            'Representer cut-off eigenvector to process.'
#    endif
#   endif
#   if defined POSTERIOR_EOFS && defined WEAK_CONSTRAINT
          WRITE (out,80) NpostI, 'NpostI',                              &
     &            'Number of Lanczos iterations in posterior analysis.'
#   endif
#   ifndef TLM_CHECK
#    ifndef IS4DVAR_SENSITIVITY
          WRITE (out,170) LdefNRM(1:4,ng), 'LdefNRM',                   &
     &            'Switch to create a normalization NetCDF file.'
          WRITE (out,170) LwrtNRM(1:4,ng), 'LwrtNRM',                   &
     &            'Switch to write out normalization factors.'
          IF (ANY(LwrtNRM(:,ng))) THEN
            IF (Nmethod(ng).eq.0) THEN
              WRITE (out,80) Nmethod(ng), 'Nmethod',                    &
     &            'Correlation normalization method: Exact.'
            ELSE IF (Nmethod(ng).eq.1) THEN
              WRITE (out,80) Nmethod(ng), 'Nmethod',                    &
     &            'Correlation normalization method: Randomization.'
              WRITE (out,80) Rscheme(ng), 'Rscheme',                    &
     &            'Random number generation scheme'
              WRITE (out,80) Nrandom, 'Nrandom',                        &
     &            'Number of iterations for randomization.'
            END IF
          END IF
#     if defined SENSITIVITY_4DVAR || \
         defined TL_W4DPSAS        || defined TL_W4DVAR || \
         defined W4DPSAS           || defined W4DVAR
          IF (ANY(LwrtNRM(:,ng))) THEN
            WRITE (out,70) Cnorm(2,isFsur), 'CnormM(isFsur)',           &
     &            'Compute model 2D RHO-normalization factors.'
            WRITE (out,70) Cnorm(2,isUbar), 'CnormM(isUbar)',           &
     &            'Compute model 2D U-normalization factors.'
            WRITE (out,70) Cnorm(2,isVbar), 'CnormM(isVbar)',           &
     &            'Compute model 2D V-normalization factors.'
#      ifdef SOLVE3D
            WRITE (out,70) Cnorm(2,isUvel), 'CnormM(isUvel)',           &
     &            'Compute model 3D U-normalization factors.'
            WRITE (out,70) Cnorm(2,isVvel), 'CnormM(isVvel)',           &
     &            'Compute model 3D V-normalization factors.'
            DO itrc=1,NT(ng)
              WRITE (out,110) Cnorm(2,isTvar(itrc)), 'CnormM(isTvar)',  &
     &            'Compute model normalization factors for tracer ',    &
     &            itrc, TRIM(Vname(1,idTvar(itrc)))
            END DO
#      endif
          END IF
#     endif
          IF (ANY(LwrtNRM(:,ng))) THEN
            WRITE (out,70) Cnorm(1,isFsur), 'CnormI(isFsur)',           &
     &            'Compute initial 2D RHO-normalization factors.'
            WRITE (out,70) Cnorm(1,isUbar), 'CnormI(isUbar)',           &
     &            'Compute initial 2D U-normalization factors.'
            WRITE (out,70) Cnorm(1,isVbar), 'CnormI(isVbar)',           &
     &            'Compute initial 2D V-normalization factors.'
#     ifdef SOLVE3D
            WRITE (out,70) Cnorm(1,isUvel), 'CnormI(isUvel)',           &
     &            'Compute initial 3D U-normalization factors.'
            WRITE (out,70) Cnorm(1,isVvel), 'CnormI(isVvel)',           &
     &            'Compute initial 3D V-normalization factors.'
            DO itrc=1,NT(ng)
              WRITE (out,110) Cnorm(1,isTvar(itrc)), 'CnormI(isTvar)',  &
     &            'Compute initial normalization factors for tracer ',  &
     &            itrc, TRIM(Vname(1,idTvar(itrc)))
            END DO
#     endif
          END IF
#     ifdef ADJUST_BOUNDARY
          IF (ANY(LwrtNRM(:,ng))) THEN
            WRITE (out,170) CnormB(isFsur,1:4), 'CnormB(isFsur)',       &
     &            'Compute boundary 2D RHO-normalization factors.'
            WRITE (out,170) CnormB(isUbar,1:4), 'CnormB(isUbar)',       &
     &            'Compute boundary 2D U-normalization factors.'
            WRITE (out,170) CnormB(isVbar,1:4), 'CnormB(isVbar)',       &
     &            'Compute initial 2D V-normalization factors.'
#      ifdef SOLVE3D
            WRITE (out,170) CnormB(isUvel,1:4), 'CnormB(isUvel)',       &
     &            'Compute initial 3D U-normalization factors.'
            WRITE (out,170) CnormB(isVvel,1:4), 'CnormI(isVvel)',       &
     &            'Compute initial 3D V-normalization factors.'
            DO itrc=1,NT(ng)
              WRITE (out,180) CnormB(isTvar(itrc),1:4),'CnormI(isTvar)',&
     &            'Compute initial normalization factors for tracer ',  &
     &            itrc, TRIM(Vname(1,idTvar(itrc)))
            END DO
#      endif
          END IF
#     endif
#     ifdef ADJUST_WSTRESS
          IF (ANY(LwrtNRM(:,ng))) THEN
            WRITE (out,70) Cnorm(1,isUstr), 'CnormF(isUstr)',           &
     &            'Compute normalization factors at surface U-stress.'
            WRITE (out,70) Cnorm(1,isVstr), 'CnormF(isVstr)',           &
     &            'Compute normalization factors at surface V-stress.'
          END IF
#     endif
#     if defined ADJUST_STFLUX && defined SOLVE3D
          IF (ANY(LwrtNRM(:,ng))) THEN
            DO itrc=1,NT(ng)
              WRITE (out,110) Cnorm(1,isTsur(itrc)), 'CnormF(isTsur)',  &
     &            'Compute normalization factors for flux of tracer ',  &
     &            itrc, TRIM(Vname(1,idTvar(itrc)))
            END DO
          END IF
#     endif
#    endif
          WRITE (out,100) Hgamma(1), 'Hgamma',                          &
     &            'Horizontal diffusion factor, initial conditions.'
#    ifdef WEAK_CONSTRAINT
          WRITE (out,100) Hgamma(2), 'HgammaM',                         &
     &            'Horizontal diffusion factor, model error.'
#    endif
#    ifdef ADJUST_BOUNDARY
          WRITE (out,100) Hgamma(3), 'HgammaB',                         &
     &            'Horizontal diffusion factor, boundary conditions.'
#    endif
#    ifdef ADJUST_STFLUX
          WRITE (out,100) Hgamma(4), 'HgammaF',                         &
     &            'Horizontal diffusion factor, surface forcing.'
#    endif
#    ifdef SOLVE3D
          WRITE (out,100) Vgamma(1), 'Vgamma',                          &
     &            'Vertical diffusion factor, initial conditions.'
#     ifdef WEAK_CONSTRAINT
          WRITE (out,100) Vgamma(2), 'VgammaM',                         &
     &            'Vertical diffusion factor, model error.'
#     endif
#     ifdef ADJUST_BOUNDARY
          WRITE (out,100) Vgamma(3), 'VgammaB',                         &
     &            'Vertical diffusion factor, boundary conditions.'
#     endif
#    endif
#    if defined SENSITIVITY_4DVAR || \
        defined TL_W4DPSAS        || defined TL_W4DVAR || \
        defined W4DPSAS           || defined W4DVAR
          IF (nADJ(ng).lt.ntimes(ng)) THEN
            WRITE (out,120) Hdecay(2,isFsur,ng), 'HdecayM(isFsur)',     &
     &            'Model decorrelation H-scale (m), free-surface.'
            WRITE (out,120) Hdecay(2,isUbar,ng), 'HdecayM(isUbar)',     &
     &            'Model decorrelation H-scale (m), 2D U-momentum.'
            WRITE (out,120) Hdecay(2,isVbar,ng), 'HdecayM(isVbar)',     &
     &            'Model decorrelation H-scale (m), 2D V-momentum.'
#     ifdef SOLVE3D
            WRITE (out,120) Hdecay(2,isUvel,ng), 'HdecayM(isUvel)',     &
     &            'Model decorrelation H-scale (m), 3D U-momentum.'
            WRITE (out,120) Hdecay(2,isVvel,ng), 'HdecayM(isVvel)',     &
     &            'Model decorrelation H-scale (m), 3D V-momentum.'
            DO itrc=1,NT(ng)
              WRITE (out,130) Hdecay(2,isTvar(itrc),ng),                &
     &            'HdecayM(idTvar)',                                    &
     &            'Model decorrelation H-scale (m), ',                  &
     &            TRIM(Vname(1,idTvar(itrc)))
            END DO
            WRITE (out,120) Vdecay(2,isUvel,ng), 'VdecayM(isUvel)',     &
     &            'Model decorrelation V-scale (m), 3D U-momentum.'
            WRITE (out,120) Vdecay(2,isVvel,ng), 'VdecayM(isVvel)',     &
     &            'Model decorrelation V-scale (m), 3D V-momentum.'
            DO itrc=1,NT(ng)
              WRITE (out,130) Vdecay(2,isTvar(itrc),ng),                &
     &            'VdecayM(idTvar)',                                    &
     &            'Model decorrelation V-scale (m), ',                  &
     &            TRIM(Vname(1,idTvar(itrc)))
            END DO
#     endif
          END IF
#    endif
          WRITE (out,120) Hdecay(1,isFsur,ng), 'HdecayI(isFsur)',       &
     &            'Initial decorrelation H-scale (m), free-surface.'
          WRITE (out,120) Hdecay(1,isUbar,ng), 'HdecayI(isUbar)',       &
     &            'Initial decorrelation H-scale (m), 2D U-momentum.'
          WRITE (out,120) Hdecay(1,isVbar,ng), 'HdecayI(isVbar)',       &
     &            'Initial decorrelation H-scale (m), 2D V-momentum.'
#    ifdef SOLVE3D
          WRITE (out,120) Hdecay(1,isUvel,ng), 'HdecayI(isUvel)',       &
     &            'Initial decorrelation H-scale (m), 3D U-momentum.'
          WRITE (out,120) Hdecay(1,isVvel,ng), 'HdecayI(isVvel)',       &
     &            'Initial decorrelation H-scale (m), 3D V-momentum.'
          DO itrc=1,NT(ng)
            WRITE (out,130) Hdecay(1,isTvar(itrc),ng),                  &
     &            'HdecayI(idTvar)',                                    &
     &            'Initial decorrelation H-scale (m), ',                &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
          WRITE (out,120) Vdecay(1,isUvel,ng), 'VdecayI(isUvel)',       &
     &            'Initial decorrelation V-scale (m), 3D U-momentum.'
          WRITE (out,120) Vdecay(1,isVvel,ng), 'VdecayI(isVvel)',       &
     &            'Initial decorrelation V-scale (m), 3D V-momentum.'
          DO itrc=1,NT(ng)
            WRITE (out,130) Vdecay(1,isTvar(itrc),ng),                  &
     &            'VdecayI(idTvar)',                                    &
     &            'Initial decorrelation V-scale (m), ',                &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#    endif
#    ifdef ADJUST_BOUNDARY
          DO ib=1,4
            IF (ib.eq.iwest) THEN
              Text='W-bry  '
            ELSE IF (ib.eq.isouth) THEN
              Text='S-bry  '
            ELSE IF (ib.eq.ieast) THEN
              Text='E-bry  '
            ELSE IF (ib.eq.inorth) THEN
              Text='N-bry  '
            END IF
            IF (Lobc(ib,isFsur,ng)) THEN
              WRITE (out,120) HdecayB(isFsur,ib,ng), 'HdecayB(isFsur)', &
     &              Text//' decorrelation H-scale (m), free-surface.'
            END IF
            IF (Lobc(ib,isUbar,ng)) THEN
              WRITE (out,120) HdecayB(isUbar,ib,ng), 'HdecayB(isUbar)', &
     &              Text//' decorrelation H-scale (m), 2D U-momentum.'
            END IF
            IF (Lobc(ib,isVbar,ng)) THEN
              WRITE (out,120) HdecayB(isVbar,ib,ng), 'HdecayB(isVbar)', &
     &              Text//' decorrelation H-scale (m), 2D V-momentum.'
            END IF
#     ifdef SOLVE3D
            IF (Lobc(ib,isUvel,ng)) THEN
              WRITE (out,120) HdecayB(isUvel,ib,ng), 'HdecayB(isUvel)', &
     &              Text//' decorrelation H-scale (m), 3D U-momentum.'
            END IF
            IF (Lobc(ib,isVvel,ng)) THEN
              WRITE (out,120) HdecayB(isVvel,ib,ng), 'HdecayB(isVvel)', &
     &              Text//' decorrelation H-scale (m), 3D V-momentum.'
            END IF
            DO i=1,NT(ng)
              IF (Lobc(ib,isTvar(i),ng)) THEN
                WRITE(out,130) HdecayB(isTvar(i),ib,ng),                &
     &              'HdecayB(idTvar)',                                  &
     &              Text//' decorrelation H-scale (m), ',               &
     &              TRIM(Vname(1,idTvar(i)))
              END IF
            END DO
            IF (Lobc(ib,isUvel,ng)) THEN
              WRITE (out,120) VdecayB(isUvel,ib,ng), 'VdecayB(isUvel)', &
     &              Text//' decorrelation V-scale (m), 3D U-momentum.'
            END IF
            IF (Lobc(ib,isVvel,ng)) THEN
              WRITE (out,120) VdecayB(isVvel,ib,ng), 'VdecayB(isVvel)', &
     &              Text//' decorrelation V-scale (m), 3D V-momentum.'
            END IF
            DO i=1,NT(ng)
              IF (Lobc(ib,isTvar(i),ng)) THEN
                WRITE(out,130) VdecayB(isTvar(i),ib,ng),                &
     &              'VdecayB(idTvar)',                                  &
     &              Text//' decorrelation V-scale (m), ',               &
     &              TRIM(Vname(1,idTvar(i)))
              END IF
            END DO
#     endif
          END DO
#    endif
#    ifdef ADJUST_WSTRESS
          WRITE (out,120) Hdecay(1,isUstr,ng), 'HdecayF(isUstr)',       &
     &            'Forcing decorrelation H-scale (m), U-stress.'
          WRITE (out,120) Hdecay(1,isVstr,ng), 'HdecayF(isVstr)',       &
     &            'Forcing decorrelation H-scale (m), V-stress.'
#    endif
#    if defined ADJUST_STFLUX && defined SOLVE3D
          DO itrc=1,NT(ng)
            WRITE (out,130) Hdecay(1,isTsur(itrc),ng),                  &
     &            'HdecayF(idTsur)',                                    &
     &            'Forcing decorrelation H-scale (m), ',                &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#    endif
#    if defined ADJUST_STFLUX && defined SOLVE3D
          DO itrc=1,NT(ng)
            WRITE (out,110) Lstflux(itrc,ng), 'Lstflux(itrc)',          &
     &            'Adjusting surface flux of tracer ', itrc,            &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#    endif
#    ifdef ADJUST_BOUNDARY
          WRITE (out,170) Lobc(1:4,isFsur,ng), 'Lobc(isFsur)',          &
     &            'Adjusting free-surface boundaries.'
          WRITE (out,170) Lobc(1:4,isUbar,ng), 'Lobc(isUbar)',          &
     &            'Adjusting 2D U-momentum boundaries.'
          WRITE (out,170) Lobc(1:4,isVbar,ng), 'Lobc(isVbar)',          &
     &            'Adjusting 2D V-momentum boundaries.'
#     ifdef SOLVE3D
          WRITE (out,170) Lobc(1:4,isUvel,ng), 'Lobc(isUvel)',          &
     &            'Adjusting 3D U-momentum boundaries.'
          WRITE (out,170) Lobc(1:4,isVvel,ng), 'Lobc(isVvel)',          &
     &            'Adjusting 3D V-momentum boundaries.'
          DO itrc=1,NT(ng)
            WRITE (out,180) Lobc(1:4,isTvar(itrc),ng),'Lobc(isTvar)',   &
     &            'Adjusting boundaries for tracer ', itrc,             &
     &            TRIM(Vname(1,idTvar(itrc)))
          END DO
#     endif
#    endif
#   endif
#  endif
!
!-----------------------------------------------------------------------
!  Report input files and check availability of input files.
!-----------------------------------------------------------------------
!
          WRITE (out,150)
#  ifdef VERIFICATION
          WRITE (out,160) ' Verification Parameters File:  ',           &
     &                    TRIM(aparnam)
#  else
          WRITE (out,160) ' Assimilation Parameters File:  ',           &
     &                    TRIM(aparnam)
#  endif
#  ifdef FOUR_DVAR
#   if defined IS4DVAR          || defined OBS_SENSITIBITY || \
       defined OPT_OBSERVATIONS || defined WEAK_CONSTRAINT
#    if defined SENSITIVITY_4DVAR || \
        defined TL_W4DPSAS        || defined TL_W4DVAR || \
        defined W4DPSAS           || defined W4DVAR
          fname=STD(2,ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,160) '               Model STD File:  ',           &
     &                    TRIM(fname)
#    endif
          fname=STD(1,ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,160) '  Initial Conditions STD File:  ',           &
     &                    TRIM(fname)
#    ifdef ADJUST_BOUNDARY
          fname=STD(3,ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,160) ' Boundary Conditions STD File:  ',           &
     &                    TRIM(fname)
#    endif
#    if defined ADJUST_WSTRESS || defined ADJUST_STFLUX
          fname=STD(4,ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,160) '     Surface Forcing STD File:  ',           &
     &                    TRIM(fname)
#    endif
#   endif
#   if defined SENSITIVITY_4DVAR || defined TL_W4DPSAS  || \
       defined TL_W4DVAR         || defined W4DPSAS     || \
       defined W4DVAR
          fname=NRM(2,ng)%name
          WRITE (out,160) '              Model Norm File:  ',           &
     &                    TRIM(fname)
          IF (.not.LdefNRM(2,ng)) THEN
            IF (.not.find_file(ng, fname)) GO TO 30
          END IF
#   elif defined CORRELATION
          fname=NRM(2,ng)%name
          WRITE (out,160) '              Model Norm File:  ',           &
     &                    TRIM(fname)
          IF (.not.LdefNRM(2,ng).and.LwrtNRM(2,ng)) THEN
            IF (.not.find_file(ng, fname)) GO TO 30
          END IF
#   endif
#   if defined CORRELATION
          fname=NRM(1,ng)%name
          WRITE (out,160) ' Initial Conditions Norm File:  ',           &
     &                    TRIM(fname)
          IF (.not.LdefNRM(1,ng).and.LwrtNRM(1,ng)) THEN
            IF (.not.find_file(ng, fname)) GO TO 30
          END IF
#   else
          fname=NRM(1,ng)%name
          WRITE (out,160) ' Initial Conditions Norm File:  ',           &
     &                    TRIM(fname)
          IF (.not.LdefNRM(1,ng)) THEN
            IF (.not.find_file(ng, fname)) GO TO 30
          END IF
#   endif
#   ifdef ADJUST_BOUNDARY
#    ifdef CORRELATION
          fname=NRM(3,ng)%name
          WRITE (out,160) 'Boundary Conditions Norm File:  ',           &
     &                    TRIM(fname)
          IF (.not.LdefNRM(3,ng).and.LwrtNRM(3,ng)) THEN
            IF (.not.find_file(ng, fname)) GO TO 30
          END IF
#    else
          fname=NRM(3,ng)%name
          WRITE (out,160) 'Boundary Conditions Norm File:  ',           &
     &                    TRIM(fname)
          IF (.not.LdefNRM(3,ng)) THEN
            IF (.not.find_file(ng, fname)) GO TO 30
          END IF
#    endif
#   endif
#   if defined ADJUST_WSTRESS || defined ADJUST_STFLUX
#    ifdef CORRELATION
          fname=NRM(4,ng)%name
          WRITE (out,160) '    Surface Forcing Norm File:  ',           &
     &                    TRIM(fname)
          IF (.not.LdefNRM(4,ng).and.LwrtNRM(4,ng)) THEN
            IF (.not.find_file(ng, fname)) GO TO 30
          END IF
#    else
          fname=NRM(4,ng)%name
          WRITE (out,160) '    Surface Forcing Norm File:  ',           &
     &                    TRIM(fname)
          IF (.not.LdefNRM(4,ng)) THEN
            IF (.not.find_file(ng, fname)) GO TO 30
          END IF
#    endif
#   endif
#   if !(defined CORRELATION || defined OPT_OBSERVATIONS)
          fname=OBS(ng)%name
          IF (.not.find_file(ng, fname)) GO TO 30
          WRITE (out,160) '            Observations File:  ',           &
     &                    TRIM(fname)
#   endif
#  endif
          WRITE (out,160) '    Input/Output Lanczos File:  ',           &
     &                    TRIM(LCZ(ng)%name)
#  ifndef IS4DVAR_SENSITIVITY
          WRITE (out,160) '    Input/Output Hessian File:  ',           &
     &                    TRIM(HSS(ng)%name)
#  endif
#  ifdef VERIFICATION
          WRITE (out,160) '     Output verification File:  ',           &
     &                    TRIM(DAV(ng)%name)
#  else
          WRITE (out,160) '            Output 4DVAR File:  ',           &
     &                    TRIM(DAV(ng)%name)
#  endif
#  if defined WEAK_CONSTRAINT   && \
     (defined POSTERIOR_ERROR_F || defined POSTERIOR_ERROR_I)
          WRITE (out,160) '  Output Posterior Error File:  ',           &
     &                    TRIM(ERR(ng)%name)
#  endif
          GO TO 40
  30      WRITE (out,200) TRIM(fname)
          exit_flag=4
          RETURN
  40      CONTINUE
        END DO
      END IF

  50  FORMAT (/,' READ_AssPar - Error while processing line: ',/,a)
  55  FORMAT (/,' READ_AssPar - ',a,i4,2x,i4,/,15x,a)
  60  FORMAT (/,/,' Assimilation Parameters, Grid: ',i2.2,              &
     &        /,  ' =================================',/)
  70  FORMAT (10x,l1,2x,a,t30,a)
  80  FORMAT (1x,i10,2x,a,t30,a)
  90  FORMAT (1x,i10,2x,a,t30,a,/,t32,a)
 100  FORMAT (1p,e11.4,2x,a,t30,a)
 110  FORMAT (10x,l1,2x,a,t30,a,i2.2,':',1x,a)
 120  FORMAT (f11.3,2x,a,t30,a)
 130  FORMAT (f11.3,2x,a,t30,a,a,'.')
 150  FORMAT (/,' Input Assimilation Files:',/)
 160  FORMAT (2x,a,a)
 170  FORMAT (3x,4(1x,l1),2x,a,t30,a)
 180  FORMAT (3x,4(1x,l1),2x,a,t30,a,i2.2,':',1x,a)
 190  FORMAT (/,' READ_ASSPAR - variable info not yet loaded, ', a)
 200  FORMAT (/,' READ_ASSPAR - could not find input file:  ',a)
# endif

      RETURN
      END SUBROUTINE read_AssPar
#endif

#ifdef FLOATS
      SUBROUTINE read_FloatsPar (model, inp, out, Lwrite)
!
!=======================================================================
!                                                                      !
!  This routine reads in input float parameters.                       !
!                                                                      !
!=======================================================================
!
      USE mod_param
      USE mod_parallel
      USE mod_floats
      USE mod_iounits
      USE mod_ncparam
      USE mod_scalars
!
      implicit none
!
!  Imported variable declarations
!
      logical, intent(in) :: Lwrite
      integer, intent(in) :: model, inp, out
!
!  Local variable declarations.
!
      integer :: Npts, Nval
      integer :: i, j, igrid, mc, nc, ng, status

      integer, dimension(Ngrids) :: ncount, nentry

      integer, allocatable :: Fcoor(:,:), Fcount(:,:), Ftype(:,:)

      integer :: decode_line, load_i, load_l, load_r

      real(r8) :: xfloat, yfloat, zfloat

      real(r8), dimension(100) :: Rval

      real(r8), allocatable :: Ft0(:,:), Fx0(:,:), Fy0(:,:), Fz0(:,:)
      real(r8), allocatable :: Fdt(:,:), Fdx(:,:), Fdy(:,:), Fdz(:,:)

      character (len=35 ) :: frmt
      character (len=40 ) :: KeyWord
      character (len=256) :: line
      character (len=256), dimension(100) :: Cval
!
!-----------------------------------------------------------------------
!  Read in initial float locations.
!-----------------------------------------------------------------------
!
!  Notice I added one when allocating local scratch arrays to avoid
!  out of bounds in some compilers when reading the last blank line
!  which signal termination of input data.
!
      DO WHILE (.TRUE.)
        READ (inp,'(a)',ERR=20,END=30) line
        status=decode_line(line, KeyWord, Nval, Cval, Rval)
        IF (status.gt.0) THEN
          IF (TRIM(KeyWord).eq.'Lfloats') THEN
            Npts=load_l(Nval, Cval, Ngrids, Lfloats)
          ELSE IF (TRIM(KeyWord).eq.'FRREC') THEN
            Npts=load_i(Nval, Rval, Ngrids, frrec)
          ELSE IF (TRIM(KeyWord).eq.'NFLOATS') THEN
            Npts=load_i(Nval, Rval, Ngrids, Nfloats)
          ELSE IF (TRIM(KeyWord).eq.'POS') THEN
            Npts=Nfloats(1)+1
            IF (Ngrids.gt.1) Npts=MAXVAL(Nfloats)+1
            IF (.not.allocated(Fcoor))  allocate ( Fcoor (Npts,Ngrids) )
            IF (.not.allocated(Fcount)) allocate ( Fcount(Npts,Ngrids) )
            IF (.not.allocated(Ftype))  allocate ( Ftype (Npts,Ngrids) )
            IF (.not.allocated(Ft0))    allocate ( Ft0(Npts,Ngrids) )
            IF (.not.allocated(Fx0))    allocate ( Fx0(Npts,Ngrids) )
            IF (.not.allocated(Fy0))    allocate ( Fy0(Npts,Ngrids) )
            IF (.not.allocated(Fz0))    allocate ( Fz0(Npts,Ngrids) )
            IF (.not.allocated(Fdt))    allocate ( Fdt(Npts,Ngrids) )
            IF (.not.allocated(Fdx))    allocate ( Fdx(Npts,Ngrids) )
            IF (.not.allocated(Fdy))    allocate ( Fdy(Npts,Ngrids) )
            IF (.not.allocated(Fdz))    allocate ( Fdz(Npts,Ngrids) )
            DO ng=1,Ngrids
              CALL allocate_floats (ng)
            END DO
            ncount(1:Ngrids)=0
            nentry(1:Ngrids)=0
            DO WHILE (.TRUE.)
              READ (inp,*,ERR=30,END=30) igrid,                         &
     &                                   Fcoor (nentry(igrid)+1,igrid), &
     &                                   Ftype (nentry(igrid)+1,igrid), &
     &                                   Fcount(nentry(igrid)+1,igrid), &
     &                                   Ft0(nentry(igrid)+1,igrid),    &
     &                                   Fx0(nentry(igrid)+1,igrid),    &
     &                                   Fy0(nentry(igrid)+1,igrid),    &
     &                                   Fz0(nentry(igrid)+1,igrid),    &
     &                                   Fdt(nentry(igrid)+1,igrid),    &
     &                                   Fdx(nentry(igrid)+1,igrid),    &
     &                                   Fdy(nentry(igrid)+1,igrid),    &
     &                                   Fdz(nentry(igrid)+1,igrid)
              IF (igrid.gt.Ngrids) THEN
                IF (Lwrite) WRITE (out,40) fposnam
                exit_flag=4
                RETURN
              END IF
              ncount(igrid)=ncount(igrid)+Fcount(nentry(igrid)+1,igrid)
              nentry(igrid)=nentry(igrid)+1
            END DO
          END IF
        END IF
      END DO
  20  IF (Master) WRITE (out,50) line
      exit_flag=4
      RETURN
  30  CONTINUE
!  Turn off the processing of floats if not running long enough to
!  create a floats file (LdefFLT=.FALSE. because nFLT < ntimes or
!  nFLT = 0 when nrrec = 0).
!
      DO ng=1,Ngrids
        IF (.not.LdefFLT(ng).and.Lfloats(ng)) THEN
          Lfloats(ng)=.FALSE.
        END IF
      END DO
!
!
!  Turn off the processing of floats if not running long enough to
!  create a floats file (LdefFLT=.FALSE. because nFLT < ntimes or
!  nFLT = 0 when nrrec = 0).
!
      DO ng=1,Ngrids
        IF (.not.LdefFLT(ng).and.Lfloats(ng)) THEN
          Lfloats(ng)=.FALSE.
        END IF
      END DO
!
!-----------------------------------------------------------------------
!  Report input parameters.
!-----------------------------------------------------------------------
!
      DO ng=1,Ngrids
        IF (.not. LdefFLT(ng) .and. Lfloats(ng))                        &
     &                 Lfloats(ng) = .FALSE.
      END DO
      IF (Lwrite) THEN
        DO ng=1,Ngrids
          IF (ncount(ng).ne.Nfloats(ng)) THEN
            WRITE (stdout,60) ncount(ng), Nfloats(ng)
            exit_flag=4
            RETURN
          END IF
          IF (Lfloats(ng)) THEN
            IF (ncount(ng).ne.Nfloats(ng)) THEN
              WRITE (stdout,60) ncount(ng), Nfloats(ng)
              exit_flag=4
              RETURN
            END IF
            WRITE (out,70) ng
            DO i=1,nentry(ng)
              IF (.not.spherical.and.(Fcoor(i,ng).eq.0)) THEN
                frmt='(i1,i2,i5,f10.4,2f8.2,f8.2,4f9.3)'
              ELSE
                frmt='(i1,i2,i5,f10.4,3f8.2,4f9.3)'
              END IF
              WRITE (out,frmt) Fcoor(i,ng), Ftype(i,ng), Fcount(i,ng),  &
     &                         Ft0(i,ng), Fx0(i,ng), Fy0(i,ng),         &
     &                         Fz0(i,ng), Fdt(i,ng), Fdx(i,ng),         &
     &                         Fdy(i,ng), Fdz(i,ng)
            END DO
            WRITE (out,80) Nfloats(ng),                                 &
     &            'Nfloats',                                            &
     &            'Number of float trajectories to compute.'
          END IF
        END DO
      END IF
!
!-----------------------------------------------------------------------
!  Process initial float locations.
!-----------------------------------------------------------------------
!
!  Set time of float release (seconds after model initialization) and
!  initial float horizontal positions (grid units).  Fill the initial
!  vertical level or depth position.
!
      DO ng=1,Ngrids
        mc=0
        nc=0
        IF (Lfloats(ng)) THEN
          DO i=1,nentry(ng)
            IF (Fcount(i,ng).eq.1) THEN
              nc=nc+1
              DRIFTER(ng)%Tinfo(itstr,nc)=(dstart+Ft0(i,ng))*day2sec
              DRIFTER(ng)%Tinfo(izgrd,nc)=Fz0(i,ng)
              DRIFTER(ng)%Ftype(nc)=Ftype(i,ng)
              IF (Fcoor(i,ng).eq.0) THEN
                DRIFTER(ng)%Tinfo(ixgrd,nc)=Fx0(i,ng)
                DRIFTER(ng)%Tinfo(iygrd,nc)=Fy0(i,ng)
              ELSE
                mc=mc+1
                DRIFTER(ng)%Flon(mc)=Fx0(i,ng)
                DRIFTER(ng)%Flat(mc)=Fy0(i,ng)
                DRIFTER(ng)%Findex(mc)=nc
              END IF
            ELSE IF (Fcount(i,ng).gt.1) THEN
              DO j=1,Fcount(i,ng)
                nc=nc+1
                IF (Fdt(i,ng).gt.0.0_r8) THEN
                  DRIFTER(ng)%Tinfo(itstr,nc)=(dstart+Ft0(i,ng)+        &
     &                                         REAL(j-1,r8)*Fdt(i,ng))* &
     &                                        day2sec
                  DRIFTER(ng)%Tinfo(izgrd,nc)=Fz0(i,ng)
                  DRIFTER(ng)%Ftype(nc)=Ftype(i,ng)
                  IF (Fcoor(i,ng).eq.0) THEN
                    DRIFTER(ng)%Tinfo(ixgrd,nc)=Fx0(i,ng)
                    DRIFTER(ng)%Tinfo(iygrd,nc)=Fy0(i,ng)
                  ELSE
                    mc=mc+1
                    DRIFTER(ng)%Flon(mc)=Fx0(i,ng)
                    DRIFTER(ng)%Flat(mc)=Fy0(i,ng)
                    DRIFTER(ng)%Findex(mc)=nc
                  END IF
                ELSE
                  DRIFTER(ng)%Tinfo(itstr,nc)=(dstart+Ft0(i,ng))*day2sec
                  IF (Fdz(i,ng).eq.0.0_r8) THEN
                    DRIFTER(ng)%Tinfo(izgrd,nc)=Fz0(i,ng)
                  ELSE
                    IF (Fz0(i,ng).gt.0.0_r8) THEN
                      zfloat=Fz0(i,ng)+REAL(j-1,r8)*Fdz(i,ng)
                      DRIFTER(ng)%Tinfo(izgrd,nc)=MIN(MAX(0.0_r8,       &
     &                                                    zfloat),      &
     &                                                REAL(N(ng),r8))
                    ELSE
                      DRIFTER(ng)%Tinfo(izgrd,nc)=Fz0(i,ng)+            &
     &                                            REAL(j-1,r8)*Fdz(i,ng)
                    END IF
                  END IF
                  DRIFTER(ng)%Ftype(nc)=Ftype(i,ng)
                  IF (Fcoor(i,ng).eq.0) THEN
                    xfloat=Fx0(i,ng)+REAL(j-1,r8)*Fdx(i,ng)
                    yfloat=Fy0(i,ng)+REAL(j-1,r8)*Fdy(i,ng)
                    DRIFTER(ng)%Tinfo(ixgrd,nc)=xfloat
                    DRIFTER(ng)%Tinfo(iygrd,nc)=yfloat
                  ELSE
                    mc=mc+1
                    DRIFTER(ng)%Flon(mc)=Fx0(i,ng)+                     &
     &                                   REAL(j-1,r8)*Fdx(i,ng)
                    DRIFTER(ng)%Flat(mc)=Fy0(i,ng)+                     &
     &                                   REAL(j-1,r8)*Fdy(i,ng)
                    DRIFTER(ng)%Findex(mc)=nc
                  END IF
                END IF
              END DO
            END IF
          END DO
          DRIFTER(ng)%Findex(0)=mc
        END IF
      END DO
!
!  Deallocate local arrays.
!
      IF (allocated(Fcoor))  deallocate ( Fcoor )
      IF (allocated(Fcount)) deallocate ( Fcount )
      IF (allocated(Ftype))  deallocate ( Ftype )
      IF (allocated(Ft0))    deallocate ( Ft0 )
      IF (allocated(Fx0))    deallocate ( Fx0 )
      IF (allocated(Fy0))    deallocate ( Fy0 )
      IF (allocated(Fz0))    deallocate ( Fz0 )
      IF (allocated(Fdt))    deallocate ( Fdt )
      IF (allocated(Fdx))    deallocate ( Fdx )
      IF (allocated(Fdy))    deallocate ( Fdy )
      IF (allocated(Fdz))    deallocate ( Fdz )
!
  40  FORMAT (/,' READ_FloatsPar - Error while reading floats',         &
     &          ' locations in input script: ',a)
  50  FORMAT (/,' READ_FloatsPar - Error while processing line: ',/,a)
  60  FORMAT (/,' READ_FloatsPar - Inconsistent number of floats to',   &
     &          ' process: ', 2i6,/,18x,'change input script.')
  70  FORMAT (/,/,' Floats Initial Locations, Grid: ',i2.2,             &
     &        /,  ' ==================================',/,/,            &
     &        15x,'Ft0',5x,'Fx0',5x,'Fy0',5x,'Fz0',                     &
     &        6x,'Fdt',6x,'Fdx',6x,'Fdy',6x,'Fdz',/)
 80   FORMAT (/,1x,i10,2x,a,t30,a)

      RETURN
      END SUBROUTINE read_FloatsPar
#endif

#ifdef STATIONS
      SUBROUTINE read_StaPar (model, inp, out, Lwrite)
!
!=======================================================================
!                                                                      !
!  This routine reads in input station parameters.                     !
!                                                                      !
!=======================================================================
!
      USE mod_param
      USE mod_parallel
# if defined BEST_NPZ
      USE mod_biology
# endif
      USE mod_iounits
      USE mod_ncparam
# if defined SEDIMENT || defined BBL_MODEL
      USE mod_sediment
# endif
      USE mod_scalars
!
      implicit none
!
!  Imported variable declarations
!
      logical, intent(in) :: Lwrite
      integer, intent(in) :: model, inp, out
!
!  Local variable declarations.
!
      integer :: Mstation, Npts, Nval
      integer :: flag, i, igrid, ista, itrc, ng, status

      integer :: decode_line, load_i, load_l, load_r

      real(r8) :: Xpos, Ypos

# if defined SOLVE3D && (defined BBL_MODEL || defined SEDIMENT)
      logical, dimension(MBOTP,Ngrids) :: Lbottom
# endif
      logical, dimension(MT,Ngrids) :: Lsta

      integer, dimension(Ngrids) :: is

      real(r8), dimension(100) :: Rval

      character (len=40 ) :: KeyWord
      character (len=256) :: line
      character (len=256), dimension(100) :: Cval
!
!-----------------------------------------------------------------------
!  Read in stations parameters.
!-----------------------------------------------------------------------
!
      DO WHILE (.TRUE.)
        READ (inp,'(a)',ERR=20,END=30) line
        status=decode_line(line, KeyWord, Nval, Cval, Rval)
        IF (status.gt.0) THEN
          IF (TRIM(KeyWord).eq.'Lstations') THEN
            Npts=load_l(Nval, Cval, Ngrids, Lstations)
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idOvel)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idOvel,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUbar)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUbar,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVbar)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVbar,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idFsur)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idFsur,:))
# if defined SEDIMENT && defined SED_MORPH
          ELSE IF (TRIM(KeyWord).eq.'Sout(idBath)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idBath,:))
# endif
          ELSE IF (TRIM(KeyWord).eq.'Sout(idTvar)') THEN
            Npts=load_l(Nval, Cval, MT*Ngrids, Lsta)
            DO ng=1,Ngrids
              DO itrc=1,NT(ng)
                Sout(idTvar(itrc),ng)=Lsta(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUsms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUsms,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVsms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVsms,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUbms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUbms,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVbms)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVbms,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUbrs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUbrs,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVbrs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVbrs,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUbws)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUbws,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVbws)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVbws,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUbcs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUbcs,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVbcs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVbcs,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUbot)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUbot,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVbot)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVbot,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUbur)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUbur,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVbvr)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVbvr,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idW2xx)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idW2xx,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idW2xy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idW2xy,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idW2yy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idW2yy,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idU2rs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idU2rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idV2rs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idV2rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idU2Sd)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idU2Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idV2Sd)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idV2Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idW3xx)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idW3xx,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idW3xy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idW3xy,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idW3yy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idW3yy,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idW3zx)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idW3zx,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idW3zy)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idW3zy,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idU3rs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idU3rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idV3rs)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idV3rs,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idU3Sd)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idU3Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idV3Sd)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idV3Sd,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWamp)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWamp,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWlen)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWlen,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWdir)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWdir,:))
# ifdef WAVES_TOP_PERIOD
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWptp)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWptp,:))
# endif
# ifdef WAVES_BOT_PERIOD
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWpbt)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWpbt,:))
# endif
# ifdef WAVES_UB
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWorb)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWorb,:))
# endif
# if defined TKE_WAVEDISS || defined WAVES_OCEAN
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWdis)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWdis,:))
# endif
# ifdef SOLVE3D
#  if defined BULK_FLUXES || defined ECOSIM || defined ATM_PRESS
          ELSE IF (TRIM(KeyWord).eq.'Sout(idPair)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idPair,:))
#  endif
#  if defined BULK_FLUXES || defined ECOSIM
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUair)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUair,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVair)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVair,:))
#  endif
          ELSE IF (TRIM(KeyWord).eq.'Sout(idTsur)') THEN
            Npts=load_l(Nval, Cval, NAT*Ngrids, Lsta)
            DO ng=1,Ngrids
              DO itrc=1,NAT
                Sout(idTsur(itrc),ng)=Lsta(itrc,ng)
              END DO
            END DO
          ELSE IF (TRIM(KeyWord).eq.'Sout(idLhea)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idLhea,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idShea)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idShea,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idLrad)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idLrad,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idSrad)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idSrad,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idSSSf)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idSSSf,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idEmPf)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idEmPf,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idevap)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idevap,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idrain)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idrain,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idDano)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idDano,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVvis)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVvis,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idTdif)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idTdif,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idSdif)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idSdif,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idHsbl)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idHsbl,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idHbbl)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idHbbl,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idPONsed)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idPONsed,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idOPALsed)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idOPALsed,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idDENITsed)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idDENITsed,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idPONbur)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idPONbur,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idOPALbur)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idOPALbur,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idMtke)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idMtke,:))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idMtls)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idMtls,:))
#  if defined BBL_MODEL || defined SEDIMENT
          ELSE IF (TRIM(KeyWord).eq.'Sout(idBott)') THEN
            Npts=load_l(Nval, Cval, MBOTP*Ngrids, Lbottom)
            DO ng=1,Ngrids
              DO itrc=1,MBOTP
                i=idBott(itrc)
                Sout(i,ng)=Lbottom(itrc,ng)
              END DO
            END DO
#  endif
# endif
# if defined SOLVE3D && defined ICE_MODEL
          ELSE IF (TRIM(KeyWord).eq.'Sout(idUice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idUice,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idVice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idVice,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idAice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idAice,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idHice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idHice,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idTice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idTice,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idTimid)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idTimid,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idSfwat)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idSfwat,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idAgeice)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idAgeice,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idIomflx)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idIomflx,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idSig11)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idSig11,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idSig12)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idSig12,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idSig22)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idSig22,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWfr)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWfr,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idTauiw)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idTauiw,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idChuiw)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idChuiw,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idT0mk)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idT0mk,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idS0mk)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idS0mk,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWfr)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWfr,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWai)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWai,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWao)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWao,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWio)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWio,1))
          ELSE IF (TRIM(KeyWord).eq.'Sout(idWro)') THEN
            Npts=load_l(Nval, Cval, Ngrids, Sout(idWro,1))
# endif
          ELSE IF (TRIM(KeyWord).eq.'NSTATION') THEN
            Npts=load_i(Nval, Rval, Ngrids, Nstation)
          ELSE IF (TRIM(KeyWord).eq.'POS') THEN
            DO ng=1,Ngrids
              allocate ( SCALARS(ng) % Sflag(Nstation(ng)) )
              allocate ( SCALARS(ng) % SposX(Nstation(ng)) )
              allocate ( SCALARS(ng) % SposY(Nstation(ng)) )
            END DO
            is(1:Ngrids)=0
            DO WHILE (.TRUE.)
              READ (inp,*,ERR=10,END=10) igrid, flag, Xpos, Ypos
              ng=MAX(1,ABS(igrid))
              is(ng)=is(ng)+1
              SCALARS(ng)%Sflag(is(ng))=flag
              SCALARS(ng)%SposX(is(ng))=Xpos
              SCALARS(ng)%SposY(is(ng))=Ypos
            END DO
 10         DO ng=1,Ngrids
              IF (Nstation(ng).ne.is(ng)) THEN
                IF (Master) WRITE (out,40) Nstation(ng), is(ng)
                exit_flag=4
                RETURN
              END IF
            END DO
          END IF
        END IF
      END DO
 20   IF (Master) WRITE (out,50) line
      exit_flag=4
      RETURN
 30   CONTINUE
!
!  Turn off the processing of stations if not running long enough to
!  create a stations file (LdefSTA=.FALSE. because nSTA < ntimes or
!  nSTA = 0 when nrrec = 0).
!
      DO ng=1,Ngrids
        IF (.not.LdefSTA(ng).and.Lstations(ng)) THEN
          Lstations(ng)=.FALSE.
        END IF
      END DO
!
!-----------------------------------------------------------------------
!  Report input parameters.
!-----------------------------------------------------------------------
!
      DO ng=1,Ngrids
        IF (.not. LdefSTA(ng) .and. Lstations(ng))                      &
     &                 Lstations(ng) = .FALSE.
      END DO
      IF (Lwrite) THEN
        DO ng=1,Ngrids
          IF (Lstations(ng)) THEN
            WRITE (out,60) ng
            WRITE (out,70) Nstation(ng), 'Nstation',                    &
     &            'Number of stations to write out into stations file.'
#if defined SEDIMENT && defined SED_MORPH
            IF (Sout(idbath,ng)) WRITE (out,80) Sout(idbath,ng),        &
     &          'Sout(idbath)',                                         &
     &          'Write out free-surface.'
#endif
            IF (Sout(idFsur,ng)) WRITE (out,80) Sout(idFsur,ng),        &
     &          'Sout(idFsur)',                                         &
     &          'Write out free-surface.'
            IF (Sout(idUbar,ng)) WRITE (out,80) Sout(idUbar,ng),        &
     &          'Sout(idUbar)',                                         &
     &          'Write out 2D U-momentum component.'
            IF (Sout(idVbar,ng)) WRITE (out,80) Sout(idVbar,ng),        &
     &          'Sout(idVbar)',                                         &
     &          'Write out 2D V-momentum component.'
# ifdef SOLVE3D
            IF (Sout(idUvel,ng)) WRITE (out,80) Sout(idUvel,ng),        &
     &          'Sout(idUvel)',                                         &
     &          'Write out 3D U-momentum component.'
            IF (Sout(idVvel,ng)) WRITE (out,80) Sout(idVvel,ng),        &
     &          'Sout(idVvel)',                                         &
     &          'Write out 3D V-momentum component.'
            IF (Sout(idWvel,ng)) WRITE (out,80) Sout(idWvel,ng),        &
     &          'Sout(idWvel)',                                         &
     &          'Write out W-momentum component.'
            IF (Sout(idOvel,ng)) WRITE (out,80) Sout(idOvel,ng),        &
     &          'Sout(idOvel)',                                         &
     &          'Write out omega vertical velocity.'
            DO itrc=1,NT(ng)
              IF (Sout(idTvar(itrc),ng)) WRITE (out,90)                 &
     &            Sout(idTvar(itrc),ng), 'Sout(idTvar)',                &
     &            'Write out tracer ', itrc, TRIM(Vname(1,idTvar(itrc)))
            END DO
# endif
            IF (Sout(idUsms,ng)) WRITE (out,80) Sout(idUsms,ng),        &
     &          'Sout(idUsms)',                                         &
     &          'Write out surface U-momentum stress.'
            IF (Sout(idVsms,ng)) WRITE (out,80) Sout(idVsms,ng),        &
     &          'Sout(idVsms)',                                         &
     &          'Write out surface V-momentum stress.'
            IF (Sout(idUbms,ng)) WRITE (out,80) Sout(idUbms,ng),        &
     &          'Sout(idUbms)',                                         &
     &          'Write out bottom U-momentum stress.'
            IF (Sout(idVbms,ng)) WRITE (out,80) Sout(idVbms,ng),        &
     &          'Sout(idVbms)',                                         &
     &          'Write out bottom V-momentum stress.'
# ifdef BBL_MODEL
            IF (Sout(idUbrs,ng)) WRITE (out,80) Sout(idUbrs,ng),        &
     &          'Sout(idUbrs)',                                         &
     &          'Write out bottom U-current stress.'
            IF (Sout(idVbrs,ng)) WRITE (out,80) Sout(idVbrs,ng),        &
     &          'Sout(idVbrs)',                                         &
     &          'Write out bottom V-current stress.'
            IF (Sout(idUbws,ng)) WRITE (out,80) Sout(idUbws,ng),        &
     &          'Sout(idUbws)',                                         &
     &          'Write out wind-induced, bottom U-wave stress.'
            IF (Sout(idVbws,ng)) WRITE (out,80) Sout(idVbws,ng),        &
     &          'Sout(idVbws)',                                         &
     &          'Write out wind-induced, bottom V-wave stress.'
            IF (Sout(idUbcs,ng)) WRITE (out,80) Sout(idUbcs,ng),        &
     &          'Sout(idUbcs)',                                         &
     &          'Write out max wind + current, bottom U-wave stress.'
            IF (Sout(idVbcs,ng)) WRITE (out,80) Sout(idVbcs,ng),        &
     &          'Sout(idVbcs)',                                         &
     &          'Write out max wind + current, bottom V-wave stress.'
            IF (Sout(idUbot,ng)) WRITE (out,80) Sout(idUbot,ng),        &
     &          'Sout(idUbot)',                                         &
     &          'Write out bed wave orbital U-velocity.'
            IF (Sout(idVbot,ng)) WRITE (out,80) Sout(idVbot,ng),        &
     &          'Sout(idVbot)',                                         &
     &          'Write out bed wave orbital V-velocity.'
            IF (Sout(idUbur,ng)) WRITE (out,80) Sout(idUbur,ng),        &
     &          'Sout(idUbur)',                                         &
     &          'Write out bottom U-velocity above bed.'
            IF (Sout(idVbvr,ng)) WRITE (out,80) Sout(idVbvr,ng),        &
     &          'Sout(idVbvr)',                                         &
     &          'Write out bottom V-velocity above bed.'
# endif
# if defined NEARSHORE_MELLOR
            IF (Sout(idW2xx,ng)) WRITE (out,80) Sout(idW2xx,ng),        &
     &         'Sout(idW2xx)',                                          &
     &         'Write out 2D radiation stress, Sxx.'
            IF (Sout(idW2xy,ng)) WRITE (out,80) Sout(idW2xy,ng),        &
     &         'Sout(idW2xy)',                                          &
     &         'Write out 2D radiation stress, Sxy.'
            IF (Sout(idW2yy,ng)) WRITE (out,80) Sout(idW2yy,ng),        &
     &         'Sout(idW2yy)',                                          &
     &         'Write out 2D radiation stress, Syy.'
            IF (Sout(idU2rs,ng)) WRITE (out,80) Sout(idU2rs,ng),        &
     &         'Sout(idU2rs)',                                          &
     &         'Write out total 2D u-radiation stress.'
            IF (Sout(idV2rs,ng)) WRITE (out,80) Sout(idV2rs,ng),        &
     &         'Sout(idV2rs)',                                          &
     &         'Write out total 2D v-radiation stress.'
            IF (Sout(idU2Sd,ng)) WRITE (out,80) Sout(idU2Sd,ng),        &
     &         'Sout(idU2Sd)',                                          &
     &         'Write out 2D u-momentum stokes velocity.'
            IF (Sout(idV2Sd,ng)) WRITE (out,80) Sout(idV2Sd,ng),        &
     &         'Sout(idV2Sd)',                                          &
     &         'Write out 2D v-momentum stokes velocity.'
#  ifdef SOLVE3D
            IF (Sout(idW3xx,ng)) WRITE (out,80) Sout(idW3xx,ng),        &
     &         'Sout(idW3xx)',                                          &
     &         'Write out 3D horizonrtal radiation stress, Sxx.'
            IF (Sout(idW3xy,ng)) WRITE (out,80) Sout(idW3xy,ng),        &
     &         'Sout(idW3xy)',                                          &
     &         'Write out 3D horizonrtal radiation stress, Sxy.'
            IF (Sout(idW3yy,ng)) WRITE (out,80) Sout(idW3yy,ng),        &
     &         'Sout(idW3yy)',                                          &
     &         'Write out 3D horizonrtal radiation stress, Syy.'
            IF (Sout(idW3zx,ng)) WRITE (out,80) Sout(idW3zx,ng),        &
     &         'Sout(idW3zx)',                                          &
     &         'Write out 3D vertical radiation stress, Spx.'
            IF (Sout(idW3zy,ng)) WRITE (out,80) Sout(idW3zy,ng),        &
     &         'Sout(idW3zy)',                                          &
     &         'Write out 3D vertical radiation stress, Spy.'
            IF (Sout(idU3rs,ng)) WRITE (out,80) Sout(idU3rs,ng),        &
     &         'Sout(idU3rs)',                                          &
     &         'Write out total 3D u-radiation stress.'
            IF (Sout(idV3rs,ng)) WRITE (out,80) Sout(idV3rs,ng),        &
     &         'Sout(idV3rs)',                                          &
     &         'Write out total 3D v-radiation stress.'
            IF (Sout(idU3Sd,ng)) WRITE (out,80) Sout(idU3Sd,ng),        &
     &         'Sout(idU3Sd)',                                          &
     &         'Write out 3D u-momentum stokes velocity.'
            IF (Sout(idV3Sd,ng)) WRITE (out,80) Sout(idV3Sd,ng),        &
     &         'Sout(idV3Sd)',                                          &
     &         'Write out 3D v-momentum stokes velocity.'
#  endif
# endif
# ifdef WAVES_HEIGHT
            IF (Sout(idWamp,ng)) WRITE (out,80) Sout(idWamp,ng),        &
     &         'Sout(idWamp)',                                          &
     &         'Write out wave height.'
# endif
# ifdef WAVES_LENGTH
            IF (Sout(idWlen,ng)) WRITE (out,80) Sout(idWlen,ng),        &
     &         'Sout(idWlen)',                                          &
     &         'Write out wave length.'
# endif
# ifdef WAVES_DIR
            IF (Sout(idWdir,ng)) WRITE (out,80) Sout(idWdir,ng),        &
     &         'Sout(idWdir)',                                          &
     &         'Write out wave direction.'
# endif
# ifdef WAVES_TOP_PERIOD
            IF (Sout(idWptp,ng)) WRITE (out,80) Sout(idWptp,ng),        &
     &         'Sout(idWptp)',                                          &
     &         'Write out wave surface period.'
# endif
# ifdef WAVES_BOT_PERIOD
            IF (Sout(idWpbt,ng)) WRITE (out,80) Sout(idWpbt,ng),        &
     &         'Sout(idWpbt)',                                          &
     &         'Write out wave bottom period.'
# endif
# ifdef WAVES_UB
            IF (Sout(idWorb,ng)) WRITE (out,80) Sout(idWorb,ng),        &
     &         'Sout(idWorb)',                                          &
     &         'Write out wave bottom orbital velocity.'
# endif
# if defined TKE_WAVEDISS || defined WAVES_OCEAN
            IF (Sout(idWdis,ng)) WRITE (out,80) Sout(idWdis,ng),        &
     &         'Sout(idWdis)',                                          &
     &         'Write out wave dissipation.'
# endif
# if defined SOLVE3D && (defined BBL_MODEL || defined SEDIMENT)
            DO itrc=1,MBOTP
              IF (Sout(idBott(itrc),ng)) WRITE (out,90)                 &
     &            Sout(idBott(itrc),ng), 'Sout(idBott)',                &
     &            'Write out bottom property ', itrc,                   &
     &            TRIM(Vname(1,idBott(itrc)))
            END DO
# endif
# ifdef SOLVE3D
#  if defined BULK_FLUXES || defined ECOSIM || defined ATM_PRESS
            IF (Sout(idPair,ng)) WRITE (out,80) Sout(idPair,ng),        &
     &          'Sout(idPair)',                                         &
     &          'Write out surface air pressure.'
#  endif
#  if defined BULK_FLUXES || defined ECOSIM
            IF (Sout(idUair,ng)) WRITE (out,80) Sout(idUair,ng),        &
     &          'Sout(idUair)',                                         &
     &          'Write out surface U-wind component.'
            IF (Sout(idVair,ng)) WRITE (out,80) Sout(idVair,ng),        &
     &          'Sout(idVair)',                                         &
     &          'Write out surface V-wind component.'
#  endif
            IF (Sout(idTsur(itemp),ng)) WRITE (out,80)                  &
     &          Sout(idTsur(itemp),ng), 'Sout(idTsur)',                 &
     &          'Write out surface net heat flux.'
            IF (Sout(idTsur(isalt),ng)) WRITE (out,80)                  &
     &          Sout(idTsur(isalt),ng), 'Sout(idTsur)',                 &
     &          'Write out surface net salt flux.'
#  ifdef SHORTWAVE
            IF (Sout(idSrad,ng)) WRITE (out,80) Sout(idSrad,ng),        &
     &          'Sout(idSrad)',                                         &
     &          'Write out shortwave radiation flux.'
#  endif
            IF (Sout(idSSSf,ng)) WRITE (out,80) Sout(idSSSf,ng),        &
     &          'Sout(idSSSf)',                                         &
     &          'Write out sea surface salinity correction flux.'
#  ifdef BULK_FLUXES
            IF (Sout(idLrad,ng)) WRITE (out,80) Sout(idLrad,ng),        &
     &          'Sout(idLrad)',                                         &
     &          'Write out longwave radiation flux.'
            IF (Sout(idLhea,ng)) WRITE (out,80) Sout(idLhea,ng),        &
     &          'Sout(idLhea)',                                         &
     &          'Write out latent heat flux.'
            IF (Sout(idShea,ng)) WRITE (out,80) Sout(idShea,ng),        &
     &          'Sout(idShea)',                                         &
     &          'Write out sensible heat flux.'
#   ifdef EMINUSP
            IF (Sout(idEmPf,ng)) WRITE (out,80) Sout(idEmPf,ng),        &
     &         'Sout(idEmPf)',                                          &
     &         'Write out E-P flux.'
            IF (Sout(idevap,ng)) WRITE (out,80) Sout(idevap,ng),        &
     &         'Sout(idevap)',                                          &
     &         'Write out evaporation rate.'
            IF (Sout(idrain,ng)) WRITE (out,80) Sout(idrain,ng),        &
     &         'Sout(idrain)',                                          &
     &         'Write out rain rate.'
#   endif
#  endif
            IF (Sout(idDano,ng)) WRITE (out,80) Sout(idDano,ng),        &
     &          'Sout(idDano)',                                         &
     &          'Write out density anomaly.'
            IF (Sout(idVvis,ng)) WRITE (out,80) Sout(idVvis,ng),        &
     &          'Sout(idVvis)',                                         &
     &          'Write out vertical viscosity coefficient.'
            IF (Sout(idTdif,ng)) WRITE (out,80) Sout(idTdif,ng),        &
     &          'Sout(idTdif)',                                         &
     &          'Write out vertical T-diffusion coefficient.'
            IF (Sout(idSdif,ng)) WRITE (out,80) Sout(idSdif,ng),        &
     &          'Sout(idSdif)',                                         &
     &          'Write out vertical S-diffusion coefficient.'
#  ifdef NEMURO_SED1
            IF (Sout(idPONsed,ng)) WRITE (out,80) Sout(idPONsed,ng),    &
     &          'Sout(idPONsed)',                                       &
     &          'Write out PON in sediment.'
            IF (Sout(idOPALsed,ng)) WRITE (out,80) Sout(idOPALsed,ng),  &
     &          'Sout(idOPALsed)',                                      &
     &          'Write out OPAL in sediment.'
            IF (Sout(idDENITsed,ng)) WRITE (out,80) Sout(idDENITsed,ng),&
     &          'Sout(idDENITsed)',                                     &
     &          'Write out DENIT in sediment.'
            IF (Sout(idPONbur,ng)) WRITE (out,80) Sout(idPONbur,ng),    &
     &          'Sout(idPONbur)',                                       &
     &          'Write out buried PON in sediment.'
            IF (Sout(idOPALbur,ng)) WRITE (out,80) Sout(idOPALbur,ng),  &
     &          'Sout(idOPALbur)',                                      &
     &          'Write out buried OPAL in sediment.'
#  endif
#  ifdef LMD_SKPP
            IF (Sout(idHsbl,ng)) WRITE (out,80) Sout(idHsbl,ng),        &
     &          'Sout(idHsbl)',                                         &
     &          'Write out depth of surface boundary layer.'
#  endif
#  ifdef LMD_BKPP
            IF (Sout(idHbbl,ng)) WRITE (out,80) Sout(idHbbl,ng),        &
     &          'Sout(idHbbl)',                                         &
     &          'Write out depth of bottom boundary layer.'
#  endif
#  if defined GLS_MIXING || defined MY25_MIXING
            IF (Sout(idMtke,ng)) WRITE (out,80) Sout(idMtke,ng),        &
     &          'Sout(idMtke)',                                         &
     &          'Write out turbulent kinetic energy.'
            IF (Sout(idMtls,ng)) WRITE (out,80) Sout(idMtls,ng),        &
     &          'Sout(idMtls)',                                         &
     &          'Write out turbulent generic length-scale.'
#  endif
# endif
# ifdef ICE_MODEL
          IF (Sout(idUice,ng)) WRITE (out,80) Sout(idUice,ng),          &
     &       'Sout(idUice)',                                            &
     &       'Write out U-component ice velocity.'
          IF (Sout(idVice,ng)) WRITE (out,80) Sout(idVice,ng),          &
     &       'Sout(idVice)',                                            &
     &       'Write out V-component ice velocity.'
          IF (Sout(idAice,ng)) WRITE (out,80) Sout(idAice,ng),          &
     &       'Sout(idAice)',                                            &
     &       'Write out ice concentration.'
          IF (Sout(idHice,ng)) WRITE (out,80) Sout(idHice,ng),          &
     &       'Sout(idHice)',                                            &
     &       'Write out average ice thickness.'
          IF (Sout(idHsno,ng)) WRITE (out,80) Sout(idHsno,ng),          &
     &       'Sout(idHsno)',                                            &
     &       'Write out snow thickness.'
# if defined ICE_BIO
          IF (Sout(idIcePhL,ng)) WRITE (out,80) Sout(idIcePhL,ng),      &
     &       'Sout(idIcePhL)',                                          &
     &       'Write out average ice algae.'
# endif
          IF (Sout(idTice,ng)) WRITE (out,80) Sout(idTice,ng),          &
     &       'Sout(idTice)',                                            &
     &       'Write out ice/snow surface temperature.'
          IF (Sout(idTimid,ng)) WRITE (out,80) Sout(idTimid,ng),        &
     &       'Sout(idTimid)',                                           &
     &       'Write out interior ice temperature.'
          IF (Sout(idSfwat,ng)) WRITE (out,80) Sout(idSfwat,ng),        &
     &       'Sout(idSfwat)',                                           &
     &       'Write out surface water (on ice) thickness.'
          IF (Sout(idAgeice,ng)) WRITE (out,80) Sout(idAgeice,ng),      &
     &       'Sout(idAgeice)',                                          &
     &       'Write out surface water (on ice) thickness.'
          IF (Sout(idIomflx,ng)) WRITE (out,80) Sout(idIomflx,ng),      &
     &       'Sout(idIomflx)',                                          &
     &       'Write out ice-ocean mass flux.'
          IF (Sout(idSig11,ng)) WRITE (out,80) Sout(idSig11,ng),        &
     &       'Sout(idSig11)',                                           &
     &       'Write out internal ice stress component 11.'
          IF (Sout(idSig12,ng)) WRITE (out,80) Sout(idSig12,ng),        &
     &       'Sout(idSig12)',                                           &
     &       'Write out internal ice stress component 12.'
          IF (Sout(idSig22,ng)) WRITE (out,80) Sout(idSig22,ng),        &
     &       'Sout(idSig22)',                                           &
     &       'Write out internal ice stress component 22.'
          IF (Sout(idTauiw,ng)) WRITE (out,80) Sout(idTauiw,ng),        &
     &       'Sout(idTauiw)',                                           &
     &       'Write out ice-water friction velocity.'
          IF (Sout(idChuiw,ng)) WRITE (out,80) Sout(idChuiw,ng),        &
     &       'Hout(idChuiw)',                                           &
     &       'Write out ice-water momentum transfer coefficient.'
          IF (Sout(idT0mk,ng)) WRITE (out,80) Sout(idT0mk,ng),          &
     &       'Sout(idT0mk)',                                            &
     &       'Write out temperature of molecular sublayer under ice.'
          IF (Sout(idS0mk,ng)) WRITE (out,80) Sout(idS0mk,ng),          &
     &       'Sout(idS0mk)',                                            &
     &       'Write out salinity of molecular sublayer under ice.'
          IF (Sout(idWfr,ng)) WRITE (out,80) Sout(idWfr,ng),            &
     &       'Sout(idWfr)',                                             &
     &       'Write out frazil ice growth rate.'
          IF (Sout(idWai,ng)) WRITE (out,80) Sout(idWai,ng),            &
     &       'Sout(idWai)',                                             &
     &       'Write out ice growth/melt rate.'
          IF (Sout(idWao,ng)) WRITE (out,80) Sout(idWao,ng),            &
     &       'Sout(idWao)',                                             &
     &       'Write out ice growth/melt rate.'
          IF (Sout(idWio,ng)) WRITE (out,80) Sout(idWio,ng),            &
     &       'Sout(idWio)',                                             &
     &       'Write out ice growth/melt rate.'
          IF (Sout(idWro,ng)) WRITE (out,80) Sout(idWro,ng),            &
     &       'Sout(idWro)',                                             &
     &       'Write out ice melt runoff rate.'
# endif

            WRITE (out,*)
            DO i=1,Nstation(ng)
              WRITE (out,100) i, SCALARS(ng)%Sflag(i),                  &
     &                           SCALARS(ng)%SposX(i),                  &
     &                           SCALARS(ng)%SposY(i)
            END DO
          END IF
        END DO
      END IF

  40  FORMAT (/,' READ_StaPar - Inconsistent number of stations, ',     &
     &        'Nstation = ',2i8,/,15x,'change input script values.')
  50  FORMAT (/,' READ_StaPar - Error while processing line: ',/,a)

  60  FORMAT (/,/,' Stations Parameters, Grid: ',i2.2,                  &
     &        /,  ' =============================',/)
  70  FORMAT (1x,i10,2x,a,t30,a)
  80  FORMAT (10x,l1,2x,a,t30,a)
  90  FORMAT (10x,l1,2x,a,t30,a,i2.2,':',1x,a)
 100  FORMAT (13x,'Flag and positions for station ',i4.4,':',           &
     &        i3,1x,2f10.4)
 110  FORMAT (/,' READ_StaPAR - variable info not yet loaded, ', a)

      RETURN
      END SUBROUTINE read_StaPar
#endif

      FUNCTION decode_line (line_text, KeyWord, Nval, Cval, Rval)
!
!=======================================================================
!                                                                      !
!  This function decodes lines of text from input script files.        !
!                                                                      !
!=======================================================================
!
      USE mod_kinds
!
      implicit none
!
! Imported variable declarations.
!
      character (len=*), intent(in) :: line_text

      character (len=40), intent(inout) :: KeyWord

      integer, intent(inout) :: Nval

      character (len=256), dimension(100), intent(inout) :: Cval

      real(r8), dimension(100), intent(inout) :: Rval
!
! Local variable declarations
!
      logical :: IsString, Kextract, decode, nested
      integer :: Iblank, Icomm, Icont, ierr, Ipipe, Kstr, Kend, Linp
      integer :: Lend, LenS, Lstr, Lval, Nmul, Schar
      integer :: copies, i, ic, ie, is, j, status

      integer, dimension(20) :: Imul

      integer :: decode_line

      character (len=1 ), parameter :: blank = ' '
      character (len=256) :: Vstring, line, string
!
!------------------------------------------------------------------------
!  Decode input line.
!------------------------------------------------------------------------
!
!  Initialize.
!
      DO i=1,LEN(line)
        line(i:i)=blank
        Vstring(i:i)=blank
        string(i:i)=blank
      END DO
!
!  Get length of "line". Remove comment after the KEYWORD, if any.
!  Then, remove leading and trailing blanks.
!
      Linp=LEN(line_text)
      IF ((Linp.gt.0).and.(line_text(1:1).ne.CHAR(33))) THEN
        Icomm=INDEX(line_text,CHAR(33),BACK=.FALSE.)
        IF (Icomm.gt.0) Linp=Icomm-1
        line=TRIM(ADJUSTL(line_text(1:Linp)))
        Linp=LEN_TRIM(line)
      ELSE
        line=TRIM(ADJUSTL(line_text))
        Linp=LEN_TRIM(line)
      END IF
!
!  If not a blank or comment line [char(33)=!], decode and extract input
!  values.  Find equal sign [char(61)].
!
      status=-1
      nested=.FALSE.
      IF ((Linp.gt.0).and.(line(1:1).ne.CHAR(33))) THEN
        status=1
        Kstr=1
        Kend=INDEX(line,CHAR(61),BACK=.FALSE.)-1
        Lstr=INDEX(line,CHAR(61),BACK=.TRUE.)+1
!
! Determine if KEYWORD is followed by double equal sign (==) indicating
! nested parameter.
!
        IF ((Lstr-Kend).eq.3) nested=.TRUE.
!
! Extract KEYWORD, trim leading and trailing blanks.
!
        Kextract=.FALSE.
        IF (Kend.gt.0) THEN
          Lend=Linp
          KeyWord=line(Kstr:Kend)
          Nval=0
          Kextract=.TRUE.
        ELSE
          Lstr=1
          Lend=Linp
          Kextract=.TRUE.
        END IF
!
! Extract parameter values string.  Remove continuation symbol
! [char(92)=\] or multi-line value [char(124)=|], if any.  Trim
! leading trailing blanks.
!
        IF (Kextract) THEN
          Icont=INDEX(line,CHAR(92 ),BACK=.FALSE.)
          Ipipe=INDEX(line,CHAR(124),BACK=.FALSE.)
          IF (Icont.gt.0) Lend=Icont-1
          IF (Ipipe.gt.0) Lend=Ipipe-1
          Vstring=ADJUSTL(line(Lstr:Lend))
          Lval=LEN_TRIM(Vstring)
!
! The TITLE KEYWORD is a special one since it can include strings,
! numbers, spaces, and continuation symbol.
!
          IsString=.FALSE.
          IF (TRIM(KeyWord).eq.'TITLE') THEN
            Nval=Nval+1
            Cval(Nval)=Vstring(1:Lval)
            IsString=.TRUE.
          ELSE
!
! Check if there is a multiplication symbol [char(42)=*] in the variable
! string indicating repetition of input values.
!
            Nmul=0
            DO i=1,Lval
              IF (Vstring(i:i).eq.CHAR(42)) THEN
                Nmul=Nmul+1
                Imul(Nmul)=i
              END IF
            END DO
            ic=1
!
! Check for blank spaces [char(32)=' '] between entries and decode.
!
            is=1
            ie=Lval
            Iblank=0
            decode=.FALSE.
            DO i=1,Lval
              IF (Vstring(i:i).eq.CHAR(32)) THEN
                IF (Vstring(i+1:i+1).ne.CHAR(32)) decode=.TRUE.
                Iblank=i
              ELSE
                ie=i
              ENDIF
              IF (decode.or.(i.eq.Lval)) THEN
                Nval=Nval+1
!
! Processing numeric values.  Check starting character to determine
! if numeric or character values. It is possible to have both when
! processing repetitions via the multiplication symbol.
!
                Schar=ICHAR(Vstring(is:is))
                IF (((48.le.Schar).and.(Schar.le.57)).or.               &
     &              (Schar.eq.43).or.(Schar.eq.45)) THEN
                  IF ((Nmul.gt.0).and.                                  &
     &                (is.lt.Imul(ic)).and.(Imul(ic).lt.ie)) THEN
                    READ (Vstring(is:Imul(ic)-1),*) copies
                    Schar=ICHAR(Vstring(Imul(ic)+1:Imul(ic)+1))
                    IF ((43.le.Schar).and.(Schar.le.57)) THEN
                      READ (Vstring(Imul(ic)+1:ie),*) Rval(Nval)
                      DO j=1,copies-1
                        Rval(Nval+j)=Rval(Nval)
                      END DO
                    ELSE
                      string=Vstring(Imul(ic)+1:ie)
                      LenS=LEN_TRIM(string)
                      Cval(Nval)=string(1:LenS)
                      DO j=1,copies-1
                        Cval(Nval+j)=Cval(Nval)
                      END DO
                    END IF
                    Nval=Nval+copies-1
                    ic=ic+1
                  ELSE
                    string=Vstring(is:ie)
                    LenS=LEN_TRIM(string)
!                   READ (string(1:LenS),*) Rval(Nval)
                    READ (string(1:LenS),*,IOSTAT=ierr) Rval(Nval)
                    if (ierr.ne.0) then
                      write(*,*)                                        &
     &     '#### ERROR :: Cannot interpret string ', string(1:LenS),    &
	' as a REAL number.'
                    end if
                  END IF
                ELSE
!
! Processing character values (logicals and strings).
!
                  IF ((Nmul.gt.0).and.                                  &
     &                (is.lt.Imul(ic)).and.(Imul(ic).lt.ie)) THEN
                    READ (Vstring(is:Imul(ic)-1),*) copies
                    Cval(Nval)=Vstring(Imul(ic)+1:ie)
                    DO j=1,copies-1
                      Cval(Nval+j)=Cval(Nval)
                    END DO
                    Nval=Nval+copies-1
                    ic=ic+1
                  ELSE
                    string=Vstring(is:ie)
                    Cval(Nval)=TRIM(ADJUSTL(string))
                  END IF
                  IsString=.TRUE.
                END IF
                is=Iblank+1
                ie=Lval
                decode=.FALSE.
              END IF
            END DO
          END IF
        END IF
        status=Nval
      END IF
      decode_line=status
      RETURN
      END FUNCTION decode_line

      FUNCTION find_file (ng, fname) RESULT (foundit)
!
!=======================================================================
!                                                                      !
!  This function checks if provided input file exits.                  !
!                                                                      !
!  On Input:                                                           !
!                                                                      !
!     ng         Nested grid number.                                   !
!     fname      File name (path and name).                            !
!                                                                      !
!  On Output:                                                          !
!                                                                      !
!     foundit    The value of the result is TRUE/FALSE if the file     !
!                  was found or not.                                   !
!                                                                      !
!=======================================================================
!
      USE mod_kinds
      USE mod_param
      USE mod_iounits
      USE mod_netcdf
      USE mod_scalars
!
      implicit none
!
!  Imported variable declarations.
!
      integer, intent(in) :: ng

      character (len=*), intent(in) :: fname
!
!  Local variable declarations.
!
      logical :: foundit, isURL

      integer :: ncid
!
      SourceFile='inp_par.F, find_file'
!
!-----------------------------------------------------------------------
!  Check if the file exit.
!-----------------------------------------------------------------------
!
      foundit=.FALSE.
!
!  Check if provided file is a URL.  This implies the file is a NetCDF
!  file on Data Access Protocol (DAP) server (like OPeNDAP).
!
      isURL=.FALSE.
      IF (INDEX(TRIM(fname),'http:').ne.0) THEN
        isURL=.TRUE.
      END IF
!
!  Use F90 intrinsic function for non URL files.
!
      IF (.not.isURL) THEN
        INQUIRE (FILE=TRIM(fname), EXIST=foundit)
!
!  Use NetCDF library (version 4.1.1 or higher) to check URL NetCDF
!  files.
!
      ELSE
        CALL netcdf_open (ng, iNLM, fname, 0, ncid)
        IF (exit_flag.eq.NoError) THEN
          foundit=.TRUE.
        END IF
      END IF

      RETURN
      END FUNCTION find_file

      FUNCTION load_i (Ninp, Vinp, Nout, Vout)
!
!=======================================================================
!                                                                      !
!  This function loads input values into a requested model integer     !
!  variable.                                                           !
!                                                                      !
!  On Input:                                                           !
!                                                                      !
!     Ninp       Size of input variable.                               !
!     Vinp       Input values                                          !
!     Nout       Number of output values.                              !
!                                                                      !
!  On Output:                                                          !
!                                                                      !
!     Vout       Output integer variable.                              !
!     load_i     Number of output values processed.                    !
!                                                                      !
!=======================================================================
!
      USE mod_kinds
!
      implicit none
!
!  Imported variable declarations.
!
      integer, intent(in) :: Ninp, Nout
      real(r8), intent(in) :: Vinp(Ninp)
      integer, intent(out) :: Vout(Nout)
!
!  Local variable declarations.
!
      integer :: i, ic
      integer :: load_i
!
!-----------------------------------------------------------------------
!  Load integer variable with input values.
!-----------------------------------------------------------------------
!
!  If not all values are provided for variable, assume the last value
!  for the rest of the array.
!
      ic=0
      IF (Ninp.le.Nout) THEN
        DO i=1,Ninp
          ic=ic+1
          Vout(i)=INT(Vinp(i))
        END DO
        DO i=Ninp+1,Nout
          ic=ic+1
          Vout(i)=INT(Vinp(Ninp))
        END DO
      ELSE
        DO i=1,Nout
          ic=ic+1
          Vout(i)=INT(Vinp(i))
        END DO
      END IF
      load_i=ic

      RETURN
      END FUNCTION load_i

      FUNCTION load_l (Ninp, Vinp, Nout, Vout)
!
!=======================================================================
!                                                                      !
!  This function loads input values into a requested model logical     !
!  variable.                                                           !
!                                                                      !
!  On Input:                                                           !
!                                                                      !
!     Ninp       Size of input variable.                               !
!     Vinp       Input values                                          !
!     Nout       Number of output values.                              !
!                                                                      !
!  On Output:                                                          !
!                                                                      !
!     Vout       Output integer variable.                              !
!     load_l     Number of output values processed.                    !
!                                                                      !
!=======================================================================
!
      USE mod_kinds
!
      implicit none
!
!  Imported variable declarations.
!
      integer, intent(in) :: Ninp, Nout
      character (len=*), intent(in) :: Vinp(Ninp)
      logical, intent(out) :: Vout(Nout)
!
!  Local variable declarations.
!
      integer :: i, ic
      integer :: load_l
!
!-----------------------------------------------------------------------
!  Load integer variable with input values.
!-----------------------------------------------------------------------
!
!  If not all values are provided for variable, assume the last value
!  for the rest of the array.
!
      ic=0
      IF (Ninp.le.Nout) THEN
        DO i=1,Ninp
          ic=ic+1
          IF ((Vinp(i)(1:1).eq.'T').or.(Vinp(i)(1:1).eq.'t')) THEN
            Vout(i)=.TRUE.
          ELSE
            Vout(i)=.FALSE.
          END IF
        END DO
        DO i=Ninp+1,Nout
          ic=ic+1
          IF ((Vinp(Ninp)(1:1).eq.'T').or.(Vinp(Ninp)(1:1).eq.'t')) THEN
            Vout(i)=.TRUE.
          ELSE
            Vout(i)=.FALSE.
          END IF
        END DO
      ELSE
        DO i=1,Nout
          ic=ic+1
          IF ((Vinp(i)(1:1).eq.'T').or.(Vinp(i)(1:1).eq.'t')) THEN
            Vout(i)=.TRUE.
          ELSE
            Vout(i)=.FALSE.
          END IF
        END DO
      END IF
      load_l=ic

      RETURN
      END FUNCTION load_l

      FUNCTION load_r (Ninp, Vinp, Nout, Vout)
!
!=======================================================================
!                                                                      !
!  This function loads input values into a requested model real        !
!  variable.                                                           !
!                                                                      !
!  On Input:                                                           !
!                                                                      !
!     Ninp       Size of input variable.                               !
!     Vinp       Input values                                          !
!     Nout       Number of output values.                              !
!                                                                      !
!  On Output:                                                          !
!                                                                      !
!     Vout       Output real variable.                                 !
!     load_r     Number of output values processed.                    !
!                                                                      !
!=======================================================================
!
      USE mod_kinds
!
      implicit none
!
!  Imported variable declarations.
!
      integer, intent(in) :: Ninp, Nout
      real(r8), intent(in) :: Vinp(Ninp)
      real(r8), intent(out) :: Vout(Nout)
!
!  Local variable declarations.
!
      integer :: i, ic
      integer :: load_r
!
!-----------------------------------------------------------------------
!  Load integer variable with input values.
!-----------------------------------------------------------------------
!
!  If not all values are provided for variable, assume the last value
!  for the rest of the array.
!
      ic=0
      IF (Ninp.le.Nout) THEN
        DO i=1,Ninp
          ic=ic+1
          Vout(i)=Vinp(i)
        END DO
        DO i=Ninp+1,Nout
          ic=ic+1
          Vout(i)=Vinp(Ninp)
        END DO
      ELSE
        DO i=1,Nout
          ic=ic+1
          Vout(i)=Vinp(i)
        END DO
      END IF
      load_r=ic

      RETURN
      END FUNCTION load_r

      FUNCTION load_s1d (Nval, Fname, line, label, igrid, Nfiles, S)
!
!=======================================================================
!                                                                      !
!  This function loads input values into requested 1D structure        !
!  containing information about I/O files.                             !
!                                                                      !
!  On Input:                                                           !
!                                                                      !
!     Nval       Number of values processed (integer)                  !
!     Fname      File name(s) processed (string array)                 !
!     line       Current input line (string)                           !
!     label      I/O structure label (string)                          !
!     igrid      Nested grid counter (integer)                         !
!     Nfiles     Number of files per grid (integer array)              !
!     S          Derived type structure, TYPE(IO)                      !
!                                                                      !
!  On Output:                                                          !
!                                                                      !
!     igrid      Updated nested grid counter.                          !
!     S          Updated derived type structure, TYPE(IO).             !
!     load_s1d   Number of output values processed.                    !
!                                                                      !
!=======================================================================
!
      USE mod_param
      USE mod_parallel
      USE mod_iounits
      USE mod_ncparam
      USE mod_scalars
!
      implicit none
!
!  Imported variable declarations.
!
      integer, intent(in)    :: Nval
      integer, intent(inout) :: igrid
      integer, intent(inout) :: Nfiles(Ngrids)

      character (len=*),   intent(in) :: line
      character (len=256), intent(in) :: Fname(100)
      character (len=*),   intent(inout) :: label

      TYPE(T_IO), intent(inout) :: S(Ngrids)
!
!  Local variable declarations.
!
      logical :: load

      integer :: Icont, Ipipe, i, j, lstr, ng
      integer :: load_s1d

      character (len=1 ), parameter :: blank = ' '
!
!-----------------------------------------------------------------------
!  Count files for all grids and activate load switch.
!-----------------------------------------------------------------------
!
!  Check current line for the continuation symbol [char(92)=\] or pipe
!  symbol [char(124)=|]. The continuation symbol is used to separate
!  string values for different grid, whereas the pipe symbol is used
!  to separate multi-string values for split input files. User may
!  split the records for a particular input field into several files.
!
      Icont=INDEX(TRIM(line),CHAR(92) ,BACK=.FALSE.)
      Ipipe=INDEX(TRIM(line),CHAR(124),BACK=.FALSE.)
      IF ((Icont.eq.0).and.(Ipipe.eq.0)) THEN
        load=.TRUE.                           ! last input string
      ELSE
        load=.FALSE.                          ! process next string
      END IF
!
!  Accumulate number of multi-files per each grid.
!
      Nfiles(igrid)=Nfiles(igrid)+1
!
!  Set grid counter.
!
      IF (.not.load) THEN
        igrid=igrid+MIN(1,Icont)
      END IF
      IF (igrid.gt.Ngrids) THEN
        IF (Master) THEN
          WRITE (stdout,10) TRIM(line)
        END IF
        exit_flag=2
        RETURN
      END IF
!
!-----------------------------------------------------------------------
!  Load I/O information into structure.
!-----------------------------------------------------------------------
!
      IF (load) THEN
!
!  Allocate various fields in structure, if not continuation or pipe
!  symbol is found which indicates end of input data.
!
        DO ng=1,Ngrids
          allocate ( S(ng)%Nrec(Nfiles(ng)) )
          allocate ( S(ng)%time_min(Nfiles(ng)) )
          allocate ( S(ng)%time_max(Nfiles(ng)) )
          IF (label(1:3).eq.'FLT') THEN
            allocate ( S(ng)%Vid(-6:NV) )
          ELSE
            allocate ( S(ng)%Vid(NV) )
          END IF
          allocate ( S(ng)%Tid(MT) )
          allocate ( S(ng)%files(Nfiles(ng)) )
        END DO
!
!  Intialize strings to blank to facilitate processing.
!
        DO ng=1,Ngrids
          lstr=LEN(S(ng)%name)
          DO i=1,lstr
            S(ng)%base(i:i)=blank
            S(ng)%name(i:i)=blank
          END DO
          DO j=1,Nfiles(ng)
            DO i=1,lstr
              S(ng)%files(j)(i:i)=blank
            END DO
          END DO
        END DO
!
!  Initialize and load fields into structure.
!
        i=0
        DO ng=1,Ngrids
          S(ng)%Nfiles=Nfiles(ng)              ! number of multi-files
          S(ng)%Fcount=1                       ! multi-file counter
          S(ng)%Rindex=0                       ! time index
          S(ng)%ncid=-1                        ! closed NetCDF state
          S(ng)%Vid=-1                         ! NetCDF variables IDs
          S(ng)%Tid=-1                         ! NetCDF tracers IDs
          DO j=1,Nfiles(ng)
            i=i+1
            S(ng)%files(j)=TRIM(Fname(i))      ! load multi-files
            S(ng)%Nrec(j)=0                    ! record counter
            S(ng)%time_min(j)=0.0_r8           ! starting time
            S(ng)%time_max(j)=0.0_r8           ! ending time
          END DO
          S(ng)%label=TRIM(label)              ! structure label
          S(ng)%name=TRIM(S(ng)%files(1))      ! load first file
          lstr=LEN_TRIM(S(ng)%name)
          S(ng)%base=S(ng)%name(1:lstr-3)      ! do not include ".nc"
          Nfiles(ng)=0                         ! clean file counter
        END DO
!
!  Reset counters and clean label.
!
        igrid=1
        DO ng=1,Ngrids
          Nfiles(ng)=0
        END DO
        DO i=1,LEN(label)
          label(i:i)=blank
        END DO
      END IF
      load_s1d=Nval

 10   FORMAT (/,' INP_PAR - incorrect continuation symbol in line:',/,  &
     &        11x,a,/,11x,'number of nested grid values exceeded.')

      RETURN
      END FUNCTION load_s1d

      FUNCTION load_s2d (Nval, Fname, line, label, ifile, igrid,        &
     &                   Nfiles, idim, S)
!
!=======================================================================
!                                                                      !
!  This function loads input values into requested 2D structure        !
!  containing information about input forcing files.                   !
!                                                                      !
!  On Input:                                                           !
!                                                                      !
!     Nval       Number of values processed (integer)                  !
!     Fname      File name(s) processed (string array)                 !
!     line       Current input line (string)                           !
!     label      I/O structure label (string)                          !
!     ifile      File structure counter (integer)                      !
!     igrid      Nested grid counter (integer)                         !
!     Nfiles     Number of files per grid counter (integer array)      !
!     idim       Size of structure inner dimension (integer)           !
!     S          Derived type structure, TYPE(IO)                      !
!                                                                      !
!  On Output:                                                          !
!                                                                      !
!     ifile      Updated file counter.                                 !
!     igrid      Updated nested grid counter.                          !
!     S          Updated derived type structure, TYPE(IO).             !
!     load_s2d   Number of output values processed.                    !
!                                                                      !
!=======================================================================
!
      USE mod_param
      USE mod_parallel
      USE mod_iounits
      USE mod_ncparam
      USE mod_scalars
!
      implicit none
!
!  Imported variable declarations.
!
      integer, intent(in)    :: Nval, idim
      integer, intent(inout) :: ifile, igrid
      integer, intent(inout) :: Nfiles(idim,Ngrids)

      character (len=*),   intent(in) :: line
      character (len=256), intent(in) :: Fname(100)
      character (len=*),   intent(inout) :: label

      TYPE(T_IO), intent(inout) :: S(idim,Ngrids)
!
!  Local variable declarations.
!
      logical :: load

      integer :: Icont, Ipipe, i, j, k, lstr, ng
      integer :: load_s2d

      character (len=1 ), parameter :: blank = ' '
!
!-----------------------------------------------------------------------
!  Count files for all grids and activate load switch.
!-----------------------------------------------------------------------
!
!  Check current line for the continuation symbol [char(92)=\] or pipe
!  symbol [char(124)=|]. The continuation symbol is used to separate
!  string values for different grid, whereas the pipe symbol is used
!  to separate multi-string values for split input files. User may
!  split the records for a particular input field into several files.
!
      Icont=INDEX(TRIM(line),CHAR(92) ,BACK=.FALSE.)
      Ipipe=INDEX(TRIM(line),CHAR(124),BACK=.FALSE.)
      IF ((Icont.eq.0).and.(Ipipe.eq.0)) THEN
        load=.TRUE.                           ! last input string
      ELSE
        load=.FALSE.                          ! process next string
      END IF
!
!  Accumulate number of multi-files per each grid.
!
      Nfiles(ifile,igrid)=Nfiles(ifile,igrid)+1
!
!  Set counters for next processing file, if any.  The continuation
!  symbol in the input "line" is used to advance the counters.
!
      IF (.not.load) THEN
        IF (ifile.le.nFfiles(igrid)) THEN
          ifile=ifile+MIN(1,Icont)
        ELSE
          ifile=1
          igrid=igrid+MIN(1,Icont)
        END IF
      END IF
      IF (ifile.gt.idim) THEN
        IF (Master) THEN
          WRITE (stdout,10) TRIM(line)
        END IF
        exit_flag=2
        RETURN
      END IF
      IF (igrid.gt.Ngrids) THEN
        IF (Master) THEN
          WRITE (stdout,20) TRIM(line)
        END IF
        exit_flag=2
        RETURN
      END IF
!
!-----------------------------------------------------------------------
!  Load I/O information into structure.
!-----------------------------------------------------------------------
!
      IF (load) THEN
!
!  Allocate various fields in structure, if not continuation or pipe
!  symbol is found which indicates end of input data.
!
        DO ng=1,Ngrids
          DO i=1,idim
            allocate ( S(i,ng)%Nrec(Nfiles(i,ng)) )
            allocate ( S(i,ng)%time_min(Nfiles(i,ng)) )
            allocate ( S(i,ng)%time_max(Nfiles(i,ng)) )
            allocate ( S(i,ng)%Vid(NV) )
            allocate ( S(i,ng)%Tid(MT) )
            allocate ( S(i,ng)%files(Nfiles(i,ng)) )
          END DO
        END DO
!
!  Intialize strings to blank to facilitate processing.
!
        DO ng=1,Ngrids
          DO i=1,idim
            lstr=LEN(S(i,ng)%name)
            DO j=1,lstr
              S(i,ng)%base(j:j)=blank
              S(i,ng)%name(j:j)=blank
            END DO
            DO k=1,Nfiles(i,ng)
              DO j=1,lstr
                S(i,ng)%files(k)(j:j)=blank
              END DO
            END DO
          END DO
        END DO
!
!  Initialize and load fields into structure.
!
        k=0
        DO ng=1,Ngrids
          DO i=1,idim
            S(i,ng)%Nfiles=Nfiles(i,ng)         ! number of multi-files
            S(i,ng)%Fcount=1                    ! multi-file counter
            S(i,ng)%Rindex=0                    ! time index
            S(i,ng)%ncid=-1                     ! closed NetCDF state
            S(i,ng)%Vid=-1                      ! NetCDF variables IDs
            S(i,ng)%Tid=-1                      ! NetCDF tracers IDs
            DO j=1,Nfiles(i,ng)
              k=k+1
              S(i,ng)%files(j)=TRIM(Fname(k))   ! load multi-files
              S(i,ng)%Nrec(j)=0                 ! record counter
              S(i,ng)%time_min(j)=0.0_r8        ! starting time
              S(i,ng)%time_max(j)=0.0_r8        ! ending time
            END DO
            S(i,ng)%label=TRIM(label)           ! structure label
            S(i,ng)%name=TRIM(S(i,ng)%files(1)) ! load first file
            lstr=LEN_TRIM(S(i,ng)%name)
            S(i,ng)%base=S(i,ng)%name(1:lstr-3) ! do not include ".nc"
          END DO
        END DO
!
!  Reset counters and clean label.
!
        igrid=1
        ifile=1
        DO ng=1,Ngrids
          DO i=1,idim
            Nfiles(i,ng)=0
          END DO
        END DO
        DO i=1,LEN(label)
          label(i:i)=blank
        END DO
      END IF
      load_s2d=Nval

 10   FORMAT (/,' INP_PAR - incorrect continuation symbol in line:',/,  &
     &        11x,a,/,11x,'inner dimension of structure exceeded.')
 20   FORMAT (/,' INP_PAR - incorrect continuation symbol in line:',/,  &
     &        11x,a,/,11x,'number of nested grid values exceeded.')

      RETURN
      END FUNCTION load_s2d
